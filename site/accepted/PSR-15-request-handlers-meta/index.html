
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Цель данного PSR — определить формальные интерфейсы для обработчиков HTTP-запросов на стороне сервера и middleware, совместимых с PSR-7.">
      
      
      
        <link rel="canonical" href="https://php-psr.ru/accepted/PSR-15-request-handlers-meta/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.3">
    
    
      
        <title>Мета-документ: Обработчики HTTP-запросов на стороне сервера - Рекомендации по стандартам PHP: PSR</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#-http-" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Рекомендации по стандартам PHP: PSR" class="md-header__button md-logo" aria-label="Рекомендации по стандартам PHP: PSR" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Рекомендации по стандартам PHP: PSR
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Мета-документ: Обработчики HTTP-запросов на стороне сервера
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Рекомендации по стандартам PHP: PSR" class="md-nav__button md-logo" aria-label="Рекомендации по стандартам PHP: PSR" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Рекомендации по стандартам PHP: PSR
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Рекомендации по стандартам PHP (PSR)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../PSR-0/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Стандарт автозагрузки PSR-0 (Устарело)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../PSR-1-basic-coding-standard/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Основной стандарт кодирования PSR-1
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../PSR-2-coding-style-guide/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Руководство по стилю кодирования PSR-2
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../PSR-3-logger-interface/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Общий интерфейс логирования PSR-3
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../PSR-4-autoloader/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Стандарт автозагрузки PSR-4
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../proposed/phpdoc/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    PHPDoc PSR-5
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../PSR-6-cache/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Общий интерфейс кэширования PSR-6
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../PSR-7-http-message/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Интерфейсы HTTP-сообщений PSR-7
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../PSR-12-extended-coding-style-guide/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Расширенное руководство по стилю кодирования PSR-12
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../PSR-17-http-factory/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    HTTP-фабрики PSR-17
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../PSR-18-http-client/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    HTTP-клиент PSR-18
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../proposed/phpdoc-tags/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Теги PHPDoc PSR-19
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../LICENSE/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Лицензия
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. Краткое описание
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Зачем это нужно?
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Область применения
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Область применения">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.1 Цели
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.2 Не является целью
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Подходы к обработчикам запросов
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-middleware" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Подходы к middleware
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5. Подходы к middleware">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-double-pass" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.1 Double Pass (двойная передача)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5.1 Double Pass (двойная передача)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#511-double-pass" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.1.1 Проекты, использующие Double Pass
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#512-middleware-double-pass" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.1.2 Middleware, реализующее Double Pass
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-single-pass-lambda" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.2 Single Pass (Lambda)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5.2 Single Pass (Lambda)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#521-single-pass" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.2.1 Проекты, использующие Single Pass
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#522-single-pass" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.2.2 Дополнительные проекты, использующие Single Pass
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.3 Сравнение подходов
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.4 Выбранный подход
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    <span class="md-ellipsis">
      
        6. Проектные решения
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6. Проектные решения">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61" class="md-nav__link">
    <span class="md-ellipsis">
      
        6.1 Проектирование обработчика запросов
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.1 Проектирование обработчика запросов">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        Почему требуется серверный запрос?
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#handler" class="md-nav__link">
    <span class="md-ellipsis">
      
        Почему используется термин «handler» (обработчик)?
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#__invoke" class="md-nav__link">
    <span class="md-ellipsis">
      
        Почему обработчик запросов не использует __invoke?
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-middleware" class="md-nav__link">
    <span class="md-ellipsis">
      
        6.2 Проектирование middleware
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.2 Проектирование middleware">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#middleware-__invoke" class="md-nav__link">
    <span class="md-ellipsis">
      
        Почему middleware не использует __invoke?
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#process" class="md-nav__link">
    <span class="md-ellipsis">
      
        Почему метод называется process()?
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      
        Почему требуется серверный запрос?
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      
        Какова роль обработчика запросов?
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63" class="md-nav__link">
    <span class="md-ellipsis">
      
        6.3 Примеры взаимодействия интерфейсов
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.3 Примеры взаимодействия интерфейсов">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      
        Обработчик запросов на основе очереди
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      
        Обработчик запросов на основе декорирования
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#middleware" class="md-nav__link">
    <span class="md-ellipsis">
      
        Примеры переиспользуемого middleware
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    <span class="md-ellipsis">
      
        7. Участники
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8" class="md-nav__link">
    <span class="md-ellipsis">
      
        8. Голосования
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9" class="md-nav__link">
    <span class="md-ellipsis">
      
        9. Полезные ссылки
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    <span class="md-ellipsis">
      
        10. Замечания и исправления
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="-http-">Мета-документ: Обработчики HTTP-запросов на стороне сервера</h1>
<h2 id="1">1. Краткое описание</h2>
<p>Цель данного PSR — определить формальные интерфейсы для обработчиков HTTP-запросов на стороне сервера («обработчики запросов») и промежуточного программного обеспечения HTTP-сервера («middleware»), совместимых с HTTP-сообщениями, определёнными в <a href="https://www.php-fig.org/psr/psr-7/">PSR-7</a> или последующих заменяющих PSR.</p>
<p><em>Примечание: все ссылки на «обработчики запросов» и «middleware» относятся исключительно к обработке <strong>серверных запросов</strong>.</em></p>
<h2 id="2">2. Зачем это нужно?</h2>
<p>Спецификация HTTP-сообщений не содержит никаких ссылок на обработчики запросов или middleware.</p>
<p>Обработчики запросов являются фундаментальной частью любого веб-приложения. Обработчик — это компонент, получающий запрос и формирующий ответ. Практически весь код, работающий с HTTP-сообщениями, содержит какой-либо обработчик запросов.</p>
<p><a href="https://en.wikipedia.org/wiki/Middleware">Middleware</a> существует в экосистеме PHP уже много лет. Общая концепция переиспользуемого middleware была популяризована <a href="http://stackphp.com/">StackPHP</a>. После появления HTTP-сообщений в виде PSR многие фреймворки внедрили middleware, использующее интерфейсы HTTP-сообщений.</p>
<p>Принятие формальных интерфейсов для обработчиков запросов и middleware устраняет ряд проблем и даёт следующие преимущества:</p>
<ul>
<li>Предоставляет разработчикам формальный стандарт.</li>
<li>Позволяет любому компоненту middleware работать в любом совместимом фреймворке.</li>
<li>Устраняет дублирование схожих интерфейсов, определённых в различных фреймворках.</li>
<li>Исключает незначительные расхождения в сигнатурах методов.</li>
</ul>
<h2 id="3">3. Область применения</h2>
<h3 id="31">3.1 Цели</h3>
<ul>
<li>Создать интерфейс обработчика запросов, использующий HTTP-сообщения.</li>
<li>Создать интерфейс middleware, использующий HTTP-сообщения.</li>
<li>Реализовать сигнатуры обработчика запросов и middleware, основанные на лучших практиках.</li>
<li>Обеспечить совместимость обработчиков запросов и middleware с любой реализацией HTTP-сообщений.</li>
</ul>
<h3 id="32">3.2 Не является целью</h3>
<ul>
<li>Определение механизма создания HTTP-ответов.</li>
<li>Определение интерфейсов для клиентского/асинхронного middleware.</li>
<li>Определение способа диспетчеризации middleware.</li>
</ul>
<h2 id="4">4. Подходы к обработчикам запросов</h2>
<p>Существует множество подходов к обработчикам запросов, использующим HTTP-сообщения. Однако общий процесс одинаков во всех из них:</p>
<p>На основе HTTP-запроса сформировать HTTP-ответ для данного запроса.</p>
<p>Внутренние требования этого процесса будут варьироваться от фреймворка к фреймворку и от приложения к приложению. Данное предложение не стремится определить, каким должен быть этот процесс.</p>
<h2 id="5-middleware">5. Подходы к middleware</h2>
<p>В настоящее время существуют два распространённых подхода к middleware, использующему HTTP-сообщения.</p>
<h3 id="51-double-pass">5.1 Double Pass (двойная передача)</h3>
<p>Сигнатура, используемая большинством реализаций middleware, была в основном одинаковой и основана на <a href="http://expressjs.com/en/guide/writing-middleware.html">Express middleware</a>, которое определяется следующим образом:</p>
<pre><code>fn(request, response, next): response
</code></pre>
<p>На основе реализаций middleware, уже используемых фреймворками, принявшими данную сигнатуру, можно выделить следующие общие черты:</p>
<ul>
<li>Middleware определяется как <a href="http://php.net/manual/language.types.callable.php">callable</a>.</li>
<li>При вызове middleware передаётся 3 аргумента:</li>
<li>Реализация <code>ServerRequestInterface</code>.</li>
<li>Реализация <code>ResponseInterface</code>.</li>
<li><code>callable</code>, принимающий запрос и ответ для делегирования следующему middleware.</li>
</ul>
<p>Значительное число проектов предоставляет и/или использует один и тот же интерфейс. Данный подход часто называют «double pass» («двойная передача»), поскольку в middleware передаются и запрос, и ответ.</p>
<h4 id="511-double-pass">5.1.1 Проекты, использующие Double Pass</h4>
<ul>
<li><a href="https://github.com/mindplay-dk/middleman/blob/1.0.0/src/MiddlewareInterface.php#L24">mindplay/middleman v1</a></li>
<li><a href="https://github.com/relayphp/Relay.Relay/blob/1.0.0/src/MiddlewareInterface.php#L24">relay/relay v1</a></li>
<li><a href="https://github.com/slimphp/Slim/blob/3.4.0/Slim/MiddlewareAwareTrait.php#L66-L75">slim/slim v3</a></li>
<li><a href="https://github.com/zendframework/zend-stratigility/blob/1.0.0/src/MiddlewarePipe.php#L69-L79">zendframework/zend-stratigility v1</a></li>
</ul>
<h4 id="512-middleware-double-pass">5.1.2 Middleware, реализующее Double Pass</h4>
<ul>
<li><a href="https://github.com/bitExpert/adroit">bitexpert/adroit</a></li>
<li><a href="https://github.com/akrabat/rka-ip-address-middleware">akrabat/rka-ip-address-middleware</a></li>
<li><a href="https://github.com/akrabat/rka-scheme-and-host-detection-middleware">akrabat/rka-scheme-and-host-detection-middleware</a></li>
<li><a href="https://github.com/bearsunday/BEAR.Middleware">bear/middleware</a></li>
<li><a href="https://github.com/Lansoweb/api-problem">los/api-problem</a></li>
<li><a href="https://github.com/Lansoweb/LosRateLimit">los/los-rate-limit</a></li>
<li><a href="https://github.com/monii/monii-action-handler-psr7-middleware">monii/monii-action-handler-psr7-middleware</a></li>
<li><a href="https://github.com/monii/monii-nikic-fast-route-psr7-middleware">monii/monii-nikic-fast-route-psr7-middleware</a></li>
<li><a href="https://github.com/monii/monii-response-assertion-psr7-middleware">monii/monii-response-assertion-psr7-middleware</a></li>
<li><a href="https://github.com/mtymek/blast-base-url">mtymek/blast-base-url</a></li>
<li><a href="https://github.com/Ocramius/PSR7Session">ocramius/psr7-session</a></li>
<li><a href="https://github.com/oscarotero/psr7-middlewares">oscarotero/psr7-middlewares</a></li>
<li><a href="https://github.com/php-middleware/block-robots">php-middleware/block-robots</a></li>
<li><a href="https://github.com/php-middleware/http-authentication">php-middleware/http-authentication</a></li>
<li><a href="https://github.com/php-middleware/log-http-messages">php-middleware/log-http-messages</a></li>
<li><a href="https://github.com/php-middleware/maintenance">php-middleware/maintenance</a></li>
<li><a href="https://github.com/php-middleware/phpdebugbar">php-middleware/phpdebugbar</a></li>
<li><a href="https://github.com/php-middleware/request-id">php-middleware/request-id</a></li>
<li><a href="https://github.com/relayphp/Relay.Middleware">relay/middleware</a></li>
</ul>
<p>Основным недостатком данного интерфейса является то, что, хотя сам интерфейс и является callable, в настоящее время нет возможности строго типизировать замыкание.</p>
<h3 id="52-single-pass-lambda">5.2 Single Pass (Lambda)</h3>
<p>Другой подход к middleware значительно ближе к стилю <a href="http://stackphp.com/">StackPHP</a> и определяется следующим образом:</p>
<pre><code>fn(request, next): response
</code></pre>
<p>Middleware, использующее данный подход, как правило, имеет следующие общие черты:</p>
<ul>
<li>Middleware определяется с помощью конкретного интерфейса с методом, принимающим запрос для обработки.</li>
<li>При вызове middleware передаётся 2 аргумента:</li>
<li>Сообщение HTTP-запроса.</li>
<li>Обработчик запросов, которому middleware может делегировать ответственность за формирование HTTP-ответа.</li>
</ul>
<p>В данном варианте middleware не имеет доступа к ответу до его формирования обработчиком запросов. После этого middleware МОЖЕТ модифицировать ответ перед его возвратом.</p>
<p>Данный подход часто называют «single pass» («одиночная передача») или «lambda», поскольку в middleware передаётся только запрос.</p>
<h4 id="521-single-pass">5.2.1 Проекты, использующие Single Pass</h4>
<p>Примеров данного подхода в проектах, использующих HTTP-сообщения, меньше, за одним заметным исключением.</p>
<p><a href="http://docs.guzzlephp.org/en/latest/handlers-and-middleware.html">Guzzle middleware</a> ориентировано на исходящие (клиентские) запросы и использует следующую сигнатуру:</p>
<pre><code class="language-php">function (RequestInterface $request, array $options): ResponseInterface
</code></pre>
<h4 id="522-single-pass">5.2.2 Дополнительные проекты, использующие Single Pass</h4>
<p>Существуют также значимые проекты, появившиеся до HTTP-сообщений, использующие данный подход.</p>
<p><a href="http://stackphp.com/">StackPHP</a> основан на <a href="https://symfony.com/doc/current/components/http_kernel.html">Symfony HttpKernel</a> и поддерживает middleware со следующей сигнатурой:</p>
<pre><code class="language-php">function handle(Request $request, $type, $catch): Response
</code></pre>
<p><em>Примечание: хотя Stack имеет несколько аргументов, объект ответа среди них не предусмотрен.</em></p>
<p><a href="https://laravel.com/docs/master/middleware">Laravel middleware</a> использует компоненты Symfony и поддерживает middleware со следующей сигнатурой:</p>
<pre><code class="language-php">function handle(Request $request, callable $next): Response
</code></pre>
<h3 id="53">5.3 Сравнение подходов</h3>
<p>Подход single pass к middleware давно утвердился в сообществе PHP. Это наглядно демонстрирует большое количество пакетов, основанных на StackPHP.</p>
<p>Подход double pass значительно новее, однако он был почти повсеместно принят ранними разработчиками, использующими HTTP-сообщения (PSR-7).</p>
<h3 id="54">5.4 Выбранный подход</h3>
<p>Несмотря на почти повсеместное распространение подхода double pass, он имеет существенные проблемы реализации.</p>
<p>Наиболее серьёзная из них состоит в том, что передача пустого ответа не даёт никаких гарантий, что ответ находится в пригодном для использования состоянии. Ситуацию усугубляет то, что middleware МОЖЕТ модифицировать ответ перед передачей его для дальнейшей обработки.</p>
<p>Дополнительную сложность создаёт невозможность гарантировать, что в тело ответа ничего не было записано, что может привести к неполному выводу или к тому, что ответы об ошибках будут отправлены с прикреплёнными заголовками кэша. Также возможно <a href="https://akrabat.com/filtering-the-psr-7-body-in-middleware/">повреждение содержимого тела</a> при записи поверх существующего содержимого, если новое содержимое короче исходного. Наиболее эффективный способ решения этих проблем — всегда предоставлять новый поток при изменении тела сообщения.</p>
<p>Ряд специалистов утверждал, что передача ответа способствует инверсии зависимостей. Хотя это действительно помогает избежать зависимости от конкретной реализации HTTP-сообщений, данную проблему также можно решить путём внедрения фабрик в middleware для создания объектов HTTP-сообщений или путём внедрения пустых экземпляров сообщений. С появлением HTTP-фабрик в <a href="https://github.com/php-fig/fig-standards/blob/master/proposed/http-factory/http-factory-meta.md">PSR-17</a> стал возможен стандартный подход к решению задачи инверсии зависимостей.</p>
<p>Более субъективная, но также важная проблема состоит в том, что существующее middleware с подходом double pass, как правило, использует подсказку типа <code>callable</code> для ссылки на middleware. Это делает строгую типизацию невозможной, поскольку нет гарантии, что передаваемый <code>callable</code> реализует сигнатуру middleware, что снижает безопасность во время выполнения.</p>
<p><strong>В связи с этими существенными проблемами для данного предложения был выбран подход lambda.</strong></p>
<h2 id="6">6. Проектные решения</h2>
<h3 id="61">6.1 Проектирование обработчика запросов</h3>
<p><code>RequestHandlerInterface</code> определяет единственный метод, принимающий запрос и ОБЯЗАННЫЙ возвращать ответ. Обработчик запросов МОЖЕТ делегировать обработку другому обработчику.</p>
<h4 id="_1">Почему требуется серверный запрос?</h4>
<p>Чтобы явно указать, что обработчик запросов может использоваться только в серверном контексте. В клиентском контексте вместо ответа, скорее всего, возвращался бы <a href="https://promisesaplus.com/">promise</a>.</p>
<h4 id="handler">Почему используется термин «handler» (обработчик)?</h4>
<p>Термин «handler» означает нечто, предназначенное для управления или контроля. Применительно к обработке запросов обработчик запросов — это точка, в которой запрос должен быть обработан для формирования ответа.</p>
<p>В отличие от термина «delegate», который использовался в предыдущей версии данной спецификации, внутреннее поведение данного интерфейса не определяется. До тех пор пока обработчик запросов в конечном счёте формирует ответ, он является корректным.</p>
<h4 id="__invoke">Почему обработчик запросов не использует <code>__invoke</code>?</h4>
<p>Использование <code>__invoke</code> менее прозрачно, чем применение именованного метода. Кроме того, именованный метод упрощает вызов обработчика запросов, когда он присвоен переменной класса, без использования <code>call_user_func</code> или другого менее распространённого синтаксиса.</p>
<p><em>Дополнительную информацию см. в [обсуждении PHP-FIG по FrameInterface][].</em></p>
<h3 id="62-middleware">6.2 Проектирование middleware</h3>
<p><code>MiddlewareInterface</code> определяет единственный метод, принимающий HTTP-запрос и обработчик запросов и обязанный возвращать ответ. Middleware МОЖЕТ:</p>
<ul>
<li>Преобразовывать запрос перед передачей его обработчику запросов.</li>
<li>Преобразовывать ответ, полученный от обработчика запросов, перед его возвратом.</li>
<li>Создавать и возвращать ответ без передачи запроса обработчику запросов, тем самым самостоятельно обрабатывая запрос.</li>
</ul>
<p>При делегировании от одного middleware к другому в цепочке один из подходов для систем диспетчеризации — использование промежуточного обработчика запросов, объединяющего цепочку middleware как способ связывания компонентов middleware. Последний или самый внутренний middleware будет выступать в роли шлюза к коду приложения и формировать ответ на основе его результатов; в качестве альтернативы middleware МОЖЕТ делегировать эту ответственность специализированному обработчику запросов.</p>
<h4 id="middleware-__invoke">Почему middleware не использует <code>__invoke</code>?</h4>
<p>Это создало бы конфликт с существующим middleware, реализующим подход double pass и желающим реализовать интерфейс middleware в целях прямой совместимости с данной спецификацией.</p>
<h4 id="process">Почему метод называется <code>process()</code>?</h4>
<p>Мы рассмотрели ряд существующих монолитных фреймворков и фреймворков на основе middleware, чтобы определить, какой метод (или методы) каждый из них определяет для обработки входящих запросов. Мы обнаружили, что наиболее распространены следующие варианты:</p>
<ul>
<li><code>__invoke</code> (в системах middleware, таких как Slim, Expressive, Relay и др.)</li>
<li><code>handle</code> (в частности, в программном обеспечении, производном от Symfony <a href="https://symfony.com/doc/current/components/http_kernel.html">HttpKernel</a>)</li>
<li><code>dispatch</code> (Zend Framework <a href="https://github.com/zendframework/zend-stdlib/blob/980ce463c29c1a66c33e0eb67961bba895d0e19e/src/DispatchableInterface.php">DispatchableInterface</a>)</li>
</ul>
<p>Мы решили обеспечить прямую совместимость для таких классов, чтобы они могли перепрофилировать себя в middleware (или middleware, совместимое с данной спецификацией), и поэтому нам нужно было выбрать имя, не находящееся в общем употреблении. В результате мы выбрали <code>process</code>, указывая тем самым на <em>обработку</em> запроса.</p>
<h4 id="_2">Почему требуется серверный запрос?</h4>
<p>Чтобы явно указать, что middleware может использоваться только в синхронном, серверном контексте.</p>
<p>Хотя не всем middleware потребуются дополнительные методы, определённые интерфейсом серверного запроса, исходящие запросы, как правило, обрабатываются асинхронно и обычно возвращают <a href="https://promisesaplus.com/">promise</a> ответа. (Это в первую очередь обусловлено тем, что несколько запросов могут выполняться параллельно и обрабатываться по мере поступления.) Решение задач асинхронного жизненного цикла запрос/ответ выходит за рамки данного предложения.</p>
<p>Попытка определить клиентское middleware была бы на данном этапе преждевременной. Любое будущее предложение, ориентированное на обработку клиентских запросов, должно иметь возможность определить стандарт, специфичный для природы асинхронного middleware.</p>
<p><em>Дополнительную информацию см. в [обсуждении PHP-FIG о middleware на стороне клиента и сервера][].</em></p>
<h4 id="_3">Какова роль обработчика запросов?</h4>
<p>Middleware выполняет следующие роли:</p>
<ul>
<li>
<p>Самостоятельное формирование ответа. Если выполнены определённые условия запроса, middleware МОЖЕТ сформировать и вернуть ответ.</p>
</li>
<li>
<p>Возврат результата обработчика запросов. В случаях, когда middleware не МОЖЕТ самостоятельно сформировать ответ, оно МОЖЕТ делегировать эту задачу обработчику запросов; иногда это МОЖЕТ предполагать предоставление преобразованного запроса (например, для внедрения атрибута запроса или результатов разбора тела запроса).</p>
</li>
<li>
<p>Манипуляция ответом, возвращённым обработчиком запросов, и его возврат. В некоторых случаях middleware МОЖЕТ быть заинтересовано в изменении ответа, возвращённого обработчиком запросов (например, для сжатия тела ответа в gzip, добавления заголовков CORS и т. д.). В таких случаях middleware перехватывает ответ, возвращённый обработчиком запросов, и возвращает преобразованный ответ по завершении.</p>
</li>
</ul>
<p>В двух последних случаях middleware МОЖЕТ содержать код, подобный следующему:</p>
<pre><code class="language-php">// Straight delegation:
return $handler-&gt;handle($request);

// Capturing the response to manipulate:
$response = $handler-&gt;handle($request);
</code></pre>
<p>Поведение обработчика полностью определяется разработчиком — главное, чтобы в итоге формировался ответ.</p>
<p>В одном из типичных сценариев обработчик реализует <em>очередь</em> или <em>стек</em> экземпляров middleware внутри себя. В таких случаях вызов <code>$handler-&gt;handle($request)</code> продвигает внутренний указатель, извлекает middleware, связанное с этим указателем, и вызывает его с помощью <code>$middleware-&gt;process($request, $this)</code>. Если middleware больше не осталось, обработчик, как правило, либо выбрасывает исключение, либо возвращает заранее заготовленный ответ.</p>
<p>Другая возможность — <em>routing middleware</em> («маршрутизирующее middleware»), которое сопоставляет входящий серверный запрос с конкретным обработчиком и возвращает ответ, сформированный при его выполнении. Если сопоставить запрос с обработчиком не удаётся, вместо этого выполняется обработчик, переданный в middleware. (Данный механизм МОЖЕТ применяться даже совместно с очередями и стеками middleware.)</p>
<h3 id="63">6.3 Примеры взаимодействия интерфейсов</h3>
<p>Два интерфейса — <code>RequestHandlerInterface</code> и <code>MiddlewareInterface</code> — были спроектированы для совместной работы. Middleware приобретает гибкость, будучи отделённым от какого-либо объемлющего прикладного уровня и опираясь исключительно на предоставленный обработчик запросов для формирования ответа.</p>
<p>Ниже продемонстрированы два подхода к системам диспетчеризации middleware, которые рабочая группа наблюдала и/или реализовывала. Кроме того, приведены примеры переиспользуемого middleware, показывающие, как писать слабо связанный middleware.</p>
<p>Обратите внимание: данные подходы не претендуют на роль окончательных или исключительных способов определения систем диспетчеризации middleware.</p>
<h4 id="_4">Обработчик запросов на основе очереди</h4>
<p>В данном подходе обработчик запросов поддерживает очередь middleware и резервный ответ на случай, если очередь исчерпана без формирования ответа. При выполнении первого middleware очередь передаёт себя в качестве обработчика запросов данному middleware.</p>
<pre><code class="language-php">class QueueRequestHandler implements RequestHandlerInterface
{
    private $middleware = [];
    private $fallbackHandler;

    public function __construct(RequestHandlerInterface $fallbackHandler)
    {
        $this-&gt;fallbackHandler = $fallbackHandler;
    }

    public function add(MiddlewareInterface $middleware)
    {
        $this-&gt;middleware[] = $middleware;
    }

    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        // Last middleware in the queue has called on the request handler.
        if (0 === count($this-&gt;middleware)) {
            return $this-&gt;fallbackHandler-&gt;handle($request);
        }

        $middleware = array_shift($this-&gt;middleware);
        return $middleware-&gt;process($request, $this);
    }
}
</code></pre>
<p>Загрузка приложения в таком случае может выглядеть следующим образом:</p>
<pre><code class="language-php">// Fallback handler:
$fallbackHandler = new NotFoundHandler();

// Create request handler instance:
$app = new QueueRequestHandler($fallbackHandler);

// Add one or more middleware:
$app-&gt;add(new AuthorizationMiddleware());
$app-&gt;add(new RoutingMiddleware());

// execute it:
$response = $app-&gt;handle(ServerRequestFactory::fromGlobals());
</code></pre>
<p>В данной системе присутствуют два обработчика запросов: один, формирующий ответ, если последнее middleware делегирует обработку обработчику запросов, и один — для диспетчеризации слоёв middleware. (В данном примере <code>RoutingMiddleware</code>, скорее всего, будет выполнять скомпонованные обработчики при успешном совпадении маршрута; подробнее об этом ниже.)</p>
<p>Данный подход имеет следующие преимущества:</p>
<ul>
<li>Middleware не обязано знать ни о каком другом middleware или о том, как оно скомпоновано в приложении.</li>
<li><code>QueueRequestHandler</code> не зависит от конкретной реализации PSR-7.</li>
<li>Middleware выполняется в том порядке, в котором оно добавляется в приложение, что делает код явным.</li>
<li>Формирование «резервного» ответа делегируется разработчику приложения. Это позволяет разработчику самостоятельно определить, должно ли это быть условие «404 Not Found», страница по умолчанию или что-то иное.</li>
</ul>
<h4 id="_5">Обработчик запросов на основе декорирования</h4>
<p>В данном подходе реализация обработчика запросов декорирует как экземпляр middleware, так и резервный обработчик запросов, передаваемый ему. Приложение строится снаружи внутрь, при этом каждый «слой» обработчика запросов передаётся следующему внешнему слою.</p>
<pre><code class="language-php">class DecoratingRequestHandler implements RequestHandlerInterface
{
    private $middleware;
    private $nextHandler;

    public function __construct(MiddlewareInterface $middleware, RequestHandlerInterface $nextHandler)
    {
        $this-&gt;middleware = $middleware;
        $this-&gt;nextHandler = $nextHandler;
    }

    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        return $this-&gt;middleware-&gt;process($request, $this-&gt;nextHandler);
    }
}

// Create a response prototype to return if no middleware can produce a response
// on its own. This could be a 404, 500, or default page.
$responsePrototype = (new Response())-&gt;withStatus(404);
$innerHandler = new class ($responsePrototype) implements RequestHandlerInterface {
    private $responsePrototype;

    public function __construct(ResponseInterface $responsePrototype)
    {
        $this-&gt;responsePrototype = $responsePrototype;
    }

    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        return $this-&gt;responsePrototype;
    }
};

$layer1 = new DecoratingRequestHandler(new RoutingMiddleware(), $innerHandler);
$layer2 = new DecoratingRequestHandler(new AuthorizationMiddleware(), $layer1);

$response = $layer2-&gt;handle(ServerRequestFactory::fromGlobals());
</code></pre>
<p>Аналогично middleware на основе очереди, обработчики запросов в данной системе выполняют две функции:</p>
<ul>
<li>Формирование резервного ответа, если ни один другой слой этого не делает.</li>
<li>Диспетчеризация middleware.</li>
</ul>
<h4 id="middleware">Примеры переиспользуемого middleware</h4>
<p>В приведённых выше примерах в каждом из них скомпоновано по два middleware. Чтобы они работали в обоих сценариях, необходимо написать их таким образом, чтобы они взаимодействовали корректно.</p>
<p>Разработчикам middleware, стремящимся к максимальной совместимости, рекомендуется руководствоваться следующими принципами:</p>
<ul>
<li>
<p>Проверять запрос на соответствие обязательному условию. Если условие не выполнено, использовать скомпонованный прототип ответа или скомпонованную фабрику ответов для формирования и возврата ответа.</p>
</li>
<li>
<p>Если предварительные условия выполнены, делегировать создание ответа предоставленному обработчику запросов, при необходимости передавая «новый» запрос путём преобразования предоставленного (например, <code>$handler-&gt;handle($request-&gt;withAttribute('foo', 'bar')</code>).</p>
</li>
<li>
<p>Либо передавать ответ, возвращённый обработчиком запросов, без изменений, либо предоставлять новый ответ путём манипуляции возвращённым (например, <code>return $response-&gt;withHeader('X-Foo-Bar', 'baz')</code>).</p>
</li>
</ul>
<p><code>AuthorizationMiddleware</code> — это пример, задействующий все три принципа:</p>
<ul>
<li>Если авторизация требуется, но запрос не авторизован, используется скомпонованный прототип ответа для формирования ответа «unauthorized» («не авторизован»).</li>
<li>Если авторизация не требуется, запрос делегируется обработчику без изменений.</li>
<li>Если авторизация требуется и запрос авторизован, запрос делегируется обработчику, а возвращённый ответ подписывается на основе запроса.</li>
</ul>
<pre><code class="language-php">class AuthorizationMiddleware implements MiddlewareInterface
{
    private $authorizationMap;

    public function __construct(AuthorizationMap $authorizationMap)
    {
        $this-&gt;authorizationMap = $authorizationMap;
    }

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        if (! $this-&gt;authorizationMap-&gt;needsAuthorization($request)) {
            return $handler-&gt;handle($request);
        }

        if (! $this-&gt;authorizationMap-&gt;isAuthorized($request)) {
            return $this-&gt;authorizationMap-&gt;prepareUnauthorizedResponse();
        }

        $response = $handler-&gt;handle($request);
        return $this-&gt;authorizationMap-&gt;signResponse($response, $request);
    }
}
</code></pre>
<p>Обратите внимание: middleware не интересует реализация обработчика запросов — оно лишь использует его для формирования ответа при выполнении предварительных условий.</p>
<p>Реализация <code>RoutingMiddleware</code>, описанная ниже, следует аналогичному принципу: она анализирует запрос на предмет соответствия известным маршрутам. В данной реализации маршруты сопоставляются с обработчиками запросов, и middleware по существу делегирует им задачу формирования ответа. Однако в случае, когда ни один маршрут не совпадает, выполняется обработчик, переданный в middleware.</p>
<pre><code class="language-php">class RoutingMiddleware implements MiddlewareInterface
{
    private $router;

    public function __construct(Router $router)
    {
        $this-&gt;router = $router;
    }

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $result = $this-&gt;router-&gt;match($request);

        if ($result-&gt;isSuccess()) {
            return $result-&gt;getHandler()-&gt;handle($request);
        }

        return $handler-&gt;handle($request);
    }
}
</code></pre>
<h2 id="7">7. Участники</h2>
<p>Данный PSR был подготовлен рабочей группой FIG в следующем составе:</p>
<ul>
<li>Matthew Weier O'Phinney (спонсор), <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#119;&#101;&#105;&#101;&#114;&#111;&#112;&#104;&#105;&#110;&#110;&#101;&#121;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#109;&#119;&#101;&#105;&#101;&#114;&#111;&#112;&#104;&#105;&#110;&#110;&#101;&#121;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a></li>
<li>Woody Gilk (редактор), <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#119;&#111;&#111;&#100;&#121;&#46;&#103;&#105;&#108;&#107;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#119;&#111;&#111;&#100;&#121;&#46;&#103;&#105;&#108;&#107;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a></li>
<li>Glenn Eggleton</li>
<li>Matthieu Napoli</li>
<li>Oscar Otero</li>
<li>Korvin Szanto</li>
<li>Stefano Torresi</li>
</ul>
<p>Рабочая группа также выражает признательность за вклад следующим участникам:</p>
<ul>
<li>Jason Coward, <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#97;&#115;&#111;&#110;&#64;&#111;&#112;&#101;&#110;&#103;&#101;&#101;&#107;&#46;&#99;&#111;&#109;">&#106;&#97;&#115;&#111;&#110;&#64;&#111;&#112;&#101;&#110;&#103;&#101;&#101;&#107;&#46;&#99;&#111;&#109;</a></li>
<li>Paul M. Jones, <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#112;&#109;&#106;&#111;&#110;&#101;&#115;&#56;&#56;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#112;&#109;&#106;&#111;&#110;&#101;&#115;&#56;&#56;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a></li>
<li>Rasmus Schultz, <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#97;&#115;&#109;&#117;&#115;&#64;&#109;&#105;&#110;&#100;&#112;&#108;&#97;&#121;&#46;&#100;&#107;">&#114;&#97;&#115;&#109;&#117;&#115;&#64;&#109;&#105;&#110;&#100;&#112;&#108;&#97;&#121;&#46;&#100;&#107;</a></li>
</ul>
<h2 id="8">8. Голосования</h2>
<ul>
<li><a href="https://groups.google.com/d/msg/php-fig/rPFRTa0NODU/tIU9BZciAgAJ">Формирование рабочей группы</a></li>
<li><a href="https://groups.google.com/d/msg/php-fig/mfTrFinTvEM/PiYvU2S6BAAJ">Начало периода рецензирования</a></li>
<li><a href="https://groups.google.com/d/msg/php-fig/bhQmHt39hJE/ZCYrK_O2AQAJ">Принятие</a></li>
</ul>
<h2 id="9">9. Полезные ссылки</h2>
<p><em><strong>Примечание:</strong> порядок — от новых к старым.</em></p>
<ul>
<li><a href="https://groups.google.com/d/msg/php-fig/vTtGxdIuBX8/NXKieN9vDQAJ">Тема в списке рассылки PHP-FIG</a></li>
<li><a href="https://groups.google.com/d/msg/thephpleague/jyztj-Nz_rw/I4lHVFigAAAJ">Предложение по middleware от The PHP League</a></li>
<li><a href="https://groups.google.com/d/msg/php-fig/V12AAcT_SxE/aRXmNnIVCwAJ">Обсуждение PHP-FIG по FrameInterface</a></li>
<li><a href="https://groups.google.com/d/topic/php-fig/vBk0BRgDe2s/discussion">Обсуждение PHP-FIG о middleware на стороне клиента и сервера</a></li>
</ul>
<h2 id="10">10. Замечания и исправления</h2>
<p>...</p>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
        <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
      
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
      
        <script src="../../js/init.js"></script>
      
    
  </body>
</html>