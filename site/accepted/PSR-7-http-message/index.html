
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://php-psr.ru/accepted/PSR-7-http-message/">
      
      
        <link rel="prev" href="../PSR-6-cache/">
      
      
        <link rel="next" href="../PSR-12-extended-coding-style-guide/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.11">
    
    
      
        <title>Интерфейсы HTTP-сообщений PSR-7 - Рекомендации по стандартам PHP: PSR</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.85bb2934.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#http-" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Рекомендации по стандартам PHP: PSR" class="md-header__button md-logo" aria-label="Рекомендации по стандартам PHP: PSR" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Рекомендации по стандартам PHP: PSR
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Интерфейсы HTTP-сообщений PSR-7
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Рекомендации по стандартам PHP: PSR" class="md-nav__button md-logo" aria-label="Рекомендации по стандартам PHP: PSR" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Рекомендации по стандартам PHP: PSR
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Рекомендации по стандартам PHP (PSR)
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-0/" class="md-nav__link">
        Стандарт автозагрузки PSR-0 (Устарело)
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-1-basic-coding-standard/" class="md-nav__link">
        Основной стандарт кодирования PSR-1
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-2-coding-style-guide/" class="md-nav__link">
        Руководство по стилю кодирования PSR-2
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-3-logger-interface/" class="md-nav__link">
        Общий интерфейс логирования PSR-3
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-4-autoloader/" class="md-nav__link">
        Стандарт автозагрузки PSR-4
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../proposed/phpdoc/" class="md-nav__link">
        PHPDoc PSR-5
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-6-cache/" class="md-nav__link">
        Общий интерфейс кэширования PSR-6
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Интерфейсы HTTP-сообщений PSR-7
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Интерфейсы HTTP-сообщений PSR-7
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    Ссылки
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. Спецификация
  </a>
  
    <nav class="md-nav" aria-label="1. Спецификация">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 Сообщения
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-http-" class="md-nav__link">
    1.2 HTTP-заголовки
  </a>
  
    <nav class="md-nav" aria-label="1.2 HTTP-заголовки">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Имена полей заголовков без учета регистра
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Заголовки с несколькими значениями
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#host" class="md-nav__link">
    Заголовок Host
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    1.3 Потоки
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#14-uri" class="md-nav__link">
    1.4 Цели запросов и URI
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#15" class="md-nav__link">
    1.5 Запросы на стороне сервера
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#16" class="md-nav__link">
    1.6 Загрузка файлов
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2. Пакеты
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3. Интерфейсы
  </a>
  
    <nav class="md-nav" aria-label="3. Интерфейсы">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-psrhttpmessagemessageinterface" class="md-nav__link">
    3.1 Psr\Http\Message\MessageInterface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-psrhttpmessagerequestinterface" class="md-nav__link">
    3.2 Psr\Http\Message\RequestInterface
  </a>
  
    <nav class="md-nav" aria-label="3.2 Psr\Http\Message\RequestInterface">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#321-psrhttpmessageserverrequestinterface" class="md-nav__link">
    3.2.1 Psr\Http\Message\ServerRequestInterface
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-psrhttpmessageresponseinterface" class="md-nav__link">
    3.3 Psr\Http\Message\ResponseInterface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-psrhttpmessagestreaminterface" class="md-nav__link">
    3.4 Psr\Http\Message\StreamInterface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35-psrhttpmessageuriinterface" class="md-nav__link">
    3.5 Psr\Http\Message\UriInterface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#36-psrhttpmessageuploadedfileinterface" class="md-nav__link">
    3.6 Psr\Http\Message\UploadedFileInterface
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-12-extended-coding-style-guide/" class="md-nav__link">
        Расширенное руководство по стилю кодирования PSR-12
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../proposed/phpdoc-tags/" class="md-nav__link">
        Теги PHPDoc PSR-19
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../LICENSE/" class="md-nav__link">
        Лицензия
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    Ссылки
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. Спецификация
  </a>
  
    <nav class="md-nav" aria-label="1. Спецификация">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 Сообщения
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-http-" class="md-nav__link">
    1.2 HTTP-заголовки
  </a>
  
    <nav class="md-nav" aria-label="1.2 HTTP-заголовки">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Имена полей заголовков без учета регистра
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Заголовки с несколькими значениями
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#host" class="md-nav__link">
    Заголовок Host
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    1.3 Потоки
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#14-uri" class="md-nav__link">
    1.4 Цели запросов и URI
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#15" class="md-nav__link">
    1.5 Запросы на стороне сервера
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#16" class="md-nav__link">
    1.6 Загрузка файлов
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2. Пакеты
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3. Интерфейсы
  </a>
  
    <nav class="md-nav" aria-label="3. Интерфейсы">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-psrhttpmessagemessageinterface" class="md-nav__link">
    3.1 Psr\Http\Message\MessageInterface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-psrhttpmessagerequestinterface" class="md-nav__link">
    3.2 Psr\Http\Message\RequestInterface
  </a>
  
    <nav class="md-nav" aria-label="3.2 Psr\Http\Message\RequestInterface">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#321-psrhttpmessageserverrequestinterface" class="md-nav__link">
    3.2.1 Psr\Http\Message\ServerRequestInterface
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-psrhttpmessageresponseinterface" class="md-nav__link">
    3.3 Psr\Http\Message\ResponseInterface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-psrhttpmessagestreaminterface" class="md-nav__link">
    3.4 Psr\Http\Message\StreamInterface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35-psrhttpmessageuriinterface" class="md-nav__link">
    3.5 Psr\Http\Message\UriInterface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#36-psrhttpmessageuploadedfileinterface" class="md-nav__link">
    3.6 Psr\Http\Message\UploadedFileInterface
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="http-">Интерфейсы HTTP-сообщений</h1>
<p>Этот документ описывает общие интерфейсы для представления сообщений HTTP, как описано
в <a href="http://tools.ietf.org/html/rfc7230">RFC 7230</a> и
<a href="http://tools.ietf.org/html/rfc7231">RFC 7231</a> и URI для использования с сообщениями HTTP, как описано
в <a href="http://tools.ietf.org/html/rfc3986">RFC 3986</a>.</p>
<p>Сообщения HTTP являются основой веб-разработки. Веб-браузеры и клиенты HTTP, такие как cURL, создают сообщения запроса
HTTP, которые отправляются на веб-сервер, который предоставляет ответное сообщение HTTP. Серверный код получает
сообщение запроса HTTP и возвращает сообщение ответа HTTP.</p>
<p>HTTP-сообщения, как правило, абстрагируются от конечного пользователя, но нам, как разработчикам, обычно необходимо
знать, как они структурированы и как получить к ним доступ или манипулировать ими для выполнения наших задач, будь то
запрос к HTTP API или обработка входящего запроса.</p>
<p>Каждое сообщение HTTP-запроса имеет определенную форму:</p>
<pre><code class="language-http">POST /path HTTP/1.1
Host: example.com

foo=bar&amp;baz=bat
</code></pre>
<p>Первая строка запроса называется «строка запроса» и содержит метод HTTP-запроса, цель запроса (обычно либо абсолютный
URI, либо путь на веб-сервере) и версию протокола HTTP. Далее следует один или несколько заголовков HTTP, пустая строка
и тело сообщения.</p>
<p>Сообщения HTTP-ответа имеют аналогичную структуру:</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Type: text/plain

This is the response body
</code></pre>
<p>Первая строка является «строкой состояния» и содержит версию протокола HTTP, код состояния HTTP и удобочитаемое описание
кода состояния. Далее за "строкой состояния" следует один или несколько заголовков HTTP, пустая строка и тело сообщения.</p>
<p>Интерфейсы, описанные в этом документе, являются абстракциями HTTP-сообщений и составляющих их элементов.</p>
<p>Слова «НЕОБХОДИМО» / «ДОЛЖНО» ("MUST"), «НЕДОПУСТИМО» ("MUST NOT"),
«ТРЕБУЕТСЯ» ("REQUIRED"), «НУЖНО» ("SHALL"), «НЕ ПОЗВОЛЯЕТСЯ» ("SHALL NOT"),
«СЛЕДУЕТ» ("SHOULD"), «НЕ СЛЕДУЕТ» ("SHOULD NOT"),
«РЕКОМЕНДУЕТСЯ» ("RECOMMENDED"), «МОЖЕТ» / «ВОЗМОЖНО» ("MAY") и
«НЕОБЯЗАТЕЛЬНО» ("OPTIONAL") в этом документе следует понимать так,
как это описано в <a href="http://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a> (и его <a href="http://rfc.com.ru/rfc2119.htm">переводе</a>).</p>
<h3 id="_1">Ссылки</h3>
<ul>
<li><a href="http://tools.ietf.org/html/rfc2119">RFC 2119</a></li>
<li><a href="http://tools.ietf.org/html/rfc3986">RFC 3986</a></li>
<li><a href="http://tools.ietf.org/html/rfc7230">RFC 7230</a></li>
<li><a href="http://tools.ietf.org/html/rfc7231">RFC 7231</a></li>
</ul>
<h2 id="1">1. Спецификация</h2>
<h3 id="11">1.1 Сообщения</h3>
<p>HTTP-сообщение — это либо запрос от клиента к серверу, либо ответ от сервера к клиенту.
Эта спецификация определяет интерфейсы для HTTP-сообщений: <code>Psr\Http\Message\RequestInterface</code>
и <code>Psr\Http\Message\ResponseInterface</code>.</p>
<p>И <code>Psr\Http\Message\RequestInterface</code> и <code>Psr\Http\Message\ResponseInterface</code> расширяют
<code>Psr\Http\Message\MessageInterface</code>. В то время как <code>Psr\Http\Message\MessageInterface</code> МОЖЕТ быть
реализованы напрямую, разработчики ДОЛЖНЫ реализовывать
<code>Psr\Http\Message\RequestInterface</code> и <code>Psr\Http\Message\ResponseInterface</code>.</p>
<p>С этого момента пространство имен <code>Psr\Http\Message</code> будет опущено при ссылке на эти интерфейсы.</p>
<h3 id="12-http-">1.2 HTTP-заголовки</h3>
<h4 id="_2">Имена полей заголовков без учета регистра</h4>
<p>Сообщения HTTP включают имена полей заголовков без учета регистра. Заголовки извлекаются по имени из классов,
реализующих <code>MessageInterface</code> без учета регистра. Например, получение заголовка <code>foo</code> вернет тот же результат, что и
получение заголовка <code>FoO</code>. Точно так же установка заголовка <code>Foo</code> перезапишет любое ранее установленное значение
заголовка <code>foo</code>.</p>
<pre><code class="language-php">$message = $message-&gt;withHeader('foo', 'bar');

echo $message-&gt;getHeaderLine('foo');
// Выведет: bar

echo $message-&gt;getHeaderLine('FOO');
// Выведет: bar

$message = $message-&gt;withHeader('fOO', 'baz');
echo $message-&gt;getHeaderLine('foo');
// Выведет: baz
</code></pre>
<p>Несмотря на то, что заголовки могут быть получены без учета регистра, исходный регистр ДОЛЖЕН быть сохранен реализацией,
в частности, при извлечении с помощью <code>getHeaders()</code>.</p>
<p>HTTP-приложения, которые не соответсвуют стандартам, могут понимать заголовки по разному.
Поэтому полезно, чтобы разработчик мог указать регистр заголовков HTTP при создании запроса или ответа.</p>
<h4 id="_3">Заголовки с несколькими значениями</h4>
<p>Чтобы разместить заголовки с несколькими значениями, но при этом обеспечить удобство работы с заголовками в виде строк,
заголовки можно извлекать из экземпляра <code>MessageInterface</code> в виде массива или строки. Используйте
метод <code>getHeaderLine()</code>, чтобы получить значение заголовка в виде строки, содержащей все значения заголовка без учета
регистра по имени, объединенному запятой.
Используйте <code>getHeader()</code>, чтобы получить массив всех значений заголовков для конкретного заголовка без учета регистра
по имени.</p>
<pre><code class="language-php">$message = $message
    -&gt;withHeader('foo', 'bar')
    -&gt;withAddedHeader('foo', 'baz');

$header = $message-&gt;getHeaderLine('foo');
// $header содержит: 'bar,baz'

$header = $message-&gt;getHeader('foo');
// ['bar', 'baz']
</code></pre>
<p>Примечание. Не все значения заголовков можно объединить с помощью запятой (например,
<code>Set-Cookie</code>). При работе с такими заголовками
При работе с такими заголовками классы на основе <code>MessageInterface</code> ДОЛЖНЫ
полагаться на метод getHeader() для извлечения таких многозначных заголовков.</p>
<h4 id="host">Заголовок Host</h4>
<p>В запросах заголовок <code>Host</code> обычно отражает хост URI, а также хост, используемый при установлении TCP-соединения.
Однако спецификация HTTP позволяет заголовку <code>Host</code> отличаться от каждого из этих двух значений.</p>
<p>Реализации интерфейса ДОЛЖНЫ пытаться установить заголовок <code>Host</code> из предоставленного URI, если заголовок <code>Host</code> не
передан в заголовках.</p>
<p><code>RequestInterface::withUri()</code> по умолчанию заменяет заголовок <code>Host</code> возвращаемого запроса на заголовок <code>Host</code>,
соответствующий хост-компоненту переданного <code>UriInterface</code>.</p>
<p>Вы можете согласиться на сохранение исходного состояния заголовка <code>Host</code>,
передав значение <code>true</code> для второго аргумента (<code>$preserveHost</code>).
Если для этого аргумента установлено значение <code>true</code>, возвращаемый запрос не будет обновлять заголовок <code>Host</code>
возвращаемого сообщения, если сообщение не содержит заголовка <code>Host</code>.</p>
<p>В этой таблице показано, что <code>getHeaderLine('Host')</code> вернет для запроса, возвращенного <code>withUri()</code> с
аргументом <code>$preserveHost</code>, установленным на <code>true</code>, для различных исходных запросов и URI.</p>
<table>
<thead>
<tr>
<th>Заголовок <code>Host</code> запроса<sup><a href="#rhh">1</a></sup></th>
<th>Компонент <code>host</code> запроса <sup><a href="#rhc">2</a></sup></th>
<th>URI <code>host</code> компонента<sup><a href="#uhc">3</a></sup></th>
<th>Результат</th>
</tr>
</thead>
<tbody>
<tr>
<td>''</td>
<td>''</td>
<td>''</td>
<td>''</td>
</tr>
<tr>
<td>''</td>
<td>foo.com</td>
<td>''</td>
<td>foo.com</td>
</tr>
<tr>
<td>''</td>
<td>foo.com</td>
<td>bar.com</td>
<td>foo.com</td>
</tr>
<tr>
<td>foo.com</td>
<td>''</td>
<td>bar.com</td>
<td>foo.com</td>
</tr>
<tr>
<td>foo.com</td>
<td>bar.com</td>
<td>baz.com</td>
<td>foo.com</td>
</tr>
</tbody>
</table>
<ul>
<li><sup id="rhh">1</sup> Значение заголовка <code>Host</code> перед операцией.</li>
<li><sup id="rhc">2</sup> Хост-компонент URI, составленный в запросе до операции.</li>
<li><sup id="uhc">3</sup> Хост-компонент URI, внедряемый через
  <code>withUri()</code>.</li>
</ul>
<h3 id="13">1.3 Потоки</h3>
<p>Сообщения HTTP состоят из начальной строки, заголовков и тела.
Тело сообщения HTTP может быть очень маленьким или очень большим.
Попытка представить тело сообщения в виде строки может легко потребовать больше памяти,
чем предполагалось, поскольку тело должно полностью храниться в памяти.
Попытка сохранить тело запроса или ответа в памяти помешает использованию этой реализации
для работы с большими телами сообщений. <code>StreamInterface</code> используется для того,
чтобы скрыть детали реализации, когда поток данных читается или записывается.
В ситуациях, когда строка является подходящей реализацией сообщения,
могут использоваться встроенные потоки, такие как <code>php://memory</code> и <code>php://temp</code>.</p>
<p>StreamInterface предоставляет несколько методов, позволяющих эффективно читать, записывать и обходить потоки.</p>
<p>Потоки раскрывают свои возможности с помощью трех методов: <code>isReadable()</code>,
<code>isWritable()</code> и <code>isSeekable()</code>. Эти методы могут использоваться участниками совместной работы над потоком, чтобы
определить, соответствует ли поток их требованиям.</p>
<p>Каждый экземпляр потока будет иметь различные возможности: он может быть только для чтения, только для записи или для
чтения-записи. Он также может разрешать произвольный произвольный доступ (поиск в любом месте вперед или назад) или
только последовательный доступ (например, в случае потока на основе сокета, канала или обратного вызова).</p>
<p>Наконец, <code>StreamInterface</code> определяет метод <code>__toString()</code> для упрощения извлечения или одновременной передачи всего
содержимого тела.</p>
<p>В отличие от интерфейсов запроса и ответа, <code>StreamInterface</code> не моделирует неизменяемость.
В ситуациях, когда фактический поток PHP обернут, неизменяемость невозможно обеспечить,
поскольку любой код, взаимодействующий с ресурсом, потенциально может изменить его состояние
(включая положение курсора, содержимое и т. д.).
Мы рекомендуем, чтобы реализации использовали потоки только для чтения для запросов на
стороне сервера и ответов на стороне клиента. Потребители должны знать о том факте,
что экземпляр потока может быть изменчивым и, как таковой, может изменить состояние сообщения;
если есть сомнения, создайте новый экземпляр потока и прикрепите его к сообщению,
чтобы принудительно применить состояние.</p>
<h3 id="14-uri">1.4 Цели запросов и URI</h3>
<p>Согласно RFC 7230, сообщения запроса содержат «цель запроса» в качестве второго сегмента строки запроса.
Цель запроса может быть одной из следующих:</p>
<ul>
<li><strong>Исходная форма</strong>, которая состоит из пути и, если есть, строки запроса
  такую запись часто называют относительным URL-адресом. Сообщения, передаваемые по протоколу TCP, обычно имеют исходную
  форму;
  схема и авторитетные данные обычно представлены только через переменные CGI.</li>
<li><strong>Абсолютная форма</strong>, состоящая из схемы
  ("[user-info@]host[:port]", где элементы в скобках являются необязательными), путь (если есть), строка запроса (если
  есть) и фрагмент (если есть).
  Такой формат часто называют абсолютным URI, и это единственная форма для указания URI, как подробно описано в RFC</li>
<li>Эта форма обычно используется при выполнении запросов к HTTP-прокси.</li>
<li><strong>Авторитетная форма</strong>, состоящая только из полномочий. Обычно это используется только в запросах CONNECT для
  установления соединения между HTTP-клиентом и прокси-сервером.</li>
<li><strong>Форма-звездочка</strong>, состоящая исключительно из строки <code>*</code> и используемая с методом OPTIONS для определения общих
  возможностей веб-сервера.</li>
</ul>
<p>Помимо этих целей запроса, часто существует «действующий URL», который отделен от цели запроса.
Действующий URL-адрес не передается в HTTP-сообщении, но используется для определения протокола (http/https), порта и
имени хоста для выполнения запроса.</p>
<p>Эффективный URL-адрес представлен посредством <code>UriInterface</code>.
<code>UriInterface</code> моделирует URI HTTP и HTTPS, как указано в RFC 3986 (основной вариант использования).
Интерфейс предоставляет методы для взаимодействия с различными частями URI, что устраняет необходимость повторного
анализа URI.
Он также определяет метод <code>__toString()</code> для приведения смоделированного URI к его строковому представлению.</p>
<p>При получении цели запроса с помощью <code>getRequestTarget()</code> по умолчанию этот метод будет
использовать объект URI и извлекать все необходимые компоненты для создания <strong>Исходная форма</strong>. <strong>Исходная форма</strong> на
сегодняшний день является наиболее распространенной целью запроса.</p>
<p>Если конечный пользователь желает использовать одну из трех других форм или если пользователь хочет явно переопределить
цель запроса, это можно сделать с помощью <code>withRequestTarget()</code>.</p>
<p>Вызов этого метода не влияет на URI, так как он возвращается из <code>getUri()</code>.</p>
<p>Например, пользователь может захотеть сделать запрос на сервер в форме звездочки:</p>
<pre><code class="language-php">$request = $request
    -&gt;withMethod('OPTIONS')
    -&gt;withRequestTarget('*')
    -&gt;withUri(new Uri('https://example.org/'));
</code></pre>
<p>Этот пример может в конечном итоге привести к HTTP-запросу, который выглядит следующим образом:</p>
<pre><code class="language-http">OPTIONS * HTTP/1.1
</code></pre>
<p>Но HTTP-клиент сможет использовать эффективный URL-адрес (из <code>getUri()</code>), чтобы определить протокол, имя хоста и TCP-порт.</p>
<p>HTTP-клиент ДОЛЖЕН игнорировать значения <code>Uri::getPath()</code> и <code>Uri::getQuery()</code> и вместо этого использовать значение, возвращаемое <code>getRequestTarget()</code>, которое по умолчанию объединяет эти два значения.</p>
<p>Клиенты, которые решили не реализовывать 1 или более из 4 форм запроса-цели, 
ДОЛЖНЫ по-прежнему использовать <code>getRequestTarget()</code>. 
Эти клиенты ДОЛЖНЫ отклонять цели запроса, которые они не поддерживают, и 
НЕ ДОЛЖНЫ возвращаться к значениям из <code>getUri()</code>.</p>
<p><code>RequestInterface</code> предоставляет методы для получения цели запроса или создания нового экземпляра с предоставленной целью запроса. По умолчанию, если в экземпляре специально не составлена цель запроса, <code>getRequestTarget()</code> вернет исходную форму составленного URI (или "/", если URI не составлен). <code>withRequestTarget($requestTarget)</code> создает новый экземпляр с указанной целью запроса и, таким образом, позволяет разработчикам создавать сообщения запроса, которые представляют три другие формы цели запроса (абсолютная форма, форма полномочий и форма звездочки). </p>
<h3 id="15">1.5 Запросы на стороне сервера</h3>
<p><code>RequestInterface</code> обеспечивает общее представление сообщения HTTP-запроса. 
Однако запросы на стороне сервера требуют дополнительной обработки из-за особенностей среды на стороне сервера. 
Обработка на стороне сервера должна учитывать общий интерфейс шлюза (CGI) и, в частности, абстракцию PHP и расширение CGI через его серверные API (SAPI). 
PHP упростил работу с помощью суперглобальных переменных, таких как:</p>
<ul>
<li><code>$_COOKIE</code>, который десериализует и обеспечивает упрощенный доступ к файлам HTTP cookie.</li>
<li><code>$_GET</code>, который десериализует и обеспечивает упрощенный доступ к аргументам строки запроса.</li>
<li><code>$_POST</code>, который десериализует и обеспечивает упрощенный доступ к urlencoded параметрам, отправленным через HTTP POST; в общем случае его можно рассматривать как результат разбора тела сообщения.</li>
<li><code>$_FILES</code>, который предоставляет сериализованные метаданные для загрузки файлов.</li>
<li><code>$_SERVER</code>, который обеспечивает доступ к переменным среды CGI/SAPI, которые обычно включают метод запроса, схему запроса, URI запроса и заголовки.</li>
</ul>
<p><code>ServerRequestInterface</code> расширяет <code>RequestInterface</code>, чтобы обеспечить абстракцию вокруг этих различных суперглобальных переменных. 
Эта практика помогает уменьшить связь разработчиков с суперглобальными переменными, а также поощряет и продвигает возможность тестирования запросов.</p>
<p>Запрос к серверу предоставляет одно дополнительное свойство <code>attributes</code>, 
чтобы позволить разработчикам проводить самоанализ, декомпозировать и сопоставлять запрос с правилами, специфичными для приложения (такими как сопоставление пути, сопоставление схемы, сопоставление хоста и т. д.). 
Таким образом, запрос сервера также может обеспечивать обмен сообщениями между несколькими запросами.</p>
<h3 id="16">1.6 Загрузка файлов</h3>
<p><code>ServerRequestInterface</code> определяет метод получения дерева загружаемых файлов в нормализованной структуре, где каждый лист является экземпляром 
<code>UploadedFileInterface</code>.</p>
<p>Суперглобальная переменная <code>$_FILES</code> имеет некоторые хорошо известные проблемы при работе с массивами входных файлов. 
Например, если у вас есть форма, которая отправляет массив файлов — например, входное имя «files», отправка «files[0]» и «files[1]» — PHP будет представлять это как:</p>
<pre><code class="language-php">[
    'files' =&gt; [
        'name' =&gt; [
            0 =&gt; 'file0.txt',
            1 =&gt; 'file1.html',
        ],
        'type' =&gt; [
            0 =&gt; 'text/plain',
            1 =&gt; 'text/html',
        ],
        /*  и т.д. */
    ],
]
</code></pre>
<p>вместо ожидаемого:</p>
<pre><code class="language-php">[
    'files' =&gt; [
        0 =&gt; [
            'name' =&gt; 'file0.txt',
            'type' =&gt; 'text/plain',
            /* и т.д. */
        ],
        1 =&gt; [
            'name' =&gt; 'file1.html',
            'type' =&gt; 'text/html',
            /* и т.д. */
        ],
    ],
]
</code></pre>
<p>В результате разработчики должны знать детали реализации этого языка и писать код под конкретные реализации.</p>
<p>Кроме того, существуют сценарии, в которых <code>$_FILES</code> не заполняется при загрузке файлов:</p>
<ul>
<li>Когда метод HTTP не POST.</li>
<li>При модульном тестировании.</li>
<li>При работе в среде, отличной от SAPI, такой как <a href="http://reactphp.org">ReactPHP</a>.</li>
</ul>
<p>В таких случаях данные должны быть заполнены по-другому. Например:</p>
<ul>
<li>Процесс может анализировать тело сообщения, чтобы обнаружить загруженные файлы. В таких случаях реализация может решить <em>не</em> записывать загружаемые файлы в файловую систему, а вместо этого заключать их в поток, чтобы уменьшить нагрузку на память, ввод-вывод и хранилище.</li>
<li>В сценариях модульного тестирования разработчики должны иметь возможность заглушать и/или имитировать метаданные загрузки файлов, чтобы валидировать и проверять различные сценарии.</li>
</ul>
<p><code>getUploadedFiles()</code> предоставляет нормализованную структуру для разработчиков.
Ожидается, что реализации:</p>
<ul>
<li>Соберают всю информацию для данной загрузки файла и используют ее для заполнения экземпляра <code>Psr\Http\Message\UploadedFileInterface</code>.</li>
<li>Повторно создавать отправленную древовидную структуру, где каждый лист является соответствующим экземпляром <code>Psr\Http\Message\UploadedFileInterface</code> для данного местоположения в дереве.</li>
</ul>
<p>Упомянутая древовидная структура должна имитировать структуру именования, в которой были отправлены файлы.</p>
<p>В самом простом примере это может быть один именованный элемент формы, представленный как:</p>
<pre><code class="language-html">&lt;input type='file' name='avatar' /&gt;
</code></pre>
<p>В этом случае структура в <code>$_FILES</code> будет выглядеть так:</p>
<pre><code class="language-php">[
    'avatar' =&gt; [
        'tmp_name' =&gt; 'phpUxcOty',
        'name' =&gt; 'my-avatar.png',
        'size' =&gt; 90996,
        'type' =&gt; 'image/png',
        'error' =&gt; 0,
    ],
]
</code></pre>
<p>Нормализованная форма, возвращаемая функцией <code>getUploadedFiles()</code>, будет следующей:</p>
<pre><code class="language-php">[
    'avatar' =&gt; /* UploadedFileInterface instance */
]
</code></pre>
<p>В случае ввода с использованием обозначения массива для имени:</p>
<pre><code class="language-html">&lt;input type='file' name='my-form[details][avatar]' /&gt;
</code></pre>
<p><code>$_FILES</code> в конечном итоге выглядит так:</p>
<pre><code class="language-php"> [
    'my-form' =&gt; [
        'name' =&gt; [
            'details' =&gt; [
                'avatar' =&gt; 'my-avatar.png',
            ],
        ],
        'type' =&gt; [
            'details' =&gt; [
                'avatar' =&gt; 'image/png',
            ],
        ],
        'tmp_name' =&gt; [
            'details' =&gt; [
                'avatar' =&gt; 'phpmFLrzD',
            ],
        ],
        'error' =&gt; [
            'details' =&gt; [
                'avatar' =&gt; 0,
            ],
        ],
        'size' =&gt; [
            'details' =&gt; [
                'avatar' =&gt; 90996,
            ],
        ],
    ],
]
</code></pre>
<p>И соответствующее дерево, возвращаемое getUploadedFiles(), должно быть:</p>
<pre><code class="language-php">[
    'my-form' =&gt; [
        'details' =&gt; [
            'avatar' =&gt; /* UploadedFileInterface instance */
        ],
    ],
]
</code></pre>
<p>В некоторых случаях вы можете указать массив файлов:</p>
<pre><code class="language-html">Upload an avatar: &lt;input type='file' name='my-form[details][avatars][]' /&gt;
Upload an avatar: &lt;input type='file' name='my-form[details][avatars][]' /&gt;
</code></pre>
<p>(Например, элементы управления JavaScript могут создавать дополнительные поля для загрузки файлов, чтобы разрешить загрузку нескольких файлов одновременно.)</p>
<p>В таком случае реализация спецификации должна агрегировать всю информацию, относящуюся к файлу с заданным индексом. Причина в том, что <code>$_FILES</code> в таких случаях отклоняется от своей обычной структуры:</p>
<pre><code class="language-php"> [
    'my-form' =&gt; [
        'name' =&gt; [
            'details' =&gt; [
                'avatars' =&gt; [
                    0 =&gt; 'my-avatar.png',
                    1 =&gt; 'my-avatar2.png',
                    2 =&gt; 'my-avatar3.png',
                ],
            ],
        ],
        'type' =&gt; [
            'details' =&gt; [
                'avatars' =&gt; [
                    0 =&gt; 'image/png',
                    1 =&gt; 'image/png',
                    2 =&gt; 'image/png',
                ],
            ],
        ],
        'tmp_name' =&gt; [
            'details' =&gt; [
                'avatars' =&gt; [
                    0 =&gt; 'phpmFLrzD',
                    1 =&gt; 'phpV2pBil',
                    2 =&gt; 'php8RUG8v',
                ],
            ],
        ],
        'error' =&gt; [
            'details' =&gt; [
                'avatars' =&gt; [
                    0 =&gt; 0,
                    1 =&gt; 0,
                    2 =&gt; 0,
                ],
            ],
        ],
        'size' =&gt; [
            'details' =&gt; [
                'avatars' =&gt; [
                    0 =&gt; 90996,
                    1 =&gt; 90996,
                    3 =&gt; 90996,
                ],
            ],
        ],
    ],
]
</code></pre>
<p>Приведенный выше массив <code>$_FILES</code> будет соответствовать следующей структуре, возвращаемой функцией <code>getUploadedFiles()</code>:</p>
<pre><code class="language-php">[
    'my-form' =&gt; [
        'details' =&gt; [
            'avatars' =&gt; [
                0 =&gt; /* UploadedFileInterface instance */,
                1 =&gt; /* UploadedFileInterface instance */,
                2 =&gt; /* UploadedFileInterface instance */,
            ],
        ],
    ],
]
</code></pre>
<p>Разработчики будут обращаться к индексу <code>1</code> вложенного массива, используя:</p>
<pre><code class="language-php">$request-&gt;getUploadedFiles()['my-form']['details']['avatars'][1];
</code></pre>
<p>Поскольку данные загруженных файлов являются производными (получены из <code>$_FILES</code> или тела запроса), в интерфейсе также присутствует метод-мутатор <code>withUploadedFiles()</code>, позволяющий делегировать нормализацию другому процессу.</p>
<p>В случае с исходными примерами реализация выглядит следующим образом:</p>
<pre><code class="language-php">$file0 = $request-&gt;getUploadedFiles()['files'][0];
$file1 = $request-&gt;getUploadedFiles()['files'][1];

printf(
    &quot;Received the files %s and %s&quot;,
    $file0-&gt;getClientFilename(),
    $file1-&gt;getClientFilename()
);

// &quot;Received the files file0.txt and file1.html&quot;
</code></pre>
<p>В этом предложении также признается, что реализации могут работать в средах, отличных от SAPI. Таким образом, <code>UploadedFileInterface</code> предоставляет методы для обеспечения работы операций независимо от среды. Особенно:</p>
<ul>
<li><code>moveTo($targetPath)</code> предоставляется как безопасная и рекомендуемая альтернатива вызову <code>move_uploaded_file()</code> непосредственно для временного загружаемого файла. Реализации определят правильную операцию для использования в зависимости от среды.</li>
<li><code>getStream()</code> вернет экземпляр <code>StreamInterface</code>. В не SAPI
  средах одна из предлагаемых возможностей состоит в том, чтобы анализировать отдельные загружаемые файлы в потоки <code>php://temp</code>, а не непосредственно в файлы; в таких случаях загружаемый файл отсутствует. Таким образом, <code>getStream()</code> гарантированно работает независимо от среды.</li>
</ul>
<p>В качестве примеров:</p>
<pre><code>// Переместить файл в каталог загрузки
$filename = sprintf(
    '%s.%s',
    create_uuid(),
    pathinfo($file0-&gt;getClientFilename(), PATHINFO_EXTENSION)
);
$file0-&gt;moveTo(DATA_DIR . '/' . $filename);

// Stream a file to Amazon S3.
// Assume $s3wrapper is a PHP stream that will write to S3, and that
// Psr7StreamWrapper is a class that will decorate a StreamInterface as a PHP
// StreamWrapper.
$stream = new Psr7StreamWrapper($file1-&gt;getStream());
stream_copy_to_stream($stream, $s3wrapper);
</code></pre>
<h2 id="2">2. Пакеты</h2>
<p>Описанные интерфейсы и классы предоставляются как часть
Пакета <a href="https://packagist.org/packages/psr/http-message">psr/http-message</a>.</p>
<h2 id="3">3. Интерфейсы</h2>
<h3 id="31-psrhttpmessagemessageinterface">3.1 <code>Psr\Http\Message\MessageInterface</code></h3>
<pre><code class="language-php">&lt;?php
namespace Psr\Http\Message;

/**
 * Сообщения HTTP состоят из запросов от клиента к серверу и ответов от сервера 
 * к клиенту. 
 * Этот интерфейс определяет методы, общие для каждого из них.
 *
 * Сообщения считаются неизменяемыми; все методы, которые могут изменить 
 * состояние, ДОЛЖНЫ быть реализованы таким образом, чтобы они сохраняли 
 * внутреннее состояние текущего сообщения и возвращали экземпляр, 
 * содержащий измененное состояние.
 *
 * @see http://www.ietf.org/rfc/rfc7230.txt
 * @see http://www.ietf.org/rfc/rfc7231.txt
 */
interface MessageInterface
{
    /**
     * Извлекает версию протокола HTTP в виде строки.
     *
     * Строка ДОЛЖНА содержать только номер версии HTTP (например, «1.1», «1.0»).
     *
     * @return string Версия протокола HTTP.
     */
    public function getProtocolVersion();

    /**
     * Возвращает экземпляр с указанной версией протокола HTTP.
     *
     * Строка ДОЛЖНА содержать только номер версии HTTP (например, «1.1», «1.0»).
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить 
     * неизменность сообщения, и ДОЛЖЕН возвращать экземпляр с новой 
     * версией протокола.
     *
     * @param string $version Версия протокола HTTP.
     * @return static
     */
    public function withProtocolVersion($version);

    /**
     * Извлекает все значения заголовков сообщений.
     *
     * Ключи представляют собой имя заголовка, которое будет отправлено по сети, 
     * а каждое значение представляет собой массив строк, связанных с заголовком.
     *
     *     // Представляем заголовки в виде строки
     *     foreach ($message-&gt;getHeaders() as $name =&gt; $values) {
     *         echo $name . ': ' . implode(', ', $values);
     *     }
     *
     *     // Генерируйте заголовки итеративно:
     *     foreach ($message-&gt;getHeaders() as $name =&gt; $values) {
     *         foreach ($values as $value) {
     *             header(sprintf('%s: %s', $name, $value), false);
     *         }
     *     }
     *
     * Хотя имена заголовков не чувствительны к регистру, getHeaders() 
     * сохранит точный регистр, в котором заголовки были изначально указаны.
     *
     * @return string[][] Возвращает ассоциативный массив заголовков сообщения. 
     * Каждый ключ ДОЛЖЕН быть именем заголовка, 
     * а каждое значение ДОЛЖНО быть массивом строк для этого заголовка.
     */
    public function getHeaders();

    /**
     * Проверяет, существует ли заголовок по данному имени без учета регистра.
     *
     * @param string $name Имя поля заголовка без учета регистра.
     * @return bool Возвращает true, если какие-либо имена заголовков совпадают 
     * с заданным именем заголовка, используя сравнение строк без учета регистра. 
     * Возвращает false, если в сообщении не найдено подходящего имени заголовка.
     */
    public function hasHeader($name);

    /**
     * Извлекает значение заголовка сообщения по заданному имени без учета регистра.
     *
     * Этот метод возвращает массив всех значений заголовка данного имени заголовка 
     * без учета регистра.
     *
     * Если заголовок не отображается в сообщении, этот метод ДОЛЖЕН возвращать 
     * пустой массив.
     *
     * @param string $name Имя поля заголовка без учета регистра.
     * @return string[] Массив строковых значений, предусмотренный для данного 
     * заголовка. 
     * Если заголовок не отображается в сообщении, этот метод ДОЛЖЕН возвращать 
     * пустой массив.
     */
    public function getHeader($name);

    /**
     * Извлекает разделенную запятыми строку значений для одного заголовка.
     *
     * Этот метод возвращает все значения заголовка данного имени заголовка 
     * без учета регистра в виде строки, объединенной вместе с помощью запятой.
     *
     * ПРИМЕЧАНИЕ. Не все значения заголовков могут быть надлежащим образом представлены
     * с помощью конкатенации запятых. Для таких заголовков используйте вместо этого
     * getHeader() и укажите свой собственный разделитель при объединении.
     *
     * Если заголовок не отображается в сообщении, этот метод ДОЛЖЕН возвращать пустую строку.
     *
     * @param string $name Имя поля заголовка без учета регистра.
     * @return string Строка значений, предусмотренных для данного заголовка, 
     * объединенных вместе с помощью запятой. Если заголовок не отображается в сообщении, 
     * этот метод ДОЛЖЕН возвращать пустую строку.
     */
    public function getHeaderLine($name);

    /**
     * Возвращает экземпляр с предоставленным значением, заменяющим указанный заголовок.
     *
     * Хотя имена заголовков нечувствительны к регистру, эта функция сохраняет 
     * регистр заголовков и возвращает их из getHeaders().
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить 
     * неизменность сообщения, и ДОЛЖЕН возвращать экземпляр с новым и/или 
     * обновленным заголовком и значением.
     *
     * @param string $name Имя поля заголовка без учета регистра.
     * @param string|string[] $value Значение(я) заголовка.
     * @return static
     * @throws \InvalidArgumentException для недопустимых имен заголовков или значений.
     */
    public function withHeader($name, $value);

    /**
     * Возвращает экземпляр с указанным заголовком, к которому добавлено заданное значение.
     *
     * Существующие значения для указанного заголовка будут сохранены. 
     * Новые значения будут добавлены к существующему списку. 
     * Если заголовок ранее не существовал, он будет добавлен.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить неизменность сообщения, 
     * и ДОЛЖЕН возвращать экземпляр с новым заголовком и/или значением.
     *
     * @param string $name Добавляемое имя поля заголовка без учета регистра.
     * @param string|string[] $value Значение(я) заголовка.
     * @return static
     * @throws \InvalidArgumentException для недопустимых имен заголовков.
     * @throws \InvalidArgumentException для недопустимых значений заголовка.
     */
    public function withAddedHeader($name, $value);

    /**
     * Возвращает экземпляр без указанного заголовка.
     *
     * Разрешение заголовка ДОЛЖНО выполняться без учета регистра.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить 
     * неизменность сообщения, и ДОЛЖЕН возвращать экземпляр, удаляющий 
     * именованный заголовок.
     *
     * @param string $name Имя поля заголовка без учета регистра, которое нужно удалить.
     * @return static
     */
    public function withoutHeader($name);

    /**
     * Получает тело сообщения.
     *
     * @return StreamInterface Возвращает тело в виде потока.
     */
    public function getBody();

    /**
     * Возвращает экземпляр с указанным телом сообщения.
     *
     * Тело ДОЛЖНО быть объектом StreamInterface.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить 
     * неизменность сообщения, и ДОЛЖЕН возвращать новый экземпляр с 
     * новым потоком тела.
     *
     * @param StreamInterface $body Тело.
     * @return static
     * @throws \InvalidArgumentException Когда тело недействительно.
     */
    public function withBody(StreamInterface $body);
}
</code></pre>
<h3 id="32-psrhttpmessagerequestinterface">3.2 <code>Psr\Http\Message\RequestInterface</code></h3>
<pre><code class="language-php">&lt;?php
namespace Psr\Http\Message;

/**
 * Представляет исходящий запрос на стороне клиента.
 *
 * В соответствии со спецификацией HTTP этот интерфейс включает 
 * свойства для каждого из следующих элементов:
 *
 * - Версия протокола
 * - HTTP-метод
 * - URI
 * - Заголовки
 * - Тело сообщения
 *
 * Во время выполнения различные реализации ДОЛЖНЫ пытаться установить 
 * заголовок узла из предоставленного URI, если заголовок узла не предоставлен.
 *
 * Запросы считаются неизменяемыми; все методы, которые могут изменить 
 * состояние, ДОЛЖНЫ быть реализованы таким образом, чтобы они сохраняли 
 * внутреннее состояние текущего сообщения и возвращали экземпляр, 
 * содержащий измененное состояние.
 */
interface RequestInterface extends MessageInterface
{
    /**
     * Извлекает цель запроса сообщения.
     *
     * Извлекает цель запроса сообщения либо в том виде, в каком она 
     * появится (для клиентов), в том виде, в каком она появилась по 
     * запросу (для серверов), либо в том виде, в каком она была указана 
     * для экземпляра (см. withRequestTarget()).
     *
     * В большинстве случаев это будет исходная форма составленного URI, 
     * если только конкретная реализация не предоставила значение 
     * (см. withRequestTarget() ниже).
     *
     * Если URI недоступен и цель запроса не указана, этот метод 
     * ДОЛЖЕН вернуть строку «/».
     *
     * @return string
     */
    public function getRequestTarget();

    /**
     * Возвращает экземпляр с определенной целью запроса.
     *
     * Если для запроса требуется цель запроса, отличная от формы источника, 
     * например, для указания абсолютной формы, формы полномочий или 
     * формы звездочки,bэтот метод может использоваться для создания экземпляра 
     * с указанной целью запроса, дословно.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить 
     * неизменность сообщения, и ДОЛЖЕН возвращать экземпляр с измененной 
     * целью запроса.
     *
     * @see http://tools.ietf.org/html/rfc7230#section-5.3 (для различных форм 
     * запроса-цели, разрешенных в сообщениях запроса)
     * @param mixed $requestTarget
     * @return static
     */
    public function withRequestTarget($requestTarget);

    /**
     * Извлекает HTTP-метод запроса.
     *
     * @return string Возвращает метод запроса.
     */
    public function getMethod();

    /**
     * Возвращает экземпляр с предоставленным методом HTTP.
     *
     * Хотя имена методов HTTP обычно состоят из символов верхнего регистра, 
     * имена методов HTTP чувствительны к регистру, поэтому реализациям 
     * НЕ СЛЕДУЕТ изменять данную строку.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить 
     * неизменность сообщения, и ДОЛЖЕН возвращать экземпляр с измененным 
     * методом запроса.
     *
     * @param string $method Метод с учетом регистра.
     * @return static
     * @throws \InvalidArgumentException для недопустимых методов HTTP.
     */
    public function withMethod($method);

    /**
     * Извлекает экземпляр URI.
     *
     * Этот метод ДОЛЖЕН возвращать экземпляр UriInterface.
     *
     * @see http://tools.ietf.org/html/rfc3986#section-4.3
     * @return UriInterface Возвращает экземпляр UriInterface, 
     * представляющий URI запроса.
     */
    public function getUri();

    /**
     * Возвращает экземпляр с предоставленным URI.
     *
     * Этот метод ДОЛЖЕН обновлять заголовок узла возвращенного запроса 
     * по умолчанию, если URI содержит компонент узла. Если URI не содержит 
     * компонента хоста, любой ранее существовавший заголовок хоста ДОЛЖЕН 
     * быть перенесен в возвращаемый запрос.
     *
     * Вы можете согласиться на сохранение исходного состояния заголовка Host, 
     * установив для `$preserveHost` значение `true`. Когда для `$preserveHost`
     * установлено значение `true`, этот метод взаимодействует с заголовком
     * Host следующими способами:
     *
     * - Если заголовок узла отсутствует или пуст, а новый URI содержит компонент 
     *   узла, этот метод ДОЛЖЕН обновить заголовок узла в возвращаемом запросе.
     * - Если заголовок узла отсутствует или пуст, а новый URI не содержит 
     *   компонента узла, этот метод НЕ ДОЛЖЕН обновлять заголовок узла 
     *   в возвращаемом запросе.
     * - Если заголовок Host присутствует и не является пустым, 
     *   этот метод НЕ ДОЛЖЕН обновлять заголовок Host 
     *   в возвращаемом запросе.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить 
     * неизменность сообщения, и ДОЛЖЕН возвращать экземпляр, который имеет 
     * новый экземпляр UriInterface.
     *
     * @see http://tools.ietf.org/html/rfc3986#section-4.3
     * @param UriInterface $uri Новый URI запроса для использования.
     * @param bool $preserveHost Сохранять исходное состояние заголовка узла?
     * @return static
     */
    public function withUri(UriInterface $uri, $preserveHost = false);
}
</code></pre>
<h4 id="321-psrhttpmessageserverrequestinterface">3.2.1 <code>Psr\Http\Message\ServerRequestInterface</code></h4>
<pre><code class="language-php">&lt;?php
namespace Psr\Http\Message;

/**
 * Представляет входящий HTTP-запрос на стороне сервера.
 *
 * В соответствии со спецификацией HTTP этот интерфейс включает 
 * свойства для каждого из следующих элементов:
 *
 * - Версия протокола
 * - HTTP-метод
 * - URI
 * - Заголовки
 * - Тело сообщения
 *
 * Кроме того, он инкапсулирует все данные, поступающие в приложение из 
 * среды CGI и/или PHP, включая:
 *
  * - Значения, представленные в $_SERVER.
  * - Любые предоставленные файлы cookie (обычно через $_COOKIE)
  * - Аргументы строки запроса (обычно через $_GET или анализируются с помощью
  * parse_str())
  * - Загруженные файлы, если они есть (представлено в $_FILES)
  * - Десериализованные параметры тела (обычно из $_POST)
 *
 * Значения $_SERVER ДОЛЖНЫ рассматриваться как неизменяемые, поскольку
 * они представляют состояние приложения во время запроса; как таковые, 
 * не предусмотрено никаких методов, позволяющих изменять эти значения. 
 * Другие значения предоставляют такие методы, поскольку они могут быть 
 * восстановлены из $_SERVER или тела запроса и могут нуждаться в 
 * обработке во время приложения (например, параметры тела могут быть 
 * десериализованы на основе типа контента).
 *
 * Кроме того, этот интерфейс распознает полезность самопроверки запроса
 * для получения и сопоставления дополнительных параметров (например, 
 * путем сопоставления пути URI, расшифровки значений cookie, 
 * десериализации содержимого тела, не закодированного в форме, 
 * сопоставления заголовков авторизации с пользователями и т. д.). 
 * Эти параметры хранятся в свойстве «атрибуты».
 *
 * Запросы считаются неизменяемыми; все методы, которые могут изменить
 * состояние, ДОЛЖНЫ быть реализованы таким образом, чтобы они 
 * сохраняли внутреннее состояние текущего сообщения и возвращали 
 * экземпляр, содержащий измененное состояние.
 */
interface ServerRequestInterface extends RequestInterface
{
    /**
     * Получить параметры сервера.
     *
     * Извлекает данные, относящиеся к среде входящих запросов, 
     * обычно получаемые из суперглобальной переменной PHP $_SERVER. 
     * НЕ ТРЕБУЕТСЯ, чтобы данные изначально были в $_SERVER.
     *
     * @return array
     */
    public function getServerParams();

    /**
     * Получить данные в файлах cookie.
     *
     * Извлекает файлы cookie, отправленные клиентом на сервер.
     *
     * Данные ДОЛЖНЫ быть совместимы со структурой суперглобального 
     * массива $_COOKIE.
     *
     * @return array
     */
    public function getCookieParams();

    /**
     * Вернуть экземпляр с указанными файлами cookie.
     *
     * НЕ ТРЕБУЕТСЯ, чтобы данные поступали из суперглобала $_COOKIE, 
     * но ДОЛЖНЫ быть совместимы со структурой $_COOKIE. 
     * Как правило, эти данные создаются при создании экземпляра.
     *
     * Этот метод НЕ ДОЛЖЕН обновлять соответствующий заголовок Cookie 
     * экземпляра запроса или соответствующие значения в параметрах сервера.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить 
     * неизменность сообщения, и ДОЛЖЕН возвращать экземпляр с 
     * обновленными значениями cookie.
     *
     * @param array $cookies Массив пар ключ/значение, представляющий файлы cookie.
     * @return static
     */
    public function withCookieParams(array $cookies);

    /**
     * Получить аргументы строки запроса.
     *
     * Извлекает десериализованные аргументы строки запроса, если они есть.
     *
     * Примечание: параметры запроса могут не синхронизироваться с параметрами 
     * URI или сервера. Если вам нужно убедиться, что вы получаете только исходные 
     * значения, вам может потребоваться проанализировать строку запроса из 
     * `getUri()-&gt;getQuery()` или из параметра сервера `QUERY_STRING`.
     *
     * @return array
     */
    public function getQueryParams();

    /**
     * Возвращает экземпляр с указанными аргументами строки запроса.
     *
     * Эти значения ДОЛЖНЫ оставаться неизменными в течение входящего запроса. 
     * Они МОГУТ быть введены во время создания экземпляра, например, 
     * из суперглобального массива PHP $_GET, или МОГУТ быть получены 
     * из какого-либо другого значения, такого как URI. В тех случаях, 
     * когда аргументы анализируются из URI, данные ДОЛЖНЫ быть совместимы с тем, 
     * что возвращает PHP-функция parse_str() для целей обработки повторяющихся 
     * параметров запроса и обработки вложенных наборов.
     *
     * Установка аргументов строки запроса НЕ ДОЛЖНА изменять URI, 
     * хранящийся в запросе, или значения в параметрах сервера.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить 
     * неизменность сообщения, и ДОЛЖЕН возвращать экземпляр с обновленными 
     * аргументами строки запроса.
     *
     * @param array $query Массив аргументов строки запроса, обычно из $_GET.
     * @return static
     */
    public function withQueryParams(array $query);

    /**
     * Получить нормализованные данные загрузки файла.
     *
     * Этот метод возвращает метаданные загрузки в нормализованном дереве, 
     * где каждый лист является экземпляром Psr\Http\Message\UploadedFileInterface.
     *
     * Эти значения МОГУТ быть подготовлены из $_FILES или тела сообщения во время 
     * создания экземпляра или МОГУТ вводиться через withUploadedFiles().
     *
     * @return array Дерево массива экземпляров UploadedFileInterface; 
     * пустой массив ДОЛЖЕН быть возвращен, если данные отсутствуют.
     */
    public function getUploadedFiles();

    /**
     * Создает новый экземпляр с указанными загруженными файлами.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, чтобы сохранить 
     * неизменность сообщения, и ДОЛЖЕН возвращать экземпляр с обновленными 
     * параметрами тела.
     *
     * @param array $uploadedFiles Дерево массива экземпляров UploadedFileInterface.
     * @return static
     * @throws \InvalidArgumentException если указана недопустимая структура.
     */
    public function withUploadedFiles(array $uploadedFiles);

    /**
     * Получить все параметры, указанные в теле запроса.
     *
     * Если Content-Type запроса имеет значение application/x-www-form-urlencoded 
     * или multipart/form-data, а метод запроса — POST, этот метод ДОЛЖЕН 
     * возвращать содержимое $_POST.
     *
     * В противном случае этот метод может вернуть любые результаты десериализации 
     * содержимого тела запроса; поскольку синтаксический анализ возвращает 
     * структурированное содержимое, потенциальные типы ДОЛЖНЫ быть только 
     * массивами или объектами. Нулевое значение указывает на отсутствие 
     * основного содержимого.
     *
     * @return null|array|object Десериализованные параметры тела, если они есть.
     *     Обычно это массив или объект.
     */
    public function getParsedBody();

    /**
     * Возвращает экземпляр с указанными параметрами тела.
     *
     * Они МОГУТ быть введены во время создания экземпляра.
     *
     * Если Content-Type запроса имеет значение 
     * application/x-www-form-urlencoded или multipart/form-data, 
     * а метод запроса — POST, используйте этот метод ТОЛЬКО 
     * для внедрения содержимого $_POST.
     *
     * НЕ ТРЕБУЮТСЯ чтобы данные поступали из $_POST, но они ДОЛЖНЫ 
     * быть результатом десериализации содержимого тела запроса. 
     * Десериализация/анализ возвращает структурированные данные, 
     * и поэтому этот метод принимает ТОЛЬКО массивы или объекты или 
     * нулевое значение, если ничего не было доступно для анализа.
     *
     * Например, если согласование содержимого определяет, 
     * что данные запроса представляют собой полезные данные JSON, 
     * этот метод можно использовать для создания экземпляра 
     * запроса с десериализованными параметрами.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, 
     * чтобы сохранить неизменность сообщения, и 
     * ДОЛЖЕН возвращать экземпляр с обновленными параметрами тела.
     *
     * @param null|array|object $data Десериализованные данные тела. 
     * Обычно это массив или объект.
     * @return static
     * @throws \InvalidArgumentException если указан неподдерживаемый 
     * тип аргумента.
     */
    public function withParsedBody($data);

    /**
     * Получить атрибуты, полученные из запроса.
     *
     * «Атрибуты» запроса могут использоваться для обеспечения 
     * возможности внедрения любых параметров, полученных из запроса: 
     * например, результаты операций сопоставления пути; 
     * результаты расшифровки файлов cookie; 
     * результаты десериализации тел сообщений, не закодированных в форме; 
     * и т. д. 
     * Атрибуты будут зависеть от приложения и запроса и МОГУТ 
     * быть изменяемыми.
     *
     * @return mixed[] Атрибуты, полученные из запроса.
     */
    public function getAttributes();

    /**
     * Получить один производный атрибут запроса.
     *
     * Извлекает один производный атрибут запроса, как описано 
     * в getAttributes(). Если атрибут ранее не был установлен, 
     * возвращает значение по умолчанию, как указано.
     *
     * Этот метод устраняет необходимость в методе hasAttribute(), 
     * поскольку он позволяет указать значение по умолчанию, 
     * которое будет возвращено, если атрибут не найден.
     *
     * @see getAttributes()
     * @param string $name Имя атрибута.
     * @param mixed $default Значение по умолчанию, которое возвращается, 
     * если атрибут не существует.
     * @return mixed
     */
    public function getAttribute($name, $default = null);

    /**
     * Возвращает экземпляр с указанным производным атрибутом запроса.
     *
     * Этот метод позволяет установить один производный атрибут запроса,
     * как описано в getAttributes().
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, 
     * чтобы сохранить неизменность сообщения, и 
     * ДОЛЖЕН возвращать экземпляр с обновленным атрибутом.
     *
     * @see getAttributes()
     * @param string $name Имя атрибута.
     * @param mixed $value Значение атрибута.
     * @return static
     */
    public function withAttribute($name, $value);

    /**
     * Возвращает экземпляр, который удаляет указанный производный 
     * атрибут запроса.
     *
     * Этот метод позволяет удалить один производный атрибут запроса, 
     * как описано в getAttributes().
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом,
     * чтобы сохранить неизменность сообщения, и ДОЛЖЕН 
     * возвращать экземпляр, удаляющий атрибут.
     *
     * @see getAttributes()
     * @param string $name Имя атрибута.
     * @return static
     */
    public function withoutAttribute($name);
}
</code></pre>
<h3 id="33-psrhttpmessageresponseinterface">3.3 <code>Psr\Http\Message\ResponseInterface</code></h3>
<pre><code class="language-php">&lt;?php
namespace Psr\Http\Message;

/**
 * Представление исходящего ответа на стороне сервера.
 *
 * В соответствии со спецификацией HTTP этот интерфейс 
 * включает свойства для каждого из следующих элементов:
 *
 * - Версия протокола
 * - Код состояния и фраза причины
 * - Заголовки
 * - Тело сообщения
 *
 * Ответы считаются неизменными; все методы, которые могут 
 * изменить состояние, ДОЛЖНЫ быть реализованы таким образом, 
 * чтобы они сохраняли внутреннее состояние текущего сообщения 
 * и возвращали экземпляр, содержащий измененное состояние.
 */
interface ResponseInterface extends MessageInterface
{
    /**
     * Получает код состояния ответа.
     *
     * Код состояния представляет собой 3-значный целочисленный 
     * код результата попытки сервера понять и удовлетворить запрос.
     *
     * @return int Код состояния.
     */
    public function getStatusCode();

    /**
     * Возвращает экземпляр с указанным кодом состояния и, 
     * необязательно, фразой причины.
     *
     * Если фраза причины не указана, реализации МОГУТ выбрать 
     * по умолчанию RFC 7231 или рекомендованную IANA фразу 
     * причины для кода состояния ответа.
     *
     * Этот метод ДОЛЖЕН быть реализован таким образом, 
     * чтобы сохранить неизменность сообщения, и 
     * ДОЛЖЕН возвращать экземпляр с обновленным статусом и 
     * фразой причины.
     *
     * @see http://tools.ietf.org/html/rfc7231#section-6
     * @see http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
     * @param int $code 3-значный целочисленный код результата, 
     * который необходимо установить.
     * @param string $reasonPhrase Фраза причины для использования 
     * с предоставленным кодом состояния; если ничего не указано, 
     * реализации МОГУТ использовать значения по умолчанию, 
     * как это предлагается в спецификации HTTP.
     * @return static
     * @throws \InvalidArgumentException Для недопустимых аргументов 
     * кода состояния.
     */
    public function withStatus($code, $reasonPhrase = '');

    /**
     * Получает фразу причины ответа, связанную с кодом состояния.
     *
     * Поскольку фраза причины не является обязательным элементом 
     * в строке состояния ответа, значение фразы причины МОЖЕТ быть пустым. 
     * Реализации МОГУТ возвращать фразу причины, рекомендованную RFC 7231 
     * по умолчанию (или те, которые перечислены в реестре кодов состояния 
     * HTTP IANA) для кода состояния ответа.
     *
     * @see http://tools.ietf.org/html/rfc7231#section-6
     * @see http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
     * @return string Reason phrase; must return an empty string if none present.
     */
    public function getReasonPhrase();
}
</code></pre>
<h3 id="34-psrhttpmessagestreaminterface">3.4 <code>Psr\Http\Message\StreamInterface</code></h3>
<pre><code class="language-php">&lt;?php
namespace Psr\Http\Message;

/**
 * Описывает поток данных.
 *
 * Как правило, экземпляр оборачивает поток PHP; 
 * этот интерфейс обеспечивает оболочку для наиболее распространенных
 * операций, включая сериализацию всего потока в строку.
 */
interface StreamInterface
{
    /**
     * Считывает все данные из потока в строку от начала до конца.
     *
     * Этот метод ДОЛЖЕН пытаться найти начало потока перед чтением 
     * данных и читать поток, пока не будет достигнут конец.
     *
     * Предупреждение: Это может попытаться загрузить в память большой объем данных.
     *
     * Этот метод НЕ ДОЛЖЕН вызывать исключение, чтобы соответствовать 
     * операциям приведения строк PHP.
     *
     * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring
     * @return string
     */
    public function __toString();

    /**
     * Закрывает поток и все базовые ресурсы.
     *
     * @return void
     */
    public function close();

    /**
     * Отделяет любые базовые ресурсы от потока.
     *
     * После того, как поток был отсоединен, поток находится в 
     * непригодном для использования состоянии.
     *
     * @return resource|null Базовый поток PHP, если таковой имеется
     */
    public function detach();

    /**
     * Получает размер потока, если он известен.
     *
     * @return int|null Возвращает размер в байтах, если он известен, 
     * или null, если он неизвестен.
     */
    public function getSize();

    /**
     * Возвращает текущую позицию указателя чтения/записи файла.
     *
     * @return int Позиция указателя файла
     * @throws \RuntimeException по ошибке.
     */
    public function tell();

    /**
     * Возвращает true, если поток находится в конце потока.
     *
     * @return bool
     */
    public function eof();

    /**
     * Возвращает, является ли поток доступным для поиска.
     *
     * @return bool
     */
    public function isSeekable();

    /**
     * Ищет позицию в потоке.
     *
     * @see http://www.php.net/manual/en/function.fseek.php
     * @param int $offset Смещение
     * @param int $whence Указывает, как будет рассчитываться позиция
     * курсора на основе смещения. Допустимые значения идентичны
     * встроенным в PHP значениям $whence для `fseek()`. SEEK_SET: 
     * Установить позицию, равную байтам смещения. SEEK_CUR: Установить 
     * позицию как текущую позицию плюс смещение. SEEK_END: Установить 
     * позицию как конец потока плюс смещение.
     * @throws \RuntimeException on failure.
     */
    public function seek($offset, $whence = SEEK_SET);

    /**
     * Ищет начало потока.
     *
     * Если поток недоступен для поиска, этот метод вызовет исключение; 
     * в противном случае он выполнит seek(0).
     *
     * @see seek()
     * @see http://www.php.net/manual/en/function.fseek.php
     * @throws \RuntimeException при неудаче.
     */
    public function rewind();

    /**
     * Возвращает, доступен ли поток для записи.
     *
     * @return bool
     */
    public function isWritable();

    /**
     * Записывает данные в поток.
     *
     * @param string $string Строка, которая должна быть записана.
     * @return int Возвращает количество байтов, записанных в поток.
     * @throws \RuntimeException при неудаче.
     */
    public function write($string);

    /**
     * Возвращает, доступен ли поток для чтения.
     *
     * @return bool
     */
    public function isReadable();

    /**
     * Чтение данных из потока.
     *
     * @param int $length Считайте до $length байтов из объекта и верните их. 
     * Может быть возвращено меньше байтов, чем $length, 
     * если базовый вызов потока возвращает меньше байтов.
     * @return string Возвращает данные, считанные из потока, 
     * или пустую строку, если нет доступных байтов.
     * @throws \RuntimeException если возникает ошибка.
     */
    public function read($length);

    /**
     * Возвращает оставшееся содержимое в строке
     *
     * @return string
     * @throws \RuntimeException если чтение невозможно.
     * @throws \RuntimeException если при чтении возникает ошибка.
     */
    public function getContents();

    /**
     * Получает метаданные потока в виде ассоциативного массива 
     * или извлекает определенный ключ.
     *
     * Возвращаемые ключи идентичны ключам, возвращаемым функцией
     * PHP stream_get_meta_data().
     *
     * @see http://php.net/manual/en/function.stream-get-meta-data.php
     * @param string $key Конкретные метаданные для извлечения.
     * @return array|mixed|null Возвращает ассоциативный массив, 
     * если ключ не указан. Возвращает конкретное значение ключа, 
     * если ключ предоставлен и значение найдено, или ноль, 
     * если ключ не найден.
     */
    public function getMetadata($key = null);
}
</code></pre>
<h3 id="35-psrhttpmessageuriinterface">3.5 <code>Psr\Http\Message\UriInterface</code></h3>
<pre><code class="language-php">&lt;?php
namespace Psr\Http\Message;

/**
 * Объект значения, представляющий URI.
 *
 * Этот интерфейс предназначен для представления URI в соответствии с 
 * RFC 3986 и предоставления методов для наиболее распространенных операций. 
 * Дополнительные функции для работы с URI могут быть предоставлены 
 * поверх интерфейса или извне. В основном он используется для HTTP-запросов, 
 * но может использоваться и в других контекстах.
 *
 * Экземпляры этого интерфейса считаются неизменяемыми; 
 * все методы, которые могут изменить состояние, ДОЛЖНЫ быть 
 * реализованы таким образом, чтобы они сохраняли внутреннее 
 * состояние текущего экземпляра и возвращали экземпляр, 
 * содержащий измененное состояние.
 *
 * Обычно заголовок Host также присутствует в сообщении запроса. 
 * Для запросов на стороне сервера схему обычно можно 
 * обнаружить в параметрах сервера.
 *
 * @see http://tools.ietf.org/html/rfc3986 (the URI specification)
 */
interface UriInterface
{
    /**
     * Получает компонент схемы URI.
     *
     * Если схемы нет, этот метод ДОЛЖЕН возвращать пустую строку.
     *
     * Возвращаемое значение ДОЛЖНО быть приведено к нижнему регистру 
     * в соответствии с RFC 3986. Section 3.1.
     * 
     *
     * Завершающий символ «:» не является частью схемы и 
     * НЕ ДОЛЖЕН добавляться.
     *
     * @see https://tools.ietf.org/html/rfc3986#section-3.1
     * @return string Схема URI.
     */
    public function getScheme();

    /**
     * Получите компонент полномочий URI.
     *
     * Если информация о полномочиях отсутствует, 
     * этот метод ДОЛЖЕН возвращать пустую строку.
     *
     * Синтаксис полномочий URI:
     *
     * &lt;pre&gt;
     * [user-info@]host[:port]
     * &lt;/pre&gt;
     *
     * Если компонент порта не установлен или является стандартным 
     * портом для текущей схемы, его НЕ СЛЕДУЕТ включать.
     *
     * @see https://tools.ietf.org/html/rfc3986#section-3.2
     * @return string The URI authority, in &quot;[user-info@]host[:port]&quot; format.
     */
    public function getAuthority();

    /**
     * Получите компонент информации о пользователе URI.
     *
     * Если информация о пользователе отсутствует, 
     * этот метод ДОЛЖЕН возвращать пустую строку.
     *
     * Если пользователь присутствует в URI, это вернет это значение; 
     * кроме того, если пароль также присутствует, 
     * он будет добавлен к значению пользователя с двоеточием (&quot;:&quot;), 
     * разделяющим значения.
     *
     * Завершающий символ «@» не является частью информации 
     * о пользователе и НЕ ДОЛЖЕН добавляться.
     *
     * @return string Информация о пользователе URI в формате 
     * «имя пользователя[:пароль]».
     */
    public function getUserInfo();

    /**
     * Получите хост-компонент URI.
     *
     * Если хост отсутствует, этот метод ДОЛЖЕН возвращать пустую строку.
     *
     * Возвращаемое значение ДОЛЖНО быть приведено к 
        * нижнему регистру в соответствии с RFC 3986. Section 3.2.2.
     * 
     *
     * @see http://tools.ietf.org/html/rfc3986#section-3.2.2
     * @return string Хост URI.
     */
    public function getHost();

    /**
     * Получите компонент порта URI.
     *
     * Если порт присутствует, и он нестандартен для текущей схемы, 
     * этот метод ДОЛЖЕН вернуть его как целое число. 
     * Если порт является стандартным портом, 
     * используемым в текущей схеме, этот метод ДОЛЖЕН возвращать значение null.
     *
     * Если нет ни порта, ни схемы, этот метод ДОЛЖЕН возвращать нулевое значение.
     *
     * Если порт отсутствует, но присутствует схема, этот метод МОЖЕТ вернуть 
     * стандартный порт для этой схемы, но ДОЛЖЕН возвращать значение null.
     *
     * @return null|int URI-порт.
     */
    public function getPort();

    /**
     * Получите компонент пути URI.
     *
     * Путь может быть либо пустым, либо абсолютным (начиная с косой черты), 
     * либо без корневого каталога (не начинающимся с косой черты). 
     * Реализации ДОЛЖНЫ поддерживать все три синтаксиса.
     *
     * Обычно пустой путь &quot;&quot; и абсолютный путь &quot;/&quot; считаются равными, 
     * как определено в RFC 7230, раздел 2.7.3. Но этот метод НЕ ДОЛЖЕН 
     * автоматически выполнять эту нормализацию, потому что в контекстах с 
     * обрезанным базовым путем, например. фронт-контроллера эта разница 
     * становится существенной. Задача пользователя — обрабатывать 
     * как «», так и «/».
     *
     * Возвращаемое значение ДОЛЖНО быть закодировано в процентах, 
     * но НЕ ДОЛЖНО дважды кодировать какие-либо символы. 
     * Чтобы определить, какие символы следует кодировать, 
     * обратитесь к RFC 3986, разделы 2 и 3.3.
     *
     * Например, если значение должно включать косую черту (&quot;/&quot;), 
     * не предназначенную для использования в качестве разделителя между 
     * сегментами пути, это значение ДОЛЖНО быть передано экземпляру 
     * в закодированной форме (например, &quot;%2F&quot;).
     *
     * @see https://tools.ietf.org/html/rfc3986#section-2
     * @see https://tools.ietf.org/html/rfc3986#section-3.3
     * @return string Путь URI.
     */
    public function getPath();

    /**
     * Получите строку запроса URI.
     *
     * Если строка запроса отсутствует, этот метод ДОЛЖЕН возвращать 
     * пустую строку.
     *
     * Ведущий &quot;?&quot; символ не является частью запроса и НЕ ДОЛЖЕН добавляться.
     *
     * Возвращаемое значение ДОЛЖНО быть закодировано в процентах, 
     * но НЕ ДОЛЖНО дважды кодировать какие-либо символы. 
     * Чтобы определить, какие символы следует кодировать, обратитесь к
     * RFC 3986, разделы 2 и 3.4.
     *
     * Например, если значение в паре ключ/значение строки запроса 
     * должно включать амперсанд (&quot;&amp;&quot;), не предназначенный для использования 
     * в качестве разделителя между значениями, это значение ДОЛЖНО быть 
     * передано в закодированной форме (например, &quot;%26&quot;). к экземпляру.
     *
     * @see https://tools.ietf.org/html/rfc3986#section-2
     * @see https://tools.ietf.org/html/rfc3986#section-3.4
     * @return string Строка запроса URI.
     */
    public function getQuery();

    /**
     * Возвращает компонент фрагмента URI.
     *
     * Если фрагмента нет, этот метод ДОЛЖЕН возвращать пустую строку.
     *
     * Начальный символ «#» не является частью фрагмента и 
     * НЕ ДОЛЖЕН быть добавлен.
     *
     * Возвращаемое значение ДОЛЖНО быть закодировано в процентах, 
     * но НЕ ДОЛЖНО дважды кодировать какие-либо символы. Чтобы определить, 
     * какие символы следует кодировать, обратитесь к RFC 3986, разделы 2 и 3.5.
     *
     * @see https://tools.ietf.org/html/rfc3986#section-2
     * @see https://tools.ietf.org/html/rfc3986#section-3.5
     * @return string Фрагмент URI.
     */
    public function getFragment();

    /**
     * Возвращает экземпляр с указанной схемой.
     *
     * Этот метод ДОЛЖЕН сохранять состояние текущего экземпляра и 
     * возвращать экземпляр, содержащий указанную схему.
     *
     * Реализации ДОЛЖНЫ поддерживать схемы &quot;http&quot; и &quot;https&quot; без
     * учета регистра и МОГУТ использовать другие схемы,
     * если это необходимо.
     *
     * Пустая схема эквивалентна удалению схемы.
     *
     * @param string $scheme Схема для использования с новым экземпляром.
     * @return static Новый экземпляр с указанной схемой.
     * @throws \InvalidArgumentException за недействительные схемы.
     * @throws \InvalidArgumentException для неподдерживаемых схем.
     */
    public function withScheme($scheme);

    /**
     * Вернуть экземпляр с указанной информацией о пользователе.
     *
     * Этот метод ДОЛЖЕН сохранять состояние текущего экземпляра и 
     * возвращать экземпляр, содержащий указанную информацию
     * о пользователе.
     *
     * Пароль необязателен, но информация о пользователе ДОЛЖНА включать 
     * имя пользователя; пустая строка для пользователя эквивалентна 
     * удалению информации о пользователе.
     *
     * @param string $user Имя пользователя, используемое для полномочий.
     * @param null|string $password Пароль, связанный с $user.
     * @return static Новый экземпляр с указанной информацией о пользователе.
     */
    public function withUserInfo($user, $password = null);

    /**
     * Вернуть экземпляр с указанным хостом.
     *
     * Этот метод ДОЛЖЕН сохранять состояние текущего экземпляра и 
     * возвращать экземпляр, содержащий указанный хост.
     *
     * Пустое значение хоста эквивалентно удалению хоста.
     *
     * @param string $host Имя хоста для использования с новым экземпляром.
     * @return static Новый экземпляр с указанным хостом.
     * @throws \InvalidArgumentException для недопустимых имен хостов.
     */
    public function withHost($host);

    /**
     * Вернуть экземпляр с указанным портом.
     *
     * Этот метод ДОЛЖЕН сохранять состояние текущего экземпляра и 
     * возвращать экземпляр, содержащий указанный порт.
     *
     * Реализации ДОЛЖНЫ вызывать исключение для портов за 
     * пределами установленных диапазонов портов TCP и UDP.
     *
     *Пустое значение, указанное для порта, эквивалентно удалению 
     * информации о порте.
     *
     * @param null|int $port Порт для использования с новым экземпляром; 
     * нулевое значение удаляет информацию о порте.
     * @return static Новый экземпляр с указанным портом.
     * @throws \InvalidArgumentException для недопустимых портов.
     */
    public function withPort($port);

    /**
     * Возвращает экземпляр с указанным путем.
     *
     * Этот метод ДОЛЖЕН сохранять состояние текущего экземпляра и 
     * возвращать экземпляр, содержащий указанный путь.
     *
     * Путь может быть либо пустым, либо абсолютным (начиная с косой черты), 
     * либо без корневого каталога (не начинающимся с косой черты). 
     * Реализации ДОЛЖНЫ поддерживать все три синтаксиса.
     *
     * Если предполагается, что путь HTTP относится к хосту, а не к пути, 
     * он должен начинаться с косой черты (&quot;/&quot;). Предполагается, что пути HTTP,
     * не начинающиеся с косой черты, относятся к некоторому базовому пути, 
     * известному приложению или потребителю.
     *
     * Пользователи могут предоставлять как закодированные, 
     * так и декодированные символы пути. Реализации обеспечивают 
     * правильное кодирование, как указано в getPath().
     *
     * @param string $path Путь для использования с новым экземпляром.
     * @return static Новый экземпляр с указанным путем.
     * @throws \InvalidArgumentException для неверных путей.
     */
    public function withPath($path);

    /**
     * Возвращает экземпляр с указанной строкой запроса.
     *
     * Этот метод ДОЛЖЕН сохранять состояние текущего экземпляра и 
     * возвращать экземпляр, содержащий указанную строку запроса.
     *
     * Пользователи могут предоставлять как закодированные, 
     * так и декодированные символы запроса.
     * Реализации обеспечивают правильное кодирование, 
     * как описано в getQuery().
     *
     * Пустое значение строки запроса эквивалентно удалению строки запроса.
     *
     * @param string $query Строка запроса для использования с новым экземпляром.
     * @return static Новый экземпляр с указанной строкой запроса.
     * @throws \InvalidArgumentException для недопустимых строк запроса.
     */
    public function withQuery($query);

    /**
     * Возвращает экземпляр с указанным фрагментом URI.
     *
     * Этот метод ДОЛЖЕН сохранять состояние текущего экземпляра и 
     * возвращать экземпляр, содержащий указанный фрагмент URI.
     *
     * Пользователи могут предоставлять как закодированные, 
     * так и декодированные символы фрагментов.
     * Реализации обеспечивают правильное кодирование, 
     * как указано в getFragment().
     *
     * Пустое значение фрагмента эквивалентно удалению фрагмента.
     *
     * @param string $fragment Фрагмент для использования с новым экземпляром.
     * @return static Новый экземпляр с указанным фрагментом.
     */
    public function withFragment($fragment);

    /**
     * Возвращает строковое представление URI.
     *
     * В зависимости от того, какие компоненты URI присутствуют, 
     * результирующая строка является либо полным URI, 
     * либо относительной ссылкой в соответствии с RFC 3986, раздел 4.1. 
     * Метод объединяет различные компоненты URI, 
     * используя соответствующие разделители:
     *
     * - Если схема присутствует, она ДОЛЖНА иметь суффикс «:».
     * - Если полномочия присутствуют, они ДОЛЖНЫ иметь префикс «//».
     * - Путь может быть объединен без разделителей. Но есть два случая, 
     * когда необходимо изменить путь, чтобы сделать ссылку URI действительной, 
     * поскольку PHP не позволяет генерировать исключение в __toString():
         - Если путь не имеет корня и присутствуют полномочия, 
     * путь ДОЛЖЕН иметь префикс «/».
           - Если путь начинается с более чем одного «/» и 
     * отсутствуют полномочия, начальные косые черты ДОЛЖНЫ быть сокращены до одного.
      - Если присутствует запрос, он ДОЛЖЕН иметь префикс «?».
      - Если присутствует фрагмент, он ДОЛЖЕН иметь префикс &quot;#&quot;.
     *
     * @see http://tools.ietf.org/html/rfc3986#section-4.1
     * @return string
     */
    public function __toString();
}
</code></pre>
<h3 id="36-psrhttpmessageuploadedfileinterface">3.6 <code>Psr\Http\Message\UploadedFileInterface</code></h3>
<pre><code class="language-php">&lt;?php
namespace Psr\Http\Message;

/**
 * Объект, представляющий файл, загруженный с помощью HTTP-запроса.
 *
 * Экземпляры этого интерфейса считаются неизменяемыми; 
 * все методы, которые могут изменить состояние, 
 * ДОЛЖНЫ быть реализованы таким образом, 
 * чтобы они сохраняли внутреннее состояние текущего экземпляра 
 * и возвращали экземпляр, содержащий измененное состояние.
 */
interface UploadedFileInterface
{
    /**
     * Возвращает поток, представляющий загруженный файл.
     *
     * Этот метод ДОЛЖЕН возвращать экземпляр StreamInterface, 
     * представляющий загруженный файл. Цель этого метода — 
     * позволить использовать встроенную функциональность потока 
     * PHP для управления загрузкой файла, например, 
     * stream_copy_to_stream() (хотя для работы с такими функциями 
     * результат должен быть оформлен в встроенной оболочке потока PHP).
     *
     * Если метод moveTo() был вызван ранее, 
     * этот метод ДОЛЖЕН вызвать исключение.
     *
     * @return StreamInterface Потоковое представление загруженного файла.
     * @throws \RuntimeException в случаях, когда поток недоступен.
     * @throws \RuntimeException в случаях, когда поток не может быть создан.
     */
    public function getStream();

    /**
     * Перемещает загруженный файл в новое место.
     *
     * Используйте этот метод как альтернативу move_uploaded_file(). 
     * Этот метод гарантированно работает как в средах SAPI, 
     * так и в средах, отличных от SAPI. Реализации должны определить, 
     * в какой среде они находятся, и использовать соответствующий метод 
     * (move_uploaded_file(), rename() или потоковая операция) 
     * для выполнения операции.
     *
     * $targetPath может быть абсолютным или относительным путем. 
     * Если это относительный путь, разрешение должно быть таким же,
     * как и в функции PHP rename().
     *
     * Исходный файл или поток ДОЛЖЕН быть удален после завершения.
     *
     * Если этот метод вызывается более одного раза, 
     * любые последующие вызовы ДОЛЖНЫ вызывать исключение.
     *
     * При использовании в среде SAPI, где $_FILES заполняется, 
     * при записи файлов через moveTo() СЛЕДУЕТ использовать 
     * is_uploaded_file() и move_uploaded_file(), 
     * чтобы обеспечить правильную проверку разрешений 
     * и статуса загрузки.
     *
     * Если вы хотите перейти к потоку, используйте getStream(), 
     * так как операции SAPI не могут гарантировать запись в места назначения потока.
     *
     * @see http://php.net/is_uploaded_file
     * @see http://php.net/move_uploaded_file
     * @param string $targetPath Путь, по которому следует переместить загруженный файл.
     * @throws \InvalidArgumentException если указанный $targetPath недействителен.
     * @throws \RuntimeException при любой ошибке во время операции перемещения.
     * @throws \RuntimeException при втором или последующем вызове метода.
     */
    public function moveTo($targetPath);

    /**
     * Получить размер файла.
     *
     * Реализации ДОЛЖНЫ возвращать значение, хранящееся в ключе &quot;размер&quot; 
     * файла в массиве $_FILES, если он доступен, поскольку PHP вычисляет
     * это на основе переданного фактического размера.
     *
     * @return int|null Размер файла в байтах или null, если он неизвестен.
     */
    public function getSize();

    /**
     * Возвращает ошибку, связанную с загруженным файлом.
     *
     * Возвращаемое значение ДОЛЖНО быть одной из констант PHP UPLOAD_ERR_XXX.
     *
     * Если файл был успешно загружен, этот метод ДОЛЖЕН вернуть UPLOAD_ERR_OK.
     *
     * Реализации ДОЛЖНЫ возвращать значение, 
     * хранящееся в ключе «ошибка» файла в массиве $_FILES.
     *
     * @see http://php.net/manual/en/features.file-upload.errors.php
     * @return int Одна из констант PHP UPLOAD_ERR_XXX.
     */
    public function getError();

    /**
     * Получить имя файла, отправленное клиентом.
     *
     * Не доверяйте значению, возвращаемому этим методом. 
     * Клиент может отправить вредоносное имя файла с 
     * намерением повредить или взломать ваше приложение.
     *
     * Реализации ДОЛЖНЫ возвращать значение, 
     * хранящееся в ключе «имя» файла в массиве $_FILES.
     *
     * @return string|null Имя файла, отправленное клиентом, 
     * или значение NULL, если оно не было указано.
     */
    public function getClientFilename();

    /**
     * Возвращает тип мультимедиа, отправленный клиентом.
     *
     * Не доверяйте значению, возвращаемому этим методом. 
     * Клиент может отправить вредоносный тип носителя с намерением 
     * повредить или взломать ваше приложение.
     *
     * Реализации ДОЛЖНЫ возвращать значение, 
     * хранящееся в ключе &quot;type&quot; файла в массиве $_FILES.
     *
     * @return string|null Тип носителя, отправленный клиентом, или null, 
     * если он не был указан.
     */
    public function getClientMediaType();
}
</code></pre>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.fac441b0.min.js"></script>
      
        <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
      
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
      
        <script src="../../js/init.js"></script>
      
    
  </body>
</html>