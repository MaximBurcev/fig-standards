
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://php-psr.ru/accepted/PSR-7-http-message-meta/">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.11">
    
    
      
        <title>Метадокумент HTTP-сообщений - Рекомендации по стандартам PHP: PSR</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.85bb2934.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#http-" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Рекомендации по стандартам PHP: PSR" class="md-header__button md-logo" aria-label="Рекомендации по стандартам PHP: PSR" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Рекомендации по стандартам PHP: PSR
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Метадокумент HTTP-сообщений
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Рекомендации по стандартам PHP: PSR" class="md-nav__button md-logo" aria-label="Рекомендации по стандартам PHP: PSR" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Рекомендации по стандартам PHP: PSR
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Рекомендации по стандартам PHP (PSR)
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-0/" class="md-nav__link">
        Стандарт автозагрузки PSR-0 (Устарело)
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-1-basic-coding-standard/" class="md-nav__link">
        Основной стандарт кодирования PSR-1
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-2-coding-style-guide/" class="md-nav__link">
        Руководство по стилю кодирования PSR-2
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-3-logger-interface/" class="md-nav__link">
        Общий интерфейс логирования PSR-3
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-4-autoloader/" class="md-nav__link">
        Стандарт автозагрузки PSR-4
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../proposed/phpdoc/" class="md-nav__link">
        PHPDoc PSR-5
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-6-cache/" class="md-nav__link">
        Общий интерфейс кэширования PSR-6
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-7-http-message/" class="md-nav__link">
        Интерфейсы HTTP-сообщений PSR-7
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-17-http-factory/" class="md-nav__link">
        HTTP-фабрики PSR-17
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-18-http-client/" class="md-nav__link">
        HTTP-клиент PSR-18
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-12-extended-coding-style-guide/" class="md-nav__link">
        Расширенное руководство по стилю кодирования PSR-12
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../proposed/phpdoc-tags/" class="md-nav__link">
        Теги PHPDoc PSR-19
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../LICENSE/" class="md-nav__link">
        Лицензия
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. Краткое содержание
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-http-php" class="md-nav__link">
    2. HTTP-сообщения в PHP
  </a>
  
    <nav class="md-nav" aria-label="2. HTTP-сообщения в PHP">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#http" class="md-nav__link">
    Поддержка HTTP на стороне клиента
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http_1" class="md-nav__link">
    Поддержка HTTP на стороне сервера
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3. Зачем?
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4. Суть
  </a>
  
    <nav class="md-nav" aria-label="4. Суть">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    4.1 Цели
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    4.2 Не является целью
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5. Дизайнерские решения
  </a>
  
    <nav class="md-nav" aria-label="5. Дизайнерские решения">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    Дизайн сообщения
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Почему в сообщениях есть методы заголовков, а не в пакете заголовков?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uri" class="md-nav__link">
    Почему URI представлены как объекты?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uri_1" class="md-nav__link">
    Почему в интерфейсе запроса есть методы для работы с целью запроса И создания URI?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Почему Объекты Значения?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vs-this" class="md-nav__link">
    Новые экземпляры vs возврат $this
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#x" class="md-nav__link">
    Использование потоков вместо X
  </a>
  
    <nav class="md-nav" aria-label="Использование потоков вместо X">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#what-if-i-just-want-to-return-a-file" class="md-nav__link">
    What if I just want to return a file?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#what-if-i-want-to-directly-emit-output" class="md-nav__link">
    What if I want to directly emit output?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#what-if-i-want-to-use-an-iterator-for-content" class="md-nav__link">
    What if I want to use an iterator for content?
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-are-streams-mutable" class="md-nav__link">
    Why are streams mutable?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rationale-for-serverrequestinterface" class="md-nav__link">
    Rationale for ServerRequestInterface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-parsed-body-in-the-serverrequestinterface" class="md-nav__link">
    Why "parsed body" in the ServerRequestInterface?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-is-no-functionality-included-for-retrieving-the-base-path" class="md-nav__link">
    Why is no functionality included for retrieving the "base path"?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-does-getuploadedfiles-return-objects-instead-of-arrays" class="md-nav__link">
    Why does getUploadedFiles() return objects instead of arrays?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#what-about-special-header-values" class="md-nav__link">
    What about "special" header values?
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-people" class="md-nav__link">
    6. People
  </a>
  
    <nav class="md-nav" aria-label="6. People">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-editors" class="md-nav__link">
    6.1 Editor(s)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-sponsors" class="md-nav__link">
    6.2 Sponsors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-contributors" class="md-nav__link">
    6.3 Contributors
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="http-">Метадокумент HTTP-сообщений</h1>
<h2 id="1">1. Краткое содержание</h2>
<p>Целью этого предложения является предоставление набора общих интерфейсов для HTTP-сообщений, как описано в <a href="http://tools.ietf.org/html/rfc7230">RFC 7230</a> и <a href="http://tools. ietf.org/html/rfc7231">RFC 7231</a> и URI, как описано в <a href="http://tools.ietf.org/html/rfc3986">RFC 3986</a> (в контексте HTTP-сообщений).</p>
<ul>
<li>RFC 7230: http://www.ietf.org/rfc/rfc7230.txt</li>
<li>RFC 7231: http://www.ietf.org/rfc/rfc7231.txt</li>
<li>RFC 3986: http://www.ietf.org/rfc/rfc3986.txt</li>
</ul>
<p>Все сообщения HTTP состоят из используемой версии протокола HTTP, заголовков и тела сообщения. <em>Request</em> основывается на сообщении и включает метод HTTP, использованный для выполнения запроса, и URI, к которому выполняется запрос. <em>Ответ</em> включает код состояния HTTP и фразу причины.</p>
<p>В PHP сообщения HTTP используются в двух контекстах:</p>
<ul>
<li>Чтобы отправить HTTP-запрос через расширение <code>ext/curl</code>, собственный уровень потока PHP и т. д. и обработать полученный HTTP-ответ. Другими словами, HTTP-сообщения используются при использовании PHP в качестве <em>HTTP-клиента</em>.</li>
<li>Для обработки входящего HTTP-запроса на сервер и возврата HTTP-ответа клиенту, сделавшему запрос. PHP может использовать HTTP-сообщения при использовании в качестве «серверного приложения» для выполнения HTTP-запросов.</li>
</ul>
<p>В этом предложении представлен API для полного описания всех частей различных HTTP-сообщений в PHP.</p>
<h2 id="2-http-php">2. HTTP-сообщения в PHP</h2>
<p>PHP не имеет встроенной поддержки HTTP-сообщений.</p>
<h3 id="http">Поддержка HTTP на стороне клиента</h3>
<p>PHP поддерживает отправку HTTP-запросов с помощью нескольких механизмов:</p>
<ul>
<li><a href="http://php.net/streams">Потоки</a></li>
<li><a href="http://php.net/curl">Клиентская библиотека работы с URL</a></li>
<li><a href="http://php.net/http">ext/http</a> (v2 также пытается обеспечить поддержку на стороне сервера.)</li>
</ul>
<p>Потоки PHP — это наиболее удобный и повсеместный способ отправки HTTP-запросов, но они налагают ряд ограничений в отношении правильной настройки поддержки SSL и предоставляют громоздкий интерфейс для настройки таких вещей, как заголовки. cURL предоставляет полный и расширенный набор функций, но, поскольку он не является расширением по умолчанию, часто отсутствует. Расширение http страдает той же проблемой, что и cURL, а также тем фактом, что у него традиционно гораздо меньше примеров использования.</p>
<p>Большинство современных клиентских библиотек HTTP имеют тенденцию абстрагировать реализацию, чтобы гарантировать, что они могут работать в любой среде, в которой они выполняются, и на любом из вышеперечисленных уровней.</p>
<h3 id="http_1">Поддержка HTTP на стороне сервера</h3>
<p>PHP использует API-интерфейсы сервера (SAPI) для интерпретации входящих HTTP-запросов, маршалирования входных данных и передачи обработки сценариям. Исходный дизайн SAPI отражал [Common Gateway Interface (http://www.w3.org/CGI/), который маршалировал данные запроса и помещал их в переменные среды перед передачей делегирования сценарию; Затем сценарий извлекает данные из переменных среды, чтобы обработать запрос и вернуть ответ.</p>
<p>Конструкция PHP SAPI абстрагирует общие источники входных данных, такие как файлы cookie, аргументы строки запроса и содержимое POST в кодировке URL-адреса, через суперглобальные переменные ($_COOKIE<code>,</code>$_GET<code>и</code>$_POST` соответственно), обеспечивая уровень удобства для веб-сайтов. Разработчики.</p>
<p>Что касается ответа на уравнение, PHP изначально разрабатывался как язык шаблонов и позволяет смешивать HTML и PHP; любые части HTML файла немедленно сбрасываются в выходной буфер. Современные приложения и платформы избегают этой практики, поскольку это может привести к проблемам с отправкой строки состояния и/или заголовков ответа; они имеют тенденцию объединять все заголовки и содержимое и выдавать их сразу после завершения всей остальной обработки приложения. Особое внимание необходимо уделять тому, чтобы отчеты об ошибках и другие действия, отправляющие содержимое в выходной буфер, не очищали выходной буфер.</p>
<h2 id="3">3. Зачем?</h2>
<p>Сообщения HTTP используются во многих проектах PHP — как на клиентах, так и на серверах. В каждом случае мы наблюдаем одну или несколько из следующих закономерностей или ситуаций:</p>
<ol>
<li>Проекты напрямую используют суперглобальные переменные PHP.</li>
<li>Проекты будут создавать реализации с нуля.</li>
<li>Для проектов может потребоваться определенная клиент-серверная библиотека HTTP, обеспечивающая реализацию HTTP-сообщений.</li>
<li>Проекты могут создавать адаптеры для распространенных реализаций HTTP-сообщений.</li>
</ol>
<p>В качестве примеров:</p>
<ol>
<li>Практически любое приложение, разработка которого началась до появления фреймворков, включая ряд очень популярных систем CMS, форумов и корзин покупок, исторически использовало суперглобальные переменные.</li>
<li>Каждый из таких фреймворков, как Symfony и Zend Framework, определяет компоненты HTTP, которые составляют основу их уровней MVC; даже небольшие специализированные библиотеки, такие как oauth2-server-php, предоставляют и требуют своих собственных реализаций HTTP-запросов/ответов. Guzzle, Buzz и другие реализации HTTP-клиентов также создают свои собственные реализации HTTP-сообщений.</li>
<li>Такие проекты, как Silex, Stack и Drupal 8, жестко зависят от HTTP-ядра Symfony. Любой SDK, созданный на Guzzle, имеет жесткие требования к реализации HTTP-сообщений Guzzle.</li>
<li>Такие проекты, как Geocoder, создают избыточные <a href="https://github.com/geocoder-php/Geocoder/tree/6a729c6869f55ad55ae641c74ac9ce7731635e6e/src/Geocoder/HttpAdapter">адаптеры для общих библиотек</a>.</li>
</ol>
<p>Прямое использование суперглобальных переменных вызывает ряд проблем. Во-первых, они изменяемы, что позволяет библиотекам и коду изменять значения и, таким образом, изменять состояние приложения. Кроме того, суперглобальные переменные усложняют и делают интеграционное тестирование сложным и хрупким, что приводит к ухудшению качества кода.</p>
<p>В нынешней экосистеме фреймворков, реализующих абстракции HTTP-сообщений, конечным результатом является то, что проекты не способны к взаимодействию или перекрестному опылению. Чтобы использовать код, предназначенный для одной платформы, из другой, первым делом необходимо построить мостовой уровень между реализациями HTTP-сообщений. На стороне клиента, если в конкретной библиотеке нет адаптера, который вы могли бы использовать, вам необходимо соединить пары запрос/ответ, если вы хотите использовать адаптер из другой библиотеки.</p>
<p>Наконец, когда дело доходит до ответов на стороне сервера, PHP действует по-своему: любой контент, созданный до вызова <code>header()</code>, приведет к тому, что этот вызов станет неактивным; в зависимости от настроек отчетов об ошибках это часто может означать, что заголовки и/или статус ответа отправляются неправильно. Один из способов обойти эту проблему — использовать функции буферизации вывода PHP, но вложение выходных буферов может стать проблематичным и затруднить отладку. Таким образом, фреймворки и приложения имеют тенденцию создавать абстракции ответов для агрегирования заголовков и контента, которые могут быть отправлены одновременно, и эти абстракции часто несовместимы.</p>
<p>Таким образом, цель этого предложения — абстрагировать интерфейсы запросов и ответов как на стороне клиента, так и на стороне сервера, чтобы обеспечить совместимость между проектами. Если проекты реализуют эти интерфейсы, можно предположить разумный уровень совместимости при использовании кода из разных библиотек.</p>
<p>Следует отметить, что целью этого предложения не является устаревание текущих интерфейсов, используемых существующими библиотеками PHP. Это предложение направлено на обеспечение совместимости между пакетами PHP с целью описания HTTP-сообщений.</p>
<h2 id="4">4. Суть</h2>
<h3 id="41">4.1 Цели</h3>
<ul>
<li>Предоставить интерфейсы, необходимые для описания HTTP-сообщений.</li>
<li>Сосредоточьтесь на практическом применении и удобстве использования.</li>
<li>Определите интерфейсы для моделирования всех элементов HTTP-сообщения и спецификаций URI.</li>
<li>Убедитесь, что API не накладывает произвольные ограничения на HTTP-сообщения. Например, некоторые тела HTTP-сообщений могут быть слишком большими для хранения в памяти, поэтому мы должны это учитывать.</li>
<li>Предоставляйте полезные абстракции как для обработки входящих запросов к серверным приложениям, так и для отправки исходящих запросов в HTTP-клиентах.</li>
</ul>
<h3 id="42">4.2 Не является целью</h3>
<ul>
<li>Это предложение не предполагает использования всех клиентских HTTP-библиотек или серверных библиотек.
  фреймворки, чтобы изменить их интерфейсы в соответствии с ними. Это строго предназначено для совместимости.</li>
<li>Хотя восприятие того, что является деталями реализации, а что нет, у каждого разное, это предложение не должно навязывать детали реализации. Поскольку RFC 7230, 7231 и 3986 не требуют какой-либо конкретной реализации, потребуется определенное количество изобретений для описания интерфейсов сообщений HTTP в PHP.</li>
</ul>
<h2 id="5">5. Дизайнерские решения</h2>
<h3 id="_1">Дизайн сообщения</h3>
<p>MessageInterface предоставляет средства доступа к элементам, общим для всех HTTP-сообщений, независимо от того, предназначены ли они для запросов или ответов. Эти элементы включают в себя:</p>
<ul>
<li>Версия протокола HTTP (например, «1.0», «1.1»)</li>
<li>HTTP-заголовки</li>
<li>Тело HTTP-сообщения</li>
</ul>
<p>Для описания запросов и ответов используются более конкретные интерфейсы, а точнее контекст каждого из них (клиентская или серверная сторона). Эти подразделения частично вдохновлены существующим использованием PHP, а также другими языками, такими как [Rack] Ruby (https://rack.github.io),
Python <a href="https://www.python.org/dev/peps/pep-0333/">WSGI</a>,
[http-пакет] Go(http://golang.org/pkg/net/http/),
[http-модуль] узла (http://nodejs.org/api/http.html) и т. д.</p>
<h3 id="_2">Почему в сообщениях есть методы заголовков, а не в пакете заголовков?</h3>
<p>Само сообщение является контейнером для заголовков (а также других свойств сообщения). То, как они представлены внутри, является деталью реализации, но единообразный доступ к заголовкам является обязанностью сообщения.</p>
<h3 id="uri">Почему URI представлены как объекты?</h3>
<p>URI — это значения, идентичность которых определяется значением, и поэтому их следует моделировать как объекты значений.</p>
<p>Кроме того, URI содержат множество сегментов, к которым можно обращаться много раз в одном запросе, и для определения которых потребуется анализ URI (например, с помощью <code>parse_url()</code>). Моделирование URI как объектов значений позволяет выполнять синтаксический анализ только один раз и упрощает доступ к отдельным сегментам. Это также обеспечивает удобство в клиентских приложениях, позволяя пользователям создавать новые экземпляры базового экземпляра URI только с изменяющимися сегментами (например, обновляя только путь).</p>
<h3 id="uri_1">Почему в интерфейсе запроса есть методы для работы с целью запроса И создания URI?</h3>
<p>В RFC 7230 строка запроса подробно описана как содержащая «цель запроса». Из четырех форм запроса-цели только одна является URI, соответствующей RFC 3986; наиболее распространенной формой является origin-form, которая представляет URI без схемы или информации о полномочиях. Более того, поскольку все формы действительны для запросов, предложение должно учитывать каждую из них.</p>
<p>Таким образом, <code>RequestInterface</code> имеет методы, относящиеся к цели запроса. По умолчанию он будет использовать составной URI для представления цели запроса в исходной форме и, при отсутствии экземпляра URI, возвращать строку «/». Другой метод, withRequestTarget(), позволяет указать экземпляр с определенной целью запроса, позволяя пользователям создавать запросы, использующие одну из других допустимых форм цели запроса.</p>
<p>URI сохраняется как отдельный элемент запроса по ряду причин. Как для клиентов, так и для серверов обычно требуется знание абсолютного URI. В случае клиентов URI и, в частности, сведения о схеме и полномочиях необходимы для фактического TCP-соединения. Для серверных приложений полный URI часто требуется для проверки запроса или маршрутизации к соответствующему обработчику.</p>
<h3 id="_3">Почему Объекты Значения?</h3>
<p>В предложении сообщения и URI моделируются как <a href="http://en.wikipedia.org/wiki/Value_object">объекты значений</a>.</p>
<p>Сообщения — это значения, где идентификатор — это совокупность всех частей сообщения; изменение любого аспекта сообщения по сути является новым сообщением.
Это само определение объекта значения. Практика, при которой изменения приводят к созданию нового экземпляра, называется <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D0%B9_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82">неизменяемостью</a> и представляет собой функцию, предназначенную для обеспечения целостности данного значения.</p>
<p>В предложении также признается, что большинству клиентов и серверных приложений потребуется возможность легко обновлять аспекты сообщений, и поэтому предоставляются методы интерфейса, которые будут создавать новые экземпляры сообщений с обновлениями. Обычно к ним добавляются префиксы «с» или «без».</p>
<p>Объекты-значения предоставляют несколько преимуществ при моделировании HTTP-сообщений:</p>
<ul>
<li>Изменения в состоянии URI не могут изменить запрос, составляющий экземпляр URI.</li>
<li>Изменения в заголовках не могут изменить составляющее их сообщение.</li>
</ul>
<p>По сути, моделирование HTTP-сообщений как объектов значений обеспечивает целостность состояния сообщения и предотвращает необходимость двунаправленных зависимостей, которые часто могут выйти из синхронизации или привести к проблемам отладки или производительности.</p>
<p>Для HTTP-клиентов они позволяют потребителям создавать базовый запрос с такими данными, как базовый URI и необходимые заголовки, без необходимости создавать новый запрос или сбрасывать состояние запроса для каждого сообщения, отправляемого клиентом:</p>
<pre><code class="language-php">$uri = new Uri('http://api.example.com');
$baseRequest = new Request($uri, null, [
    'Authorization' =&gt; 'Bearer ' . $token,
    'Accept'        =&gt; 'application/json',
]);

$request = $baseRequest-&gt;withUri($uri-&gt;withPath('/user'))-&gt;withMethod('GET');
$response = $client-&gt;send($request);

// получаем идентификатор пользователя из $response

$body = new StringStream(json_encode(['tasks' =&gt; [
    'Code',
    'Coffee',
]]));
$request = $baseRequest
    -&gt;withUri($uri-&gt;withPath('/tasks/user/' . $userId))
    -&gt;withMethod('POST')
    -&gt;withHeader('Content-Type', 'application/json')
    -&gt;withBody($body);
$response = $client-&gt;send($request)

// Не нужно перезаписывать заголовки или тело!
$request = $baseRequest-&gt;withUri($uri-&gt;withPath('/tasks'))-&gt;withMethod('GET');
$response = $client-&gt;send($request);
</code></pre>
<p>На стороне сервера разработчикам необходимо:</p>
<ul>
<li>Десериализовать тело сообщения запроса.</li>
<li>Расшифровать файлы cookie HTTP.</li>
<li>Напишите в ответ.</li>
</ul>
<p>Эти операции также можно выполнять с объектами-значениями, что дает ряд преимуществ:</p>
<ul>
<li>Исходное состояние запроса может быть сохранено для извлечения любым потребителем.</li>
<li>Состояние ответа по умолчанию может быть создано с использованием заголовков и/или тела сообщения по умолчанию.</li>
</ul>
<p>Сегодня большинство популярных PHP-фреймворков имеют полностью изменяемые HTTP-сообщения. Основные изменения, необходимые для использования объектов истинной ценности:</p>
<ul>
<li>Вместо вызова методов установки или установки общедоступных свойств, мутатор
  Будут вызываться методы и присваиваться результат.</li>
<li>Разработчики должны уведомить приложение об изменении состояния.</li>
</ul>
<p>Например, в Zend Framework 2 вместо следующего:</p>
<pre><code class="language-php">function (MvcEvent $e)
{
    $response = $e-&gt;getResponse();
    $response-&gt;setHeaderLine('x-foo', 'bar');
}
</code></pre>
<p>сейчас бы написали:</p>
<pre><code class="language-php">function (MvcEvent $e)
{
    $response = $e-&gt;getResponse();
    $e-&gt;setResponse(
        $response-&gt;withHeader('x-foo', 'bar')
    );
}
</code></pre>
<p>Вышеупомянутое объединяет назначение и уведомление в одном вызове.</p>
<p>Побочным преимуществом этой практики является возможность явного внесения любых изменений в состояние приложения.</p>
<h3 id="vs-this">Новые экземпляры vs возврат $this</h3>
<p>Одно наблюдение, сделанное в отношении различных методов <code>with*()</code>, заключается в том, что они, вероятно, могут безопасно <code>вернуть $this;</code>, если представленный аргумент не приведет к изменению значения. Одним из оснований для этого является производительность (поскольку это не приведет к операции клонирования).</p>
<p>Различные интерфейсы были написаны с многословием, указывающим, что неизменность ДОЛЖНА быть сохранена, но указывают только на то, что должен быть возвращен «экземпляр», содержащий новое состояние. Поскольку экземпляры, представляющие одно и то же значение, считаются равными, возврат $this функционально эквивалентен и, следовательно, разрешен.</p>
<h3 id="x">Использование потоков вместо X</h3>
<p><code>MessageInterface</code> uses a body value that must implement <code>StreamInterface</code>. This
design decision was made so that developers can send and receive (and/or receive
and send) HTTP messages that contain more data than can practically be stored in
memory while still allowing the convenience of interacting with message bodies
as a string. While PHP provides a stream abstraction by way of stream wrappers,
stream resources can be cumbersome to work with: stream resources can only be
cast to a string using <code>stream_get_contents()</code> or manually reading the remainder
of a string. Adding custom behavior to a stream as it is consumed or populated
requires registering a stream filter; however, stream filters can only be added
to a stream after the filter is registered with PHP (i.e., there is no stream
filter autoloading mechanism).</p>
<p>The use of a well- defined stream interface allows for the potential of
flexible stream decorators that can be added to a request or response
pre-flight to enable things like encryption, compression, ensuring that the
number of bytes downloaded reflects the number of bytes reported in the
<code>Content-Length</code> of a response, etc. Decorating streams is a well-established
<a href="http://docs.oracle.com/javase/7/docs/api/java/io/package-tree.html">pattern in the Java</a>
and <a href="http://nodejs.org/api/stream.html#stream_class_stream_transform_1">Node</a>
communities that allows for very flexible streams.</p>
<p>The majority of the <code>StreamInterface</code> API is based on
<a href="http://docs.python.org/3.1/library/io.html">Python's io module</a>, which provides
a practical and consumable API. Instead of implementing stream
capabilities using something like a <code>WritableStreamInterface</code> and
<code>ReadableStreamInterface</code>, the capabilities of a stream are provided by methods
like <code>isReadable()</code>, <code>isWritable()</code>, etc. This approach is used by Python,
<a href="http://msdn.microsoft.com/en-us/library/system.io.stream.aspx">C#, C++</a>,
<a href="http://www.ruby-doc.org/core-2.0.0/IO.html">Ruby</a>,
<a href="http://nodejs.org/api/stream.html">Node</a>, and likely others.</p>
<h4 id="what-if-i-just-want-to-return-a-file">What if I just want to return a file?</h4>
<p>In some cases, you may want to return a file from the filesystem. The typical
way to do this in PHP is one of the following:</p>
<pre><code class="language-php">readfile($filename);

stream_copy_to_stream(fopen($filename, 'r'), fopen('php://output', 'w'));
</code></pre>
<p>Note that the above omits sending appropriate <code>Content-Type</code> and
<code>Content-Length</code> headers; the developer would need to emit these prior to
calling the above code.</p>
<p>The equivalent using HTTP messages would be to use a <code>StreamInterface</code>
implementation that accepts a filename and/or stream resource, and to provide
this to the response instance. A complete example, including setting appropriate
headers:</p>
<pre><code class="language-php">// where Stream is a concrete StreamInterface:
$stream   = new Stream($filename);
$finfo    = new finfo(FILEINFO_MIME);
$response = $response
    -&gt;withHeader('Content-Type', $finfo-&gt;file($filename))
    -&gt;withHeader('Content-Length', (string) filesize($filename))
    -&gt;withBody($stream);
</code></pre>
<p>Emitting this response will send the file to the client.</p>
<h4 id="what-if-i-want-to-directly-emit-output">What if I want to directly emit output?</h4>
<p>Directly emitting output (e.g. via <code>echo</code>, <code>printf</code>, or writing to the
<code>php://output</code> stream) is generally only advisable as a performance optimization
or when emitting large data sets. If it needs to be done and you still wish
to work in an HTTP message paradigm, one approach would be to use a
callback-based <code>StreamInterface</code> implementation, per <a href="https://github.com/phly/psr7examples#direct-output">this
example</a>. Wrap any code
emitting output directly in a callback, pass that to an appropriate
<code>StreamInterface</code> implementation, and provide it to the message body:</p>
<pre><code class="language-php">$output = new CallbackStream(function () use ($request) {
    printf(&quot;The requested URI was: %s&lt;br&gt;\n&quot;, $request-&gt;getUri());
    return '';
});
return (new Response())
    -&gt;withHeader('Content-Type', 'text/html')
    -&gt;withBody($output);
</code></pre>
<h4 id="what-if-i-want-to-use-an-iterator-for-content">What if I want to use an iterator for content?</h4>
<p>Ruby's Rack implementation uses an iterator-based approach for server-side
response message bodies. This can be emulated using an HTTP message paradigm via
an iterator-backed <code>StreamInterface</code> approach, as <a href="https://github.com/phly/psr7examples#iterators-and-generators">detailed in the
psr7examples repository</a>.</p>
<h3 id="why-are-streams-mutable">Why are streams mutable?</h3>
<p>The <code>StreamInterface</code> API includes methods such as <code>write()</code> which can
change the message content -- which directly contradicts having immutable
messages.</p>
<p>The problem that arises is due to the fact that the interface is intended to
wrap a PHP stream or similar. A write operation therefore will proxy to writing
to the stream. Even if we made <code>StreamInterface</code> immutable, once the stream
has been updated, any instance that wraps that stream will also be updated --
making immutability impossible to enforce.</p>
<p>Our recommendation is that implementations use read-only streams for
server-side requests and client-side responses.</p>
<h3 id="rationale-for-serverrequestinterface">Rationale for ServerRequestInterface</h3>
<p>The <code>RequestInterface</code> and <code>ResponseInterface</code> have essentially 1:1
correlations with the request and response messages described in
<a href="http://www.ietf.org/rfc/rfc7230.txt">RFC 7230</a>. They provide interfaces for
implementing value objects that correspond to the specific HTTP message types
they model.</p>
<p>For server-side applications there are other considerations for
incoming requests:</p>
<ul>
<li>Access to server parameters (potentially derived from the request, but also
  potentially the result of server configuration, and generally represented
  via the <code>$_SERVER</code> superglobal; these are part of the PHP Server API (SAPI)).</li>
<li>Access to the query string arguments (usually encapsulated in PHP via the
  <code>$_GET</code> superglobal).</li>
<li>Access to the parsed body (i.e., data deserialized from the incoming request
  body; in PHP, this is typically the result of POST requests using
  <code>application/x-www-form-urlencoded</code> content types, and encapsulated in the
  <code>$_POST</code> superglobal, but for non-POST, non-form-encoded data, could be
  an array or an object).</li>
<li>Access to uploaded files (encapsulated in PHP via the <code>$_FILES</code> superglobal).</li>
<li>Access to cookie values (encapsulated in PHP via the <code>$_COOKIE</code> superglobal).</li>
<li>Access to attributes derived from the request (usually, but not limited to,
  those matched against the URL path).</li>
</ul>
<p>Uniform access to these parameters increases the viability of interoperability
between frameworks and libraries, as they can now assume that if a request
implements <code>ServerRequestInterface</code>, they can get at these values. It also
solves problems within the PHP language itself:</p>
<ul>
<li>Until 5.6.0, <code>php://input</code> was read-once; as such, instantiating multiple
  request instances from multiple frameworks/libraries could lead to
  inconsistent state, as the first to access <code>php://input</code> would be the only
  one to receive the data.</li>
<li>Unit testing against superglobals (e.g., <code>$_GET</code>, <code>$_FILES</code>, etc.) is
  difficult and typically brittle. Encapsulating them inside the
  <code>ServerRequestInterface</code> implementation eases testing considerations.</li>
</ul>
<h3 id="why-parsed-body-in-the-serverrequestinterface">Why "parsed body" in the ServerRequestInterface?</h3>
<p>Arguments were made to use the terminology "BodyParams", and require the value
to be an array, with the following rationale:</p>
<ul>
<li>Consistency with other server-side parameter access.</li>
<li><code>$_POST</code> is an array, and the 80% use case would target that superglobal.</li>
<li>A single type makes for a strong contract, simplifying usage.</li>
</ul>
<p>The main argument is that if the body parameters are an array, developers have
predictable access to values:</p>
<pre><code class="language-php">$foo = isset($request-&gt;getBodyParams()['foo'])
    ? $request-&gt;getBodyParams()['foo']
    : null;
</code></pre>
<p>The argument for using "parsed body" was made by examining the domain. A message
body can contain literally anything. While traditional web applications use
forms and submit data using POST, this is a use case that is quickly being
challenged in current web development trends, which are often API-centric, and
thus use alternate request methods (notably PUT and PATCH), as well as
non-form-encoded content (generally JSON or XML) that <em>can</em> be coerced to arrays
in many cases, but in many cases also <em>cannot</em> or <em>should not</em>.</p>
<p>If forcing the property representing the parsed body to be only an array,
developers then need a shared convention about where to put the results of
parsing the body. These might include:</p>
<ul>
<li>A special key under the body parameters, such as <code>__parsed__</code>.</li>
<li>A specially named attribute, such as <code>__body__</code>.</li>
</ul>
<p>The end result is that a developer now has to look in multiple locations:</p>
<pre><code class="language-php">$data = $request-&gt;getBodyParams();
if (isset($data['__parsed__']) &amp;&amp; is_object($data['__parsed__'])) {
    $data = $data['__parsed__'];
}

// or:
$data = $request-&gt;getBodyParams();
if ($request-&gt;hasAttribute('__body__')) {
    $data = $request-&gt;getAttribute('__body__');
}
</code></pre>
<p>The solution presented is to use the terminology "ParsedBody", which implies
that the values are the results of parsing the message body. This also means
that the return value <em>will</em> be ambiguous; however, because this is an attribute
of the domain, this is also expected. As such, usage will become:</p>
<pre><code class="language-php">$data = $request-&gt;getParsedBody();
if (! $data instanceof \stdClass) {
    // raise an exception!
}
// otherwise, we have what we expected
</code></pre>
<p>This approach removes the limitations of forcing an array, at the expense of
ambiguity of return value. Considering that the other suggested solutions —
pushing the parsed data into a special body parameter key or into an attribute —
also suffer from ambiguity, the proposed solution is simpler as it does not
require additions to the interface specification. Ultimately, the ambiguity
enables the flexibility required when representing the results of parsing the
body.</p>
<h3 id="why-is-no-functionality-included-for-retrieving-the-base-path">Why is no functionality included for retrieving the "base path"?</h3>
<p>Many frameworks provide the ability to get the "base path," usually considered
the path up to and including the front controller. As an example, if the
application is served at <code>http://example.com/b2b/index.php</code>, and the current URI
used to request it is <code>http://example.com/b2b/index.php/customer/register</code>, the
functionality to retrieve the base path would return <code>/b2b/index.php</code>. This value
can then be used by routers to strip that path segment prior to attempting a
match.</p>
<p>This value is often also then used for URI generation within applications;
parameters will be passed to the router, which will generate the path, and
prefix it with the base path in order to return a fully-qualified URI. Other
tools — typically view helpers, template filters, or template functions — are
used to resolve a path relative to the base path in order to generate a URI for
linking to resources such as static assets.</p>
<p>On examination of several different implementations, we noticed the following:</p>
<ul>
<li>The logic for determining the base path varies widely between implementations.
  As an example, compare the <a href="https://github.com/zendframework/zf2/blob/release-2.3.7/library/Zend/Http/PhpEnvironment/Request.php#L477-L575">logic in ZF2</a>
  to the <a href="https://github.com/symfony/symfony/blob/2.7/src/Symfony/Component/HttpFoundation/Request.php#L1858-L1877">logic in Symfony 2</a>.</li>
<li>Most implementations appear to allow manual injection of a base path to the
  router and/or any facilities used for URI generation.</li>
<li>The primary use cases — routing and URI generation — typically are the only
  consumers of the functionality; developers usually do not need to be aware
  of the base path concept as other objects take care of that detail for them.
  As examples:</li>
<li>A router will strip off the base path for you during routing; you do not
    need to pass the modified path to the router.</li>
<li>View helpers, template filters, etc. typically are injected with a base path
    prior to invocation. Sometimes this is manually done, though more often it
    is the result of framework wiring.</li>
<li>All sources necessary for calculating the base path <em>are already in the
  <code>RequestInterface</code> instance</em>, via server parameters and the URI instance.</li>
</ul>
<p>Our stance is that base path detection is framework and/or application
specific, and the results of detection can be easily injected into objects that
need it, and/or calculated as needed using utility functions and/or classes from
the <code>RequestInterface</code> instance itself.</p>
<h3 id="why-does-getuploadedfiles-return-objects-instead-of-arrays">Why does getUploadedFiles() return objects instead of arrays?</h3>
<p><code>getUploadedFiles()</code> returns a tree of <code>Psr\Http\Message\UploadedFileInterface</code>
instances. This is done primarily to simplify specification: instead of
requiring paragraphs of implementation specification for an array, we specify an
interface.</p>
<p>Additionally, the data in an <code>UploadedFileInterface</code> is normalized to work in
both SAPI and non-SAPI environments. This allows the creation of processes to parse
the message body manually and assign contents to streams without first writing
to the filesystem, while still allowing proper handling of file uploads in SAPI
environments.</p>
<h3 id="what-about-special-header-values">What about "special" header values?</h3>
<p>A number of header values contain unique representation requirements which can
pose problems both for consumption as well as generation; in particular, cookies
and the <code>Accept</code> header.</p>
<p>This proposal does not provide any special treatment of any header types. The
base <code>MessageInterface</code> provides methods for header retrieval and setting, and
all header values are, in the end, string values.</p>
<p>Developers are encouraged to write commodity libraries for interacting with
these header values, either for the purposes of parsing or generation. Users may
then consume these libraries when needing to interact with those values.
Examples of this practice already exist in libraries such as
<a href="https://github.com/willdurand/Negotiation">willdurand/Negotiation</a> and
<a href="https://github.com/auraphp/Aura.Accept">Aura.Accept</a>. So long as the object
has functionality for casting the value to a string, these objects can be
used to populate the headers of an HTTP message.</p>
<h2 id="6-people">6. People</h2>
<h3 id="61-editors">6.1 Editor(s)</h3>
<ul>
<li>Matthew Weier O'Phinney</li>
</ul>
<h3 id="62-sponsors">6.2 Sponsors</h3>
<ul>
<li>Paul M. Jones</li>
<li>Beau Simensen (coordinator)</li>
</ul>
<h3 id="63-contributors">6.3 Contributors</h3>
<ul>
<li>Michael Dowling</li>
<li>Larry Garfield</li>
<li>Evert Pot</li>
<li>Tobias Schultze</li>
<li>Bernhard Schussek</li>
<li>Anton Serdyuk</li>
<li>Phil Sturgeon</li>
<li>Chris Wilkinson</li>
</ul>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.fac441b0.min.js"></script>
      
        <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
      
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
      
        <script src="../../js/init.js"></script>
      
    
  </body>
</html>