
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.11">
    
    
      
        <title>HTTP Message Meta Document - Стандартизированные рекомендации PHP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.85bb2934.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#http-message-meta-document" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Стандартизированные рекомендации PHP" class="md-header__button md-logo" aria-label="Стандартизированные рекомендации PHP" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Стандартизированные рекомендации PHP
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              HTTP Message Meta Document
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Стандартизированные рекомендации PHP" class="md-nav__button md-logo" aria-label="Стандартизированные рекомендации PHP" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Стандартизированные рекомендации PHP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Стандартизированные рекомендации PHP
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-0/" class="md-nav__link">
        Стандарт автозагрузки PSR-0 (Устарело)
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-1-basic-coding-standard/" class="md-nav__link">
        Основной стандарт кодирования PSR-1
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-2-coding-style-guide/" class="md-nav__link">
        Руководство по стилю кодирования PSR-2
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-3-logger-interface/" class="md-nav__link">
        Общий интерфейс логирования PSR-3
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-4-autoloader/" class="md-nav__link">
        Стандарт автозагрузки PSR-4
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../proposed/phpdoc/" class="md-nav__link">
        PHPDoc PSR-5
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-6-cache/" class="md-nav__link">
        Общий интерфейс кэширования PSR-6
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-7-http-message/" class="md-nav__link">
        Интерфейсы HTTP-сообщений PSR-7
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../PSR-12-extended-coding-style-guide/" class="md-nav__link">
        Расширенное руководство по стилю кодирования PSR-12
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../proposed/phpdoc-tags/" class="md-nav__link">
        Теги PHPDoc PSR-19
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../LICENSE/" class="md-nav__link">
        Лицензия
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-summary" class="md-nav__link">
    1. Summary
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-http-messages-in-php" class="md-nav__link">
    2. HTTP Messages in PHP
  </a>
  
    <nav class="md-nav" aria-label="2. HTTP Messages in PHP">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#client-side-http-support" class="md-nav__link">
    Client-side HTTP support
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#server-side-http-support" class="md-nav__link">
    Server-side HTTP Support
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-why-bother" class="md-nav__link">
    3. Why Bother?
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-scope" class="md-nav__link">
    4. Scope
  </a>
  
    <nav class="md-nav" aria-label="4. Scope">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-goals" class="md-nav__link">
    4.1 Goals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-non-goals" class="md-nav__link">
    4.2 Non-Goals
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-design-decisions" class="md-nav__link">
    5. Design Decisions
  </a>
  
    <nav class="md-nav" aria-label="5. Design Decisions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#message-design" class="md-nav__link">
    Message design
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-are-there-header-methods-on-messages-rather-than-in-a-header-bag" class="md-nav__link">
    Why are there header methods on messages rather than in a header bag?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-are-uris-represented-as-objects" class="md-nav__link">
    Why are URIs represented as objects?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-does-the-request-interface-have-methods-for-dealing-with-the-request-target-and-compose-a-uri" class="md-nav__link">
    Why does the request interface have methods for dealing with the request-target AND compose a URI?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-value-objects" class="md-nav__link">
    Why value objects?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#new-instances-vs-returning-this" class="md-nav__link">
    New instances vs returning $this
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-streams-instead-of-x" class="md-nav__link">
    Using streams instead of X
  </a>
  
    <nav class="md-nav" aria-label="Using streams instead of X">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#what-if-i-just-want-to-return-a-file" class="md-nav__link">
    What if I just want to return a file?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#what-if-i-want-to-directly-emit-output" class="md-nav__link">
    What if I want to directly emit output?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#what-if-i-want-to-use-an-iterator-for-content" class="md-nav__link">
    What if I want to use an iterator for content?
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-are-streams-mutable" class="md-nav__link">
    Why are streams mutable?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rationale-for-serverrequestinterface" class="md-nav__link">
    Rationale for ServerRequestInterface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-parsed-body-in-the-serverrequestinterface" class="md-nav__link">
    Why "parsed body" in the ServerRequestInterface?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-is-no-functionality-included-for-retrieving-the-base-path" class="md-nav__link">
    Why is no functionality included for retrieving the "base path"?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#why-does-getuploadedfiles-return-objects-instead-of-arrays" class="md-nav__link">
    Why does getUploadedFiles() return objects instead of arrays?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#what-about-special-header-values" class="md-nav__link">
    What about "special" header values?
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-people" class="md-nav__link">
    6. People
  </a>
  
    <nav class="md-nav" aria-label="6. People">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-editors" class="md-nav__link">
    6.1 Editor(s)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-sponsors" class="md-nav__link">
    6.2 Sponsors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-contributors" class="md-nav__link">
    6.3 Contributors
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="http-message-meta-document">HTTP Message Meta Document</h1>
<h2 id="1-summary">1. Summary</h2>
<p>The purpose of this proposal is to provide a set of common interfaces for HTTP
messages as described in <a href="http://tools.ietf.org/html/rfc7230">RFC 7230</a> and
<a href="http://tools.ietf.org/html/rfc7231">RFC 7231</a>, and URIs as described in
<a href="http://tools.ietf.org/html/rfc3986">RFC 3986</a> (in the context of HTTP messages).</p>
<ul>
<li>RFC 7230: http://www.ietf.org/rfc/rfc7230.txt</li>
<li>RFC 7231: http://www.ietf.org/rfc/rfc7231.txt</li>
<li>RFC 3986: http://www.ietf.org/rfc/rfc3986.txt</li>
</ul>
<p>All HTTP messages consist of the HTTP protocol version being used, headers, and
a message body. A <em>Request</em> builds on the message to include the HTTP method
used to make the request, and the URI to which the request is made. A
<em>Response</em> includes the HTTP status code and reason phrase.</p>
<p>In PHP, HTTP messages are used in two contexts:</p>
<ul>
<li>To send an HTTP request, via the <code>ext/curl</code> extension, PHP's native stream
  layer, etc., and process the received HTTP response. In other words, HTTP
  messages are used when using PHP as an <em>HTTP client</em>.</li>
<li>To process an incoming HTTP request to the server, and return an HTTP response
  to the client making the request. PHP can use HTTP messages when used as a
  <em>server-side application</em> to fulfill HTTP requests.</li>
</ul>
<p>This proposal presents an API for fully describing all parts of the various
HTTP messages within PHP.</p>
<h2 id="2-http-messages-in-php">2. HTTP Messages in PHP</h2>
<p>PHP does not have built-in support for HTTP messages.</p>
<h3 id="client-side-http-support">Client-side HTTP support</h3>
<p>PHP supports sending HTTP requests via several mechanisms:</p>
<ul>
<li><a href="http://php.net/streams">PHP streams</a></li>
<li>The <a href="http://php.net/curl">cURL extension</a></li>
<li><a href="http://php.net/http">ext/http</a> (v2 also attempts to address server-side support)</li>
</ul>
<p>PHP streams are the most convenient and ubiquitous way to send HTTP requests,
but pose a number of limitations with regards to properly configuring SSL
support, and provide a cumbersome interface around setting things such as
headers. cURL provides a complete and expanded feature-set, but, as it is not a
default extension, is often not present. The http extension suffers from the
same problem as cURL, as well as the fact that it has traditionally had far
fewer examples of usage.</p>
<p>Most modern HTTP client libraries tend to abstract the implementation, to
ensure they can work on whatever environment they are executed on, and across
any of the above layers.</p>
<h3 id="server-side-http-support">Server-side HTTP Support</h3>
<p>PHP uses Server APIs (SAPI) to interpret incoming HTTP requests, marshal input,
and pass off handling to scripts. The original SAPI design mirrored <a href="http://www.w3.org/CGI/">Common
Gateway Interface</a>, which would marshal request data
and push it into environment variables before passing delegation to a script;
the script would then pull from the environment variables in order to process
the request and return a response.</p>
<p>PHP's SAPI design abstracts common input sources such as cookies, query string
arguments, and url-encoded POST content via superglobals (<code>$_COOKIE</code>, <code>$_GET</code>,
and <code>$_POST</code>, respectively), providing a layer of convenience for web developers.</p>
<p>On the response side of the equation, PHP was originally developed as a
templating language, and allows intermixing HTML and PHP; any HTML portions of
a file are immediately flushed to the output buffer. Modern applications and
frameworks eschew this practice, as it can lead to issues with
regards to emitting a status line and/or response headers; they tend to
aggregate all headers and content, and emit them at once when all other
application processing is complete. Special care needs to be paid to ensure
that error reporting and other actions that send content to the output buffer
do not flush the output buffer.</p>
<h2 id="3-why-bother">3. Why Bother?</h2>
<p>HTTP messages are used in a wide number of PHP projects -- both clients and
servers. In each case, we observe one or more of the following patterns or
situations:</p>
<ol>
<li>Projects use PHP's superglobals directly.</li>
<li>Projects will create implementations from scratch.</li>
<li>Projects may require a specific HTTP client/server library that provides
   HTTP message implementations.</li>
<li>Projects may create adapters for common HTTP message implementations.</li>
</ol>
<p>As examples:</p>
<ol>
<li>Just about any application that began development before the rise of
   frameworks, which includes a number of very popular CMS, forum, and shopping
   cart systems, have historically used superglobals.</li>
<li>Frameworks such as Symfony and Zend Framework each define HTTP components
   that form the basis of their MVC layers; even small, single-purpose
   libraries such as oauth2-server-php provide and require their own HTTP
   request/response implementations. Guzzle, Buzz, and other HTTP client
   implementations each create their own HTTP message implementations as well.</li>
<li>Projects such as Silex, Stack, and Drupal 8 have hard dependencies on
   Symfony's HTTP kernel. Any SDK built on Guzzle has a hard requirement on
   Guzzle's HTTP message implementations.</li>
<li>Projects such as Geocoder create redundant <a href="https://github.com/geocoder-php/Geocoder/tree/6a729c6869f55ad55ae641c74ac9ce7731635e6e/src/Geocoder/HttpAdapter">adapters for common
   libraries</a>.</li>
</ol>
<p>Direct usage of superglobals has a number of concerns. First, these are
mutable, which makes it possible for libraries and code to alter the values,
and thus alter state for the application. Additionally, superglobals make unit
and integration testing difficult and brittle, leading to code quality
degradation.</p>
<p>In the current ecosystem of frameworks that implement HTTP message abstractions,
the net result is that projects are not capable of interoperability or
cross-pollination. In order to consume code targeting one framework from
another, the first order of business is building a bridge layer between the
HTTP message implementations. On the client-side, if a particular library does
not have an adapter you can utilize, you need to bridge the request/response
pairs if you wish to use an adapter from another library.</p>
<p>Finally, when it comes to server-side responses, PHP gets in its own way: any
content emitted before a call to <code>header()</code> will result in that call becoming a
no-op; depending on error reporting settings, this can often mean headers
and/or response status are not correctly sent. One way to work around this is
to use PHP's output buffering features, but nesting of output buffers can
become problematic and difficult to debug. Frameworks and applications thus
tend to create response abstractions for aggregating headers and content that
can be emitted at once - and these abstractions are often incompatible.</p>
<p>Thus, the goal of this proposal is to abstract both client- and server-side
request and response interfaces in order to promote interoperability between
projects. If projects implement these interfaces, a reasonable level of
compatibility may be assumed when adopting code from different libraries.</p>
<p>It should be noted that the goal of this proposal is not to obsolete the
current interfaces utilized by existing PHP libraries. This proposal is aimed
at interoperability between PHP packages for the purpose of describing HTTP
messages.</p>
<h2 id="4-scope">4. Scope</h2>
<h3 id="41-goals">4.1 Goals</h3>
<ul>
<li>Provide the interfaces needed for describing HTTP messages.</li>
<li>Focus on practical applications and usability.</li>
<li>Define the interfaces to model all elements of the HTTP message and URI
  specifications.</li>
<li>Ensure that the API does not impose arbitrary limits on HTTP messages. For
  example, some HTTP message bodies can be too large to store in memory, so we
  must account for this.</li>
<li>Provide useful abstractions both for handling incoming requests for
  server-side applications and for sending outgoing requests in HTTP clients.</li>
</ul>
<h3 id="42-non-goals">4.2 Non-Goals</h3>
<ul>
<li>This proposal does not expect all HTTP client libraries or server-side
  frameworks to change their interfaces to conform. It is strictly meant for
  interoperability.</li>
<li>While everyone's perception of what is and is not an implementation detail
  varies, this proposal should not impose implementation details. As
  RFCs 7230, 7231, and 3986 do not force any particular implementation,
  there will be a certain amount of invention needed to describe HTTP message
  interfaces in PHP.</li>
</ul>
<h2 id="5-design-decisions">5. Design Decisions</h2>
<h3 id="message-design">Message design</h3>
<p>The <code>MessageInterface</code> provides accessors for the elements common to all HTTP
messages, whether they are for requests or responses. These elements include:</p>
<ul>
<li>HTTP protocol version (e.g., "1.0", "1.1")</li>
<li>HTTP headers</li>
<li>HTTP message body</li>
</ul>
<p>More specific interfaces are used to describe requests and responses, and more
specifically the context of each (client- vs. server-side). These divisions are
partly inspired by existing PHP usage, but also by other languages such as
Ruby's <a href="https://rack.github.io">Rack</a>,
Python's <a href="https://www.python.org/dev/peps/pep-0333/">WSGI</a>,
Go's <a href="http://golang.org/pkg/net/http/">http package</a>,
Node's <a href="http://nodejs.org/api/http.html">http module</a>, etc.</p>
<h3 id="why-are-there-header-methods-on-messages-rather-than-in-a-header-bag">Why are there header methods on messages rather than in a header bag?</h3>
<p>The message itself is a container for the headers (as well as the other message
properties). How these are represented internally is an implementation detail,
but uniform access to headers is a responsibility of the message.</p>
<h3 id="why-are-uris-represented-as-objects">Why are URIs represented as objects?</h3>
<p>URIs are values, with identity defined by the value, and thus should be modeled
as value objects.</p>
<p>Additionally, URIs contain a variety of segments which may be accessed many
times in a given request -- and which would require parsing the URI in order to
determine (e.g., via <code>parse_url()</code>). Modeling URIs as value objects allows
parsing once only, and simplifies access to individual segments. It also
provides convenience in client applications by allowing users to create new
instances of a base URI instance with only the segments that change (e.g.,
updating the path only).</p>
<h3 id="why-does-the-request-interface-have-methods-for-dealing-with-the-request-target-and-compose-a-uri">Why does the request interface have methods for dealing with the request-target AND compose a URI?</h3>
<p>RFC 7230 details the request line as containing a "request-target". Of the four
forms of request-target, only one is a URI compliant with RFC 3986; the most
common form used is origin-form, which represents the URI without the
scheme or authority information. Moreover, since all forms are valid for
purposes of requests, the proposal must accommodate each.</p>
<p><code>RequestInterface</code> thus has methods relating to the request-target. By default,
it will use the composed URI to present an origin-form request-target, and, in
the absence of a URI instance, return the string "/".  Another method,
<code>withRequestTarget()</code>, allows specifying an instance with a specific
request-target, allowing users to create requests that use one of the other
valid request-target forms.</p>
<p>The URI is kept as a discrete member of the request for a variety of reasons.
For both clients and servers, knowledge of the absolute URI is typically
required. In the case of clients, the URI, and specifically the scheme and
authority details, is needed in order to make the actual TCP connection. For
server-side applications, the full URI is often required in order to validate
the request or to route to an appropriate handler.</p>
<h3 id="why-value-objects">Why value objects?</h3>
<p>The proposal models messages and URIs as <a href="http://en.wikipedia.org/wiki/Value_object">value objects</a>.</p>
<p>Messages are values where the identity is the aggregate of all parts of the
message; a change to any aspect of the message is essentially a new message.
This is the very definition of a value object. The practice by which changes
result in a new instance is termed <a href="http://en.wikipedia.org/wiki/Immutable_object">immutability</a>,
and is a feature designed to ensure the integrity of a given value.</p>
<p>The proposal also recognizes that most clients and server-side
applications will need to be able to easily update message aspects, and, as
such, provides interface methods that will create new message instances with
the updates. These are generally prefixed with the verbiage <code>with</code> or
<code>without</code>.</p>
<p>Value objects provides several benefits when modeling HTTP messages:</p>
<ul>
<li>Changes in URI state cannot alter the request composing the URI instance.</li>
<li>Changes in headers cannot alter the message composing them.</li>
</ul>
<p>In essence, modeling HTTP messages as value objects ensures the integrity of
the message state, and prevents the need for bi-directional dependencies, which
can often go out-of-sync or lead to debugging or performance issues.</p>
<p>For HTTP clients, they allow consumers to build a base request with data such
as the base URI and required headers, without needing to build a brand new
request or reset request state for each message the client sends:</p>
<pre><code class="language-php">$uri = new Uri('http://api.example.com');
$baseRequest = new Request($uri, null, [
    'Authorization' =&gt; 'Bearer ' . $token,
    'Accept'        =&gt; 'application/json',
]);

$request = $baseRequest-&gt;withUri($uri-&gt;withPath('/user'))-&gt;withMethod('GET');
$response = $client-&gt;send($request);

// get user id from $response

$body = new StringStream(json_encode(['tasks' =&gt; [
    'Code',
    'Coffee',
]]));
$request = $baseRequest
    -&gt;withUri($uri-&gt;withPath('/tasks/user/' . $userId))
    -&gt;withMethod('POST')
    -&gt;withHeader('Content-Type', 'application/json')
    -&gt;withBody($body);
$response = $client-&gt;send($request)

// No need to overwrite headers or body!
$request = $baseRequest-&gt;withUri($uri-&gt;withPath('/tasks'))-&gt;withMethod('GET');
$response = $client-&gt;send($request);
</code></pre>
<p>On the server-side, developers will need to:</p>
<ul>
<li>Deserialize the request message body.</li>
<li>Decrypt HTTP cookies.</li>
<li>Write to the response.</li>
</ul>
<p>These operations can be accomplished with value objects as well, with a number
of benefits:</p>
<ul>
<li>The original request state can be stored for retrieval by any consumer.</li>
<li>A default response state can be created with default headers and/or message body.</li>
</ul>
<p>Most popular PHP frameworks have fully mutable HTTP messages today. The main
changes necessary in consuming true value objects are:</p>
<ul>
<li>Instead of calling setter methods or setting public properties, mutator
  methods will be called, and the result assigned.</li>
<li>Developers must notify the application on a change in state.</li>
</ul>
<p>As an example, in Zend Framework 2, instead of the following:</p>
<pre><code class="language-php">function (MvcEvent $e)
{
    $response = $e-&gt;getResponse();
    $response-&gt;setHeaderLine('x-foo', 'bar');
}
</code></pre>
<p>one would now write:</p>
<pre><code class="language-php">function (MvcEvent $e)
{
    $response = $e-&gt;getResponse();
    $e-&gt;setResponse(
        $response-&gt;withHeader('x-foo', 'bar')
    );
}
</code></pre>
<p>The above combines assignment and notification in a single call.</p>
<p>This practice has a side benefit of making explicit any changes to application
state being made.</p>
<h3 id="new-instances-vs-returning-this">New instances vs returning $this</h3>
<p>One observation made on the various <code>with*()</code> methods is that they can likely
safely <code>return $this;</code> if the argument presented will not result in a change in
the value. One rationale for doing so is performance (as this will not result in
a cloning operation).</p>
<p>The various interfaces have been written with verbiage indicating that
immutability MUST be preserved, but only indicate that "an instance" must be
returned containing the new state. Since instances that represent the same value
are considered equal, returning <code>$this</code> is functionally equivalent, and thus
allowed.</p>
<h3 id="using-streams-instead-of-x">Using streams instead of X</h3>
<p><code>MessageInterface</code> uses a body value that must implement <code>StreamInterface</code>. This
design decision was made so that developers can send and receive (and/or receive
and send) HTTP messages that contain more data than can practically be stored in
memory while still allowing the convenience of interacting with message bodies
as a string. While PHP provides a stream abstraction by way of stream wrappers,
stream resources can be cumbersome to work with: stream resources can only be
cast to a string using <code>stream_get_contents()</code> or manually reading the remainder
of a string. Adding custom behavior to a stream as it is consumed or populated
requires registering a stream filter; however, stream filters can only be added
to a stream after the filter is registered with PHP (i.e., there is no stream
filter autoloading mechanism).</p>
<p>The use of a well- defined stream interface allows for the potential of
flexible stream decorators that can be added to a request or response
pre-flight to enable things like encryption, compression, ensuring that the
number of bytes downloaded reflects the number of bytes reported in the
<code>Content-Length</code> of a response, etc. Decorating streams is a well-established
<a href="http://docs.oracle.com/javase/7/docs/api/java/io/package-tree.html">pattern in the Java</a>
and <a href="http://nodejs.org/api/stream.html#stream_class_stream_transform_1">Node</a>
communities that allows for very flexible streams.</p>
<p>The majority of the <code>StreamInterface</code> API is based on
<a href="http://docs.python.org/3.1/library/io.html">Python's io module</a>, which provides
a practical and consumable API. Instead of implementing stream
capabilities using something like a <code>WritableStreamInterface</code> and
<code>ReadableStreamInterface</code>, the capabilities of a stream are provided by methods
like <code>isReadable()</code>, <code>isWritable()</code>, etc. This approach is used by Python,
<a href="http://msdn.microsoft.com/en-us/library/system.io.stream.aspx">C#, C++</a>,
<a href="http://www.ruby-doc.org/core-2.0.0/IO.html">Ruby</a>,
<a href="http://nodejs.org/api/stream.html">Node</a>, and likely others.</p>
<h4 id="what-if-i-just-want-to-return-a-file">What if I just want to return a file?</h4>
<p>In some cases, you may want to return a file from the filesystem. The typical
way to do this in PHP is one of the following:</p>
<pre><code class="language-php">readfile($filename);

stream_copy_to_stream(fopen($filename, 'r'), fopen('php://output', 'w'));
</code></pre>
<p>Note that the above omits sending appropriate <code>Content-Type</code> and
<code>Content-Length</code> headers; the developer would need to emit these prior to
calling the above code.</p>
<p>The equivalent using HTTP messages would be to use a <code>StreamInterface</code>
implementation that accepts a filename and/or stream resource, and to provide
this to the response instance. A complete example, including setting appropriate
headers:</p>
<pre><code class="language-php">// where Stream is a concrete StreamInterface:
$stream   = new Stream($filename);
$finfo    = new finfo(FILEINFO_MIME);
$response = $response
    -&gt;withHeader('Content-Type', $finfo-&gt;file($filename))
    -&gt;withHeader('Content-Length', (string) filesize($filename))
    -&gt;withBody($stream);
</code></pre>
<p>Emitting this response will send the file to the client.</p>
<h4 id="what-if-i-want-to-directly-emit-output">What if I want to directly emit output?</h4>
<p>Directly emitting output (e.g. via <code>echo</code>, <code>printf</code>, or writing to the
<code>php://output</code> stream) is generally only advisable as a performance optimization
or when emitting large data sets. If it needs to be done and you still wish
to work in an HTTP message paradigm, one approach would be to use a
callback-based <code>StreamInterface</code> implementation, per <a href="https://github.com/phly/psr7examples#direct-output">this
example</a>. Wrap any code
emitting output directly in a callback, pass that to an appropriate
<code>StreamInterface</code> implementation, and provide it to the message body:</p>
<pre><code class="language-php">$output = new CallbackStream(function () use ($request) {
    printf(&quot;The requested URI was: %s&lt;br&gt;\n&quot;, $request-&gt;getUri());
    return '';
});
return (new Response())
    -&gt;withHeader('Content-Type', 'text/html')
    -&gt;withBody($output);
</code></pre>
<h4 id="what-if-i-want-to-use-an-iterator-for-content">What if I want to use an iterator for content?</h4>
<p>Ruby's Rack implementation uses an iterator-based approach for server-side
response message bodies. This can be emulated using an HTTP message paradigm via
an iterator-backed <code>StreamInterface</code> approach, as <a href="https://github.com/phly/psr7examples#iterators-and-generators">detailed in the
psr7examples repository</a>.</p>
<h3 id="why-are-streams-mutable">Why are streams mutable?</h3>
<p>The <code>StreamInterface</code> API includes methods such as <code>write()</code> which can
change the message content -- which directly contradicts having immutable
messages.</p>
<p>The problem that arises is due to the fact that the interface is intended to
wrap a PHP stream or similar. A write operation therefore will proxy to writing
to the stream. Even if we made <code>StreamInterface</code> immutable, once the stream
has been updated, any instance that wraps that stream will also be updated --
making immutability impossible to enforce.</p>
<p>Our recommendation is that implementations use read-only streams for
server-side requests and client-side responses.</p>
<h3 id="rationale-for-serverrequestinterface">Rationale for ServerRequestInterface</h3>
<p>The <code>RequestInterface</code> and <code>ResponseInterface</code> have essentially 1:1
correlations with the request and response messages described in
<a href="http://www.ietf.org/rfc/rfc7230.txt">RFC 7230</a>. They provide interfaces for
implementing value objects that correspond to the specific HTTP message types
they model.</p>
<p>For server-side applications there are other considerations for
incoming requests:</p>
<ul>
<li>Access to server parameters (potentially derived from the request, but also
  potentially the result of server configuration, and generally represented
  via the <code>$_SERVER</code> superglobal; these are part of the PHP Server API (SAPI)).</li>
<li>Access to the query string arguments (usually encapsulated in PHP via the
  <code>$_GET</code> superglobal).</li>
<li>Access to the parsed body (i.e., data deserialized from the incoming request
  body; in PHP, this is typically the result of POST requests using
  <code>application/x-www-form-urlencoded</code> content types, and encapsulated in the
  <code>$_POST</code> superglobal, but for non-POST, non-form-encoded data, could be
  an array or an object).</li>
<li>Access to uploaded files (encapsulated in PHP via the <code>$_FILES</code> superglobal).</li>
<li>Access to cookie values (encapsulated in PHP via the <code>$_COOKIE</code> superglobal).</li>
<li>Access to attributes derived from the request (usually, but not limited to,
  those matched against the URL path).</li>
</ul>
<p>Uniform access to these parameters increases the viability of interoperability
between frameworks and libraries, as they can now assume that if a request
implements <code>ServerRequestInterface</code>, they can get at these values. It also
solves problems within the PHP language itself:</p>
<ul>
<li>Until 5.6.0, <code>php://input</code> was read-once; as such, instantiating multiple
  request instances from multiple frameworks/libraries could lead to
  inconsistent state, as the first to access <code>php://input</code> would be the only
  one to receive the data.</li>
<li>Unit testing against superglobals (e.g., <code>$_GET</code>, <code>$_FILES</code>, etc.) is
  difficult and typically brittle. Encapsulating them inside the
  <code>ServerRequestInterface</code> implementation eases testing considerations.</li>
</ul>
<h3 id="why-parsed-body-in-the-serverrequestinterface">Why "parsed body" in the ServerRequestInterface?</h3>
<p>Arguments were made to use the terminology "BodyParams", and require the value
to be an array, with the following rationale:</p>
<ul>
<li>Consistency with other server-side parameter access.</li>
<li><code>$_POST</code> is an array, and the 80% use case would target that superglobal.</li>
<li>A single type makes for a strong contract, simplifying usage.</li>
</ul>
<p>The main argument is that if the body parameters are an array, developers have
predictable access to values:</p>
<pre><code class="language-php">$foo = isset($request-&gt;getBodyParams()['foo'])
    ? $request-&gt;getBodyParams()['foo']
    : null;
</code></pre>
<p>The argument for using "parsed body" was made by examining the domain. A message
body can contain literally anything. While traditional web applications use
forms and submit data using POST, this is a use case that is quickly being
challenged in current web development trends, which are often API-centric, and
thus use alternate request methods (notably PUT and PATCH), as well as
non-form-encoded content (generally JSON or XML) that <em>can</em> be coerced to arrays
in many cases, but in many cases also <em>cannot</em> or <em>should not</em>.</p>
<p>If forcing the property representing the parsed body to be only an array,
developers then need a shared convention about where to put the results of
parsing the body. These might include:</p>
<ul>
<li>A special key under the body parameters, such as <code>__parsed__</code>.</li>
<li>A specially named attribute, such as <code>__body__</code>.</li>
</ul>
<p>The end result is that a developer now has to look in multiple locations:</p>
<pre><code class="language-php">$data = $request-&gt;getBodyParams();
if (isset($data['__parsed__']) &amp;&amp; is_object($data['__parsed__'])) {
    $data = $data['__parsed__'];
}

// or:
$data = $request-&gt;getBodyParams();
if ($request-&gt;hasAttribute('__body__')) {
    $data = $request-&gt;getAttribute('__body__');
}
</code></pre>
<p>The solution presented is to use the terminology "ParsedBody", which implies
that the values are the results of parsing the message body. This also means
that the return value <em>will</em> be ambiguous; however, because this is an attribute
of the domain, this is also expected. As such, usage will become:</p>
<pre><code class="language-php">$data = $request-&gt;getParsedBody();
if (! $data instanceof \stdClass) {
    // raise an exception!
}
// otherwise, we have what we expected
</code></pre>
<p>This approach removes the limitations of forcing an array, at the expense of
ambiguity of return value. Considering that the other suggested solutions —
pushing the parsed data into a special body parameter key or into an attribute —
also suffer from ambiguity, the proposed solution is simpler as it does not
require additions to the interface specification. Ultimately, the ambiguity
enables the flexibility required when representing the results of parsing the
body.</p>
<h3 id="why-is-no-functionality-included-for-retrieving-the-base-path">Why is no functionality included for retrieving the "base path"?</h3>
<p>Many frameworks provide the ability to get the "base path," usually considered
the path up to and including the front controller. As an example, if the
application is served at <code>http://example.com/b2b/index.php</code>, and the current URI
used to request it is <code>http://example.com/b2b/index.php/customer/register</code>, the
functionality to retrieve the base path would return <code>/b2b/index.php</code>. This value
can then be used by routers to strip that path segment prior to attempting a
match.</p>
<p>This value is often also then used for URI generation within applications;
parameters will be passed to the router, which will generate the path, and
prefix it with the base path in order to return a fully-qualified URI. Other
tools — typically view helpers, template filters, or template functions — are
used to resolve a path relative to the base path in order to generate a URI for
linking to resources such as static assets.</p>
<p>On examination of several different implementations, we noticed the following:</p>
<ul>
<li>The logic for determining the base path varies widely between implementations.
  As an example, compare the <a href="https://github.com/zendframework/zf2/blob/release-2.3.7/library/Zend/Http/PhpEnvironment/Request.php#L477-L575">logic in ZF2</a>
  to the <a href="https://github.com/symfony/symfony/blob/2.7/src/Symfony/Component/HttpFoundation/Request.php#L1858-L1877">logic in Symfony 2</a>.</li>
<li>Most implementations appear to allow manual injection of a base path to the
  router and/or any facilities used for URI generation.</li>
<li>The primary use cases — routing and URI generation — typically are the only
  consumers of the functionality; developers usually do not need to be aware
  of the base path concept as other objects take care of that detail for them.
  As examples:</li>
<li>A router will strip off the base path for you during routing; you do not
    need to pass the modified path to the router.</li>
<li>View helpers, template filters, etc. typically are injected with a base path
    prior to invocation. Sometimes this is manually done, though more often it
    is the result of framework wiring.</li>
<li>All sources necessary for calculating the base path <em>are already in the
  <code>RequestInterface</code> instance</em>, via server parameters and the URI instance.</li>
</ul>
<p>Our stance is that base path detection is framework and/or application
specific, and the results of detection can be easily injected into objects that
need it, and/or calculated as needed using utility functions and/or classes from
the <code>RequestInterface</code> instance itself.</p>
<h3 id="why-does-getuploadedfiles-return-objects-instead-of-arrays">Why does getUploadedFiles() return objects instead of arrays?</h3>
<p><code>getUploadedFiles()</code> returns a tree of <code>Psr\Http\Message\UploadedFileInterface</code>
instances. This is done primarily to simplify specification: instead of
requiring paragraphs of implementation specification for an array, we specify an
interface.</p>
<p>Additionally, the data in an <code>UploadedFileInterface</code> is normalized to work in
both SAPI and non-SAPI environments. This allows the creation of processes to parse
the message body manually and assign contents to streams without first writing
to the filesystem, while still allowing proper handling of file uploads in SAPI
environments.</p>
<h3 id="what-about-special-header-values">What about "special" header values?</h3>
<p>A number of header values contain unique representation requirements which can
pose problems both for consumption as well as generation; in particular, cookies
and the <code>Accept</code> header.</p>
<p>This proposal does not provide any special treatment of any header types. The
base <code>MessageInterface</code> provides methods for header retrieval and setting, and
all header values are, in the end, string values.</p>
<p>Developers are encouraged to write commodity libraries for interacting with
these header values, either for the purposes of parsing or generation. Users may
then consume these libraries when needing to interact with those values.
Examples of this practice already exist in libraries such as
<a href="https://github.com/willdurand/Negotiation">willdurand/Negotiation</a> and
<a href="https://github.com/auraphp/Aura.Accept">Aura.Accept</a>. So long as the object
has functionality for casting the value to a string, these objects can be
used to populate the headers of an HTTP message.</p>
<h2 id="6-people">6. People</h2>
<h3 id="61-editors">6.1 Editor(s)</h3>
<ul>
<li>Matthew Weier O'Phinney</li>
</ul>
<h3 id="62-sponsors">6.2 Sponsors</h3>
<ul>
<li>Paul M. Jones</li>
<li>Beau Simensen (coordinator)</li>
</ul>
<h3 id="63-contributors">6.3 Contributors</h3>
<ul>
<li>Michael Dowling</li>
<li>Larry Garfield</li>
<li>Evert Pot</li>
<li>Tobias Schultze</li>
<li>Bernhard Schussek</li>
<li>Anton Serdyuk</li>
<li>Phil Sturgeon</li>
<li>Chris Wilkinson</li>
</ul>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.fac441b0.min.js"></script>
      
        <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
      
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
      
        <script src="../../js/init.js"></script>
      
    
  </body>
</html>