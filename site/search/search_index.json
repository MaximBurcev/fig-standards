{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PHP Standard Recommendations \u0412 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u0440\u0435\u0433\u043b\u0430\u043c\u0435\u043d\u0442\u043e\u043c \u0440\u0430\u0431\u043e\u0447\u0435\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 PSR \u043a\u0430\u0436\u0434\u044b\u0439 PSR \u0438\u043c\u0435\u0435\u0442 \u0441\u0442\u0430\u0442\u0443\u0441 \u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0440\u0430\u0431\u043e\u0442\u044b. \u041f\u043e\u0441\u043b\u0435 \u0442\u043e\u0433\u043e, \u043a\u0430\u043a \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0439\u0434\u0435\u0442 \u0432\u0441\u0442\u0443\u043f\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0433\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435, \u043e\u043d\u043e \u0431\u0443\u0434\u0435\u0442 \u0443\u043a\u0430\u0437\u0430\u043d\u043e \u0437\u0434\u0435\u0441\u044c \u043a\u0430\u043a \u00ab\u0427\u0435\u0440\u043d\u043e\u0432\u0438\u043a\u00bb. \u0415\u0441\u043b\u0438 PSR \u043d\u0435 \u043e\u0442\u043c\u0435\u0447\u0435\u043d \u043a\u0430\u043a \u00ab\u041f\u0440\u0438\u043d\u044f\u0442\u043e\u00bb, \u043e\u043d \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0438\u0437\u043c\u0435\u043d\u0435\u043d. \u0427\u0435\u0440\u043d\u043e\u0432\u0438\u043a \u043c\u043e\u0436\u0435\u0442 \u043a\u0430\u0440\u0434\u0438\u043d\u0430\u043b\u044c\u043d\u043e \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c\u0441\u044f, \u043d\u043e \u0432 \u0420\u0435\u0432\u044c\u044e \u0431\u0443\u0434\u0443\u0442 \u0432\u043d\u0435\u0441\u0435\u043d\u044b \u043b\u0438\u0448\u044c \u043d\u0435\u0437\u043d\u0430\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f. As also described in the PSR Workflow Bylaw . The Editor, or editors, of a proposal are the essentially the lead contributors and writers of the PSRs and they are supported by two voting members. Those voting members are the Coordinator who is responsible for managing the review stage and votes; and a second sponsor. Index by Status Accepted Num Title Editor Coordinator Sponsor 1 Basic Coding Standard Paul M. Jones N/A N/A 3 Logger Interface Jordi Boggiano N/A N/A 4 Autoloading Standard Paul M. Jones Phil Sturgeon Larry Garfield 6 Caching Interface Larry Garfield Paul Dragoonis Robert Hafner 7 HTTP Message Interface Matthew Weier O'Phinney Beau Simensen Paul M. Jones 11 Container Interface Matthieu Napoli, David N\u00e9grier Matthew Weier O'Phinney Korvin Szanto 12 Extended Coding Style Guide Korvin Szanto Alexander Makarov Chris Tankersley 13 Hypermedia Links Larry Garfield Matthew Weier O'Phinney Marc Alexander 14 Event Dispatcher Larry Garfield N/A Cees-Jan Kiewiet 15 HTTP Handlers Woody Gilk N/A Matthew Weier O'Phinney 16 Simple Cache Paul Dragoonis Jordi Boggiano Fabien Potencier 17 HTTP Factories Woody Gilk N/A Matthew Weier O'Phinney 18 HTTP Client Tobias Nyholm N/A Sara Golemon Draft Num Title Editor(s) 5 PHPDoc Standard Chuck Burgess 19 PHPDoc tags Chuck Burgess 20 Clock Chris Seufert Abandoned Num Title Editor(s) 8 Huggable Interface Larry Garfield 9 Security Advisories Michael Hess 10 Security Reporting Process Michael Hess Deprecated Num Title Editor 0 Autoloading Standard Matthew Weier O'Phinney 2 Coding Style Guide Paul M. Jones Numerical Index Num Title Editor(s) Status 0 Autoloading Standard Matthew Weier O'Phinney Deprecated 1 Basic Coding Standard Paul M. Jones Accepted 2 Coding Style Guide Paul M. Jones Deprecated 3 Logger Interface Jordi Boggiano Accepted 4 Autoloading Standard Paul M. Jones Accepted 5 PHPDoc Standard Chuck Burgess Draft 6 Caching Interface Larry Garfield Accepted 7 HTTP Message Interface Matthew Weier O'Phinney Accepted 8 Huggable Interface Larry Garfield Abandoned 9 Security Advisories Michael Hess Abandoned 10 Security Reporting Process Michael Hess Abandoned 11 Container Interface Matthieu Napoli, David N\u00e9grier Accepted 12 Extended Coding Style Guide Korvin Szanto Accepted 13 Hypermedia Links Larry Garfield Accepted 14 Event Dispatcher Larry Garfield Accepted 15 HTTP Handlers Woody Gilk Accepted 16 Simple Cache Paul Dragoonis Accepted 17 HTTP Factories Woody Gilk Accepted 18 HTTP Client Tobias Nyholm Accepted 19 PHPDoc tags Chuck Burgess Draft 20 Clock Chris Seufert Draft","title":"PHP Standard Recommendations"},{"location":"#php-standard-recommendations","text":"\u0412 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u0440\u0435\u0433\u043b\u0430\u043c\u0435\u043d\u0442\u043e\u043c \u0440\u0430\u0431\u043e\u0447\u0435\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 PSR \u043a\u0430\u0436\u0434\u044b\u0439 PSR \u0438\u043c\u0435\u0435\u0442 \u0441\u0442\u0430\u0442\u0443\u0441 \u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0440\u0430\u0431\u043e\u0442\u044b. \u041f\u043e\u0441\u043b\u0435 \u0442\u043e\u0433\u043e, \u043a\u0430\u043a \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0439\u0434\u0435\u0442 \u0432\u0441\u0442\u0443\u043f\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0433\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435, \u043e\u043d\u043e \u0431\u0443\u0434\u0435\u0442 \u0443\u043a\u0430\u0437\u0430\u043d\u043e \u0437\u0434\u0435\u0441\u044c \u043a\u0430\u043a \u00ab\u0427\u0435\u0440\u043d\u043e\u0432\u0438\u043a\u00bb. \u0415\u0441\u043b\u0438 PSR \u043d\u0435 \u043e\u0442\u043c\u0435\u0447\u0435\u043d \u043a\u0430\u043a \u00ab\u041f\u0440\u0438\u043d\u044f\u0442\u043e\u00bb, \u043e\u043d \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0438\u0437\u043c\u0435\u043d\u0435\u043d. \u0427\u0435\u0440\u043d\u043e\u0432\u0438\u043a \u043c\u043e\u0436\u0435\u0442 \u043a\u0430\u0440\u0434\u0438\u043d\u0430\u043b\u044c\u043d\u043e \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c\u0441\u044f, \u043d\u043e \u0432 \u0420\u0435\u0432\u044c\u044e \u0431\u0443\u0434\u0443\u0442 \u0432\u043d\u0435\u0441\u0435\u043d\u044b \u043b\u0438\u0448\u044c \u043d\u0435\u0437\u043d\u0430\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f. As also described in the PSR Workflow Bylaw . The Editor, or editors, of a proposal are the essentially the lead contributors and writers of the PSRs and they are supported by two voting members. Those voting members are the Coordinator who is responsible for managing the review stage and votes; and a second sponsor.","title":"PHP Standard Recommendations"},{"location":"#index-by-status","text":"","title":"Index by Status"},{"location":"#accepted","text":"Num Title Editor Coordinator Sponsor 1 Basic Coding Standard Paul M. Jones N/A N/A 3 Logger Interface Jordi Boggiano N/A N/A 4 Autoloading Standard Paul M. Jones Phil Sturgeon Larry Garfield 6 Caching Interface Larry Garfield Paul Dragoonis Robert Hafner 7 HTTP Message Interface Matthew Weier O'Phinney Beau Simensen Paul M. Jones 11 Container Interface Matthieu Napoli, David N\u00e9grier Matthew Weier O'Phinney Korvin Szanto 12 Extended Coding Style Guide Korvin Szanto Alexander Makarov Chris Tankersley 13 Hypermedia Links Larry Garfield Matthew Weier O'Phinney Marc Alexander 14 Event Dispatcher Larry Garfield N/A Cees-Jan Kiewiet 15 HTTP Handlers Woody Gilk N/A Matthew Weier O'Phinney 16 Simple Cache Paul Dragoonis Jordi Boggiano Fabien Potencier 17 HTTP Factories Woody Gilk N/A Matthew Weier O'Phinney 18 HTTP Client Tobias Nyholm N/A Sara Golemon","title":"Accepted"},{"location":"#draft","text":"Num Title Editor(s) 5 PHPDoc Standard Chuck Burgess 19 PHPDoc tags Chuck Burgess 20 Clock Chris Seufert","title":"Draft"},{"location":"#abandoned","text":"Num Title Editor(s) 8 Huggable Interface Larry Garfield 9 Security Advisories Michael Hess 10 Security Reporting Process Michael Hess","title":"Abandoned"},{"location":"#deprecated","text":"Num Title Editor 0 Autoloading Standard Matthew Weier O'Phinney 2 Coding Style Guide Paul M. Jones","title":"Deprecated"},{"location":"#numerical-index","text":"Num Title Editor(s) Status 0 Autoloading Standard Matthew Weier O'Phinney Deprecated 1 Basic Coding Standard Paul M. Jones Accepted 2 Coding Style Guide Paul M. Jones Deprecated 3 Logger Interface Jordi Boggiano Accepted 4 Autoloading Standard Paul M. Jones Accepted 5 PHPDoc Standard Chuck Burgess Draft 6 Caching Interface Larry Garfield Accepted 7 HTTP Message Interface Matthew Weier O'Phinney Accepted 8 Huggable Interface Larry Garfield Abandoned 9 Security Advisories Michael Hess Abandoned 10 Security Reporting Process Michael Hess Abandoned 11 Container Interface Matthieu Napoli, David N\u00e9grier Accepted 12 Extended Coding Style Guide Korvin Szanto Accepted 13 Hypermedia Links Larry Garfield Accepted 14 Event Dispatcher Larry Garfield Accepted 15 HTTP Handlers Woody Gilk Accepted 16 Simple Cache Paul Dragoonis Accepted 17 HTTP Factories Woody Gilk Accepted 18 HTTP Client Tobias Nyholm Accepted 19 PHPDoc tags Chuck Burgess Draft 20 Clock Chris Seufert Draft","title":"Numerical Index"},{"location":"LICENSE/","text":"License Unless stated otherwise, all content is licensed under the Creative Commons Attribution License and code licensed under the MIT License. Copies of all licenses are included in this project's root directory.","title":"License"},{"location":"LICENSE/#license","text":"Unless stated otherwise, all content is licensed under the Creative Commons Attribution License and code licensed under the MIT License. Copies of all licenses are included in this project's root directory.","title":"License"},{"location":"accepted/PSR-0/","text":"Autoloading Standard Deprecated - As of 2014-10-21 PSR-0 has been marked as deprecated. PSR-4 is now recommended as an alternative. The following describes the mandatory requirements that must be adhered to for autoloader interoperability. Mandatory A fully-qualified namespace and class must have the following structure \\<Vendor Name>\\(<Namespace>\\)*<Class Name> Each namespace must have a top-level namespace (\"Vendor Name\"). Each namespace can have as many sub-namespaces as it wishes. Each namespace separator is converted to a DIRECTORY_SEPARATOR when loading from the file system. Each _ character in the CLASS NAME is converted to a DIRECTORY_SEPARATOR . The _ character has no special meaning in the namespace. The fully-qualified namespace and class are suffixed with .php when loading from the file system. Alphabetic characters in vendor names, namespaces, and class names may be of any combination of lower case and upper case. Examples \\Doctrine\\Common\\IsolatedClassLoader => /path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php \\Symfony\\Core\\Request => /path/to/project/lib/vendor/Symfony/Core/Request.php \\Zend\\Acl => /path/to/project/lib/vendor/Zend/Acl.php \\Zend\\Mail\\Message => /path/to/project/lib/vendor/Zend/Mail/Message.php Underscores in Namespaces and Class Names \\namespace\\package\\Class_Name => /path/to/project/lib/vendor/namespace/package/Class/Name.php \\namespace\\package_name\\Class_Name => /path/to/project/lib/vendor/namespace/package_name/Class/Name.php The standards we set here should be the lowest common denominator for painless autoloader interoperability. You can test that you are following these standards by utilizing this sample SplClassLoader implementation which is able to load PHP 5.3 classes. Example Implementation Below is an example function to simply demonstrate how the above proposed standards are autoloaded. <?php function autoload($className) { $className = ltrim($className, '\\\\'); $fileName = ''; $namespace = ''; if ($lastNsPos = strrpos($className, '\\\\')) { $namespace = substr($className, 0, $lastNsPos); $className = substr($className, $lastNsPos + 1); $fileName = str_replace('\\\\', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR; } $fileName .= str_replace('_', DIRECTORY_SEPARATOR, $className) . '.php'; require $fileName; } spl_autoload_register('autoload'); SplClassLoader Implementation The following gist is a sample SplClassLoader implementation that can load your classes if you follow the autoloader interoperability standards proposed above. It is the current recommended way to load PHP 5.3 classes that follow these standards. http://gist.github.com/221634","title":"Autoloading Standard"},{"location":"accepted/PSR-0/#autoloading-standard","text":"Deprecated - As of 2014-10-21 PSR-0 has been marked as deprecated. PSR-4 is now recommended as an alternative. The following describes the mandatory requirements that must be adhered to for autoloader interoperability.","title":"Autoloading Standard"},{"location":"accepted/PSR-0/#mandatory","text":"A fully-qualified namespace and class must have the following structure \\<Vendor Name>\\(<Namespace>\\)*<Class Name> Each namespace must have a top-level namespace (\"Vendor Name\"). Each namespace can have as many sub-namespaces as it wishes. Each namespace separator is converted to a DIRECTORY_SEPARATOR when loading from the file system. Each _ character in the CLASS NAME is converted to a DIRECTORY_SEPARATOR . The _ character has no special meaning in the namespace. The fully-qualified namespace and class are suffixed with .php when loading from the file system. Alphabetic characters in vendor names, namespaces, and class names may be of any combination of lower case and upper case.","title":"Mandatory"},{"location":"accepted/PSR-0/#examples","text":"\\Doctrine\\Common\\IsolatedClassLoader => /path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php \\Symfony\\Core\\Request => /path/to/project/lib/vendor/Symfony/Core/Request.php \\Zend\\Acl => /path/to/project/lib/vendor/Zend/Acl.php \\Zend\\Mail\\Message => /path/to/project/lib/vendor/Zend/Mail/Message.php","title":"Examples"},{"location":"accepted/PSR-0/#underscores-in-namespaces-and-class-names","text":"\\namespace\\package\\Class_Name => /path/to/project/lib/vendor/namespace/package/Class/Name.php \\namespace\\package_name\\Class_Name => /path/to/project/lib/vendor/namespace/package_name/Class/Name.php The standards we set here should be the lowest common denominator for painless autoloader interoperability. You can test that you are following these standards by utilizing this sample SplClassLoader implementation which is able to load PHP 5.3 classes.","title":"Underscores in Namespaces and Class Names"},{"location":"accepted/PSR-0/#example-implementation","text":"Below is an example function to simply demonstrate how the above proposed standards are autoloaded. <?php function autoload($className) { $className = ltrim($className, '\\\\'); $fileName = ''; $namespace = ''; if ($lastNsPos = strrpos($className, '\\\\')) { $namespace = substr($className, 0, $lastNsPos); $className = substr($className, $lastNsPos + 1); $fileName = str_replace('\\\\', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR; } $fileName .= str_replace('_', DIRECTORY_SEPARATOR, $className) . '.php'; require $fileName; } spl_autoload_register('autoload');","title":"Example Implementation"},{"location":"accepted/PSR-0/#splclassloader-implementation","text":"The following gist is a sample SplClassLoader implementation that can load your classes if you follow the autoloader interoperability standards proposed above. It is the current recommended way to load PHP 5.3 classes that follow these standards. http://gist.github.com/221634","title":"SplClassLoader Implementation"},{"location":"accepted/PSR-1-basic-coding-standard/","text":"Basic Coding Standard This section of the standard comprises what should be considered the standard coding elements that are required to ensure a high level of technical interoperability between shared PHP code. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . 1. Overview Files MUST use only <?php and <?= tags. Files MUST use only UTF-8 without BOM for PHP code. Files SHOULD either declare symbols (classes, functions, constants, etc.) or cause side-effects (e.g. generate output, change .ini settings, etc.) but SHOULD NOT do both. Namespaces and classes MUST follow an \"autoloading\" PSR: [[PSR-0], [PSR-4]]. Class names MUST be declared in StudlyCaps . Class constants MUST be declared in all upper case with underscore separators. Method names MUST be declared in camelCase . 2. Files 2.1. PHP Tags PHP code MUST use the long <?php ?> tags or the short-echo <?= ?> tags; it MUST NOT use the other tag variations. 2.2. Character Encoding PHP code MUST use only UTF-8 without BOM. 2.3. Side Effects A file SHOULD declare new symbols (classes, functions, constants, etc.) and cause no other side effects, or it SHOULD execute logic with side effects, but SHOULD NOT do both. The phrase \"side effects\" means execution of logic not directly related to declaring classes, functions, constants, etc., merely from including the file . \"Side effects\" include but are not limited to: generating output, explicit use of require or include , connecting to external services, modifying ini settings, emitting errors or exceptions, modifying global or static variables, reading from or writing to a file, and so on. The following is an example of a file with both declarations and side effects; i.e, an example of what to avoid: <?php // side effect: change ini settings ini_set('error_reporting', E_ALL); // side effect: loads a file include \"file.php\"; // side effect: generates output echo \"<html>\\n\"; // declaration function foo() { // function body } The following example is of a file that contains declarations without side effects; i.e., an example of what to emulate: <?php // declaration function foo() { // function body } // conditional declaration is *not* a side effect if (! function_exists('bar')) { function bar() { // function body } } 3. Namespace and Class Names Namespaces and classes MUST follow an \"autoloading\" PSR: [[PSR-0], [PSR-4]]. This means each class is in a file by itself, and is in a namespace of at least one level: a top-level vendor name. Class names MUST be declared in StudlyCaps . Code written for PHP 5.3 and after MUST use formal namespaces. For example: <?php // PHP 5.3 and later: namespace Vendor\\Model; class Foo { } Code written for 5.2.x and before SHOULD use the pseudo-namespacing convention of Vendor_ prefixes on class names. <?php // PHP 5.2.x and earlier: class Vendor_Model_Foo { } 4. Class Constants, Properties, and Methods The term \"class\" refers to all classes, interfaces, and traits. 4.1. Constants Class constants MUST be declared in all upper case with underscore separators. For example: <?php namespace Vendor\\Model; class Foo { const VERSION = '1.0'; const DATE_APPROVED = '2012-06-01'; } 4.2. Properties This guide intentionally avoids any recommendation regarding the use of $StudlyCaps , $camelCase , or $under_score property names. Whatever naming convention is used SHOULD be applied consistently within a reasonable scope. That scope may be vendor-level, package-level, class-level, or method-level. 4.3. Methods Method names MUST be declared in camelCase() .","title":"Basic Coding Standard"},{"location":"accepted/PSR-1-basic-coding-standard/#basic-coding-standard","text":"This section of the standard comprises what should be considered the standard coding elements that are required to ensure a high level of technical interoperability between shared PHP code. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"Basic Coding Standard"},{"location":"accepted/PSR-1-basic-coding-standard/#1-overview","text":"Files MUST use only <?php and <?= tags. Files MUST use only UTF-8 without BOM for PHP code. Files SHOULD either declare symbols (classes, functions, constants, etc.) or cause side-effects (e.g. generate output, change .ini settings, etc.) but SHOULD NOT do both. Namespaces and classes MUST follow an \"autoloading\" PSR: [[PSR-0], [PSR-4]]. Class names MUST be declared in StudlyCaps . Class constants MUST be declared in all upper case with underscore separators. Method names MUST be declared in camelCase .","title":"1. Overview"},{"location":"accepted/PSR-1-basic-coding-standard/#2-files","text":"","title":"2. Files"},{"location":"accepted/PSR-1-basic-coding-standard/#21-php-tags","text":"PHP code MUST use the long <?php ?> tags or the short-echo <?= ?> tags; it MUST NOT use the other tag variations.","title":"2.1. PHP Tags"},{"location":"accepted/PSR-1-basic-coding-standard/#22-character-encoding","text":"PHP code MUST use only UTF-8 without BOM.","title":"2.2. Character Encoding"},{"location":"accepted/PSR-1-basic-coding-standard/#23-side-effects","text":"A file SHOULD declare new symbols (classes, functions, constants, etc.) and cause no other side effects, or it SHOULD execute logic with side effects, but SHOULD NOT do both. The phrase \"side effects\" means execution of logic not directly related to declaring classes, functions, constants, etc., merely from including the file . \"Side effects\" include but are not limited to: generating output, explicit use of require or include , connecting to external services, modifying ini settings, emitting errors or exceptions, modifying global or static variables, reading from or writing to a file, and so on. The following is an example of a file with both declarations and side effects; i.e, an example of what to avoid: <?php // side effect: change ini settings ini_set('error_reporting', E_ALL); // side effect: loads a file include \"file.php\"; // side effect: generates output echo \"<html>\\n\"; // declaration function foo() { // function body } The following example is of a file that contains declarations without side effects; i.e., an example of what to emulate: <?php // declaration function foo() { // function body } // conditional declaration is *not* a side effect if (! function_exists('bar')) { function bar() { // function body } }","title":"2.3. Side Effects"},{"location":"accepted/PSR-1-basic-coding-standard/#3-namespace-and-class-names","text":"Namespaces and classes MUST follow an \"autoloading\" PSR: [[PSR-0], [PSR-4]]. This means each class is in a file by itself, and is in a namespace of at least one level: a top-level vendor name. Class names MUST be declared in StudlyCaps . Code written for PHP 5.3 and after MUST use formal namespaces. For example: <?php // PHP 5.3 and later: namespace Vendor\\Model; class Foo { } Code written for 5.2.x and before SHOULD use the pseudo-namespacing convention of Vendor_ prefixes on class names. <?php // PHP 5.2.x and earlier: class Vendor_Model_Foo { }","title":"3. Namespace and Class Names"},{"location":"accepted/PSR-1-basic-coding-standard/#4-class-constants-properties-and-methods","text":"The term \"class\" refers to all classes, interfaces, and traits.","title":"4. Class Constants, Properties, and Methods"},{"location":"accepted/PSR-1-basic-coding-standard/#41-constants","text":"Class constants MUST be declared in all upper case with underscore separators. For example: <?php namespace Vendor\\Model; class Foo { const VERSION = '1.0'; const DATE_APPROVED = '2012-06-01'; }","title":"4.1. Constants"},{"location":"accepted/PSR-1-basic-coding-standard/#42-properties","text":"This guide intentionally avoids any recommendation regarding the use of $StudlyCaps , $camelCase , or $under_score property names. Whatever naming convention is used SHOULD be applied consistently within a reasonable scope. That scope may be vendor-level, package-level, class-level, or method-level.","title":"4.2. Properties"},{"location":"accepted/PSR-1-basic-coding-standard/#43-methods","text":"Method names MUST be declared in camelCase() .","title":"4.3. Methods"},{"location":"accepted/PSR-11-container-meta/","text":"Container Meta Document 1. Introduction This document describes the process and discussions that led to the Container PSR. Its goal is to explain the reasons behind each decision. 2. Why bother? There are dozens of dependency injection containers out there, and these DI containers have very different ways to store entries. Some are based on callbacks (Pimple, Laravel, ...) Others are based on configuration (Symfony, ZF, ...), with various formats (PHP arrays, YAML files, XML files...) Some can leverage factories... Some have a PHP API to build entries (PHP-DI, ZF, Symfony, Mouf...) Some can do auto-wiring (Laravel, PHP-DI, ...) Others can wire entries based on annotations (PHP-DI, JMS Bundle...) Some have a graphical user interface (Mouf...) Some can compile configuration files to PHP classes (Symfony, ZF...) Some can do aliasing... Some can use proxies to provide lazy loading of dependencies... So when you look at the big picture, there is a very large number of ways in which the DI problem can be tackled, and therefore a big number of different implementations. However, all the DI containers out there are answering the same need: they offer a way for the application to retrieve a set of configured objects (usually services). By standardizing the way entries are fetched from a container, frameworks and libraries using the Container PSR could work with any compatible container. That would allow end users to choose their own container based on their own preferences. 3. Scope 3.1. Goals The goal set by the Container PSR is to standardize how frameworks and libraries make use of a container to obtain objects and parameters. It is important to distinguish the two usages of a container: configuring entries fetching entries Most of the time, those two sides are not used by the same party. While it is often end users who tend to configure entries, it is generally the framework that fetches entries to build the application. This is why this interface focuses only on how entries can be fetched from a container. 3.2. Non-goals How entries are set in the container and how they are configured is out of the scope of this PSR. This is what makes a container implementation unique. Some containers have no configuration at all (they rely on autowiring), others rely on PHP code defined via callback, others on configuration files... This standard only focuses on how entries are fetched. Also, naming conventions used for entries are not part of the scope of this PSR. Indeed, when you look at naming conventions, there are 2 strategies: the identifier is the class name, or an interface name (used mostly by frameworks with an autowiring capability) the identifier is a common name (closer to a variable name), which is mostly used by frameworks relying on configuration. Both strategies have their strengths and weaknesses. The goal of this PSR is not to choose one convention over the other. Instead, the user can simply use aliasing to bridge the gap between 2 containers with different naming strategies. 4. Recommended usage: Container PSR and the Service Locator The PSR states that: \"users SHOULD NOT pass a container into an object, so the object can retrieve its own dependencies . Users doing so are using the container as a Service Locator. Service Locator usage is generally discouraged.\" // This is not OK, you are using the container as a service locator class BadExample { public function __construct(ContainerInterface $container) { $this->db = $container->get('db'); } } // Instead, please consider injecting directly the dependencies class GoodExample { public function __construct($db) { $this->db = $db; } } // You can then use the container to inject the $db object into your $goodExample object. In the BadExample you should not inject the container because: it makes the code less interoperable : by injecting the container, you have to use a container compatible with the Container PSR. With the other option, your code can work with ANY container. you are forcing the developer into naming its entry \"db\". This naming could conflict with another package that has the same expectations for another service. it is harder to test. it is not directly clear from your code that the BadExample class will need the \"db\" service. Dependencies are hidden. Very often, the ContainerInterface will be used by other packages. As a end-user PHP developer using a framework, it is unlikely you will ever need to use containers or type-hint on the ContainerInterface directly. Whether using the Container PSR into your code is considered a good practice or not boils down to knowing if the objects you are retrieving are dependencies of the object referencing the container or not. Here are a few more examples: class RouterExample { // ... public function __construct(ContainerInterface $container) { $this->container = $container; } public function getRoute($request) { $controllerName = $this->getContainerEntry($request->getUrl()); // This is OK, the router is finding the matching controller entry, the controller is // not a dependency of the router $controller = $this->container->get($controllerName); // ... } } In this example, the router is transforming the URL into a controller entry name, then fetches the controller from the container. A controller is not really a dependency of the router. As a rule of thumb, if your object is computing the entry name among a list of entries that can vary, your use case is certainly legitimate. As an exception, factory objects whose only purpose is to create and return new instances may use the service locator pattern. The factory must then implement an interface so that it can itself be replaced by another factory using the same interface. // ok: a factory interface + implementation to create an object interface FactoryInterface { public function newInstance(); } class ExampleFactory implements FactoryInterface { protected $container; public function __construct(ContainerInterface $container) { $this->container = $container; } public function newInstance() { return new Example($this->container->get('db')); } } 5. History Before submitting the Container PSR to the PHP-FIG, the ContainerInterface was first proposed in a project named container-interop . The goal of the project was to provide a test-bed for implementing the ContainerInterface , and to pave the way for the Container PSR. In the rest of this meta document, you will see frequent references to container-interop. 6. Interface name The interface name is the same as the one discussed for container-interop (only the namespace is changed to match the other PSRs). It has been thoroughly discussed on container-interop [4] and was decided by a vote [5] . The list of options considered with their respective votes are: ContainerInterface : +8 ProviderInterface : +2 LocatorInterface : 0 ReadableContainerInterface : -5 ServiceLocatorInterface : -6 ObjectFactory : -6 ObjectStore : -8 ConsumerInterface : -9 7. Interface methods The choice of which methods the interface would contain was made after a statistical analysis of existing containers. [6] . The summary of the analysis showed that: all containers offer a method to get an entry by its id a large majority name such method get() for all containers, the get() method has 1 mandatory parameter of type string some containers have an optional additional argument for get() , but it doesn't have the same purpose between containers a large majority of the containers offer a method to test if it can return an entry by its id a majority name such method has() for all containers offering has() , the method has exactly 1 parameter of type string a large majority of the containers throw an exception rather than returning null when an entry is not found in get() a large majority of the containers don't implement ArrayAccess The question of whether to include methods to define entries has been discussed at the very start of the container-interop project [4] . It has been judged that such methods do not belong in the interface described here because it is out of its scope (see the \"Goal\" section). As a result, the ContainerInterface contains two methods: get() , returning anything, with one mandatory string parameter. Should throw an exception if the entry is not found. has() , returning a boolean, with one mandatory string parameter. 7.1. Number of parameters in get() method While ContainerInterface only defines one mandatory parameter in get() , it is not incompatible with existing containers that have additional optional parameters. PHP allows an implementation to offer more parameters as long as they are optional, because the implementation does satisfy the interface. Difference with container-interop: The container-interop spec stated that: While ContainerInterface only defines one mandatory parameter in get() , implementations MAY accept additional optional parameters. This sentence was removed from PSR-11 because: It is something that stems from OO principles in PHP, so this is not directly related to PSR-11 We do not want to encourage implementors to add additional parameters as we recommend coding against the interface and not the implementation However, some implementations have extra optional parameters; that's technically legal. Such implementations are compatible with PSR-11. [11] 7.2. Type of the $id parameter The type of the $id parameter in get() and has() has been discussed in the container-interop project. While string is used in all the containers that were analyzed, it was suggested that allowing anything (such as objects) could allow containers to offer a more advanced query API. An example given was to use the container as an object builder. The $id parameter would then be an object that would describe how to create an instance. The conclusion of the discussion [7] was that this was beyond the scope of getting entries from a container without knowing how the container provided them, and it was more fit for a factory. 7.3. Exceptions thrown This PSR provides 2 interfaces meant to be implemented by container exceptions. 7.3.1 Base exception The Psr\\Container\\ContainerExceptionInterface is the base interface. It SHOULD be implemented by custom exceptions thrown directly by the container. It is expected that any exception that is part of the domain of the container implements the ContainerExceptionInterface . A few examples: if a container relies on a configuration file and if that configuration file is flawed, the container might throw an InvalidFileException implementing the ContainerExceptionInterface . if a cyclic dependency is detected between dependencies, the container might throw an CyclicDependencyException implementing the ContainerExceptionInterface . However, if the exception is thrown by some code out of the container's scope (for instance an exception thrown while instantiating an entry), the container is not required to wrap this exception in a custom exception implementing the ContainerExceptionInterface . The usefulness of the base exception interface was questioned: it is not an exception one would typically catch [8] . However, most PHP-FIG members considered it to be a best practice. Base exception interface are implemented in previous PSRs and several member projects. The base exception interface was therefore kept. 7.3.2 Not found exception A call to the get method with a non-existing id must throw an exception implementing the Psr\\Container\\NotFoundExceptionInterface . For a given identifier: if the has method returns false , then the get method MUST throw a Psr\\Container\\NotFoundExceptionInterface . if the has method returns true , this does not mean that the get method will succeed and throw no exception. It can even throw a Psr\\Container\\NotFoundExceptionInterface if one of the dependencies of the requested entry is missing. Therefore, when a user catches the Psr\\Container\\NotFoundExceptionInterface , it has 2 possible meanings [9] : the requested entry does not exist (bad request) or a dependency of the requested entry does not exist (i.e. the container is misconfigured) The user can however easily make a distinction with a call to has . In pseudo-code: if (!$container->has($id)) { // The requested instance does not exist return; } try { $entry = $container->get($id); } catch (NotFoundExceptionInterface $e) { // Since the requested entry DOES exist, a NotFoundExceptionInterface means that the container is misconfigured and a dependency is missing. } 8. Implementations At the time of writing, the following projects already implement and/or consume the container-interop version of the interface. Implementors Acclimate Aura.DI dcp-di League Container Mouf Njasm Container PHP-DI PimpleInterop XStatic Zend ServiceManager Middleware Alias-Container Prefixer-Container Consumers Behat interop.silex.di mindplay/middleman PHP-DI Invoker Prophiler Silly Slim Splash Zend Expressive This list is not comprehensive and should be only taken as an example showing that there is considerable interest in the PSR. 9. People 9.1 Editors Matthieu Napoli David N\u00e9grier 9.2 Sponsors Matthew Weier O'Phinney (Coordinator) Korvin Szanto 9.3 Contributors Are listed here all people that contributed in the discussions or votes (on container-interop and during migration to PSR-11), by alphabetical order: Alexandru P\u0103tr\u0103nescu Amy Stephen Ben Peachey David N\u00e9grier Don Gilbert Jason Judge Jeremy Lindblom Larry Garfield Marco Pivetta Matthieu Napoli Nelson J Morais Paul M. Jones Phil Sturgeon Stephan Hochd\u00f6rfer Taylor Otwell 10. Relevant links Discussion about the container PSR and the service locator Container-interop's ContainerInterface.php List of all issues Discussion about the interface name and container-interop scope Vote for the interface name Statistical analysis of existing containers method names Discussion about the method names and parameters Discussion about the usefulness of the base exception Discussion about the NotFoundExceptionInterface Discussion about get optional parameters in container-interop and on the PHP-FIG mailing list 11. Errata Type additions The 1.1 release of the psr/container package includes scalar parameter types. The 2.0 release of the package includes return types. This structure leverages PHP 7.2 covariance support to allow for a gradual upgrade process. Implementers MAY add return types to their own packages at their discretion, provided that: the return types match those in the 2.0 package. the implementation specifies a minimum PHP version of 7.2.0 or later. Implementers MAY add parameter types to their own packages in a new major release, either at the same time as adding return types or in a subsequent release, provided that: the parameter types match those in the 1.1 package. the implementation specifies a minimum PHP version of 7.2.0. the implementation depends on \"psr/container\": \"^1.1 || ^2.0\" so as to exclude the untyped 1.0 version. Implementers are encouraged but not required to transition their packages toward the 2.0 version of the package at their earliest convenience.","title":"Container Meta Document"},{"location":"accepted/PSR-11-container-meta/#container-meta-document","text":"","title":"Container Meta Document"},{"location":"accepted/PSR-11-container-meta/#1-introduction","text":"This document describes the process and discussions that led to the Container PSR. Its goal is to explain the reasons behind each decision.","title":"1. Introduction"},{"location":"accepted/PSR-11-container-meta/#2-why-bother","text":"There are dozens of dependency injection containers out there, and these DI containers have very different ways to store entries. Some are based on callbacks (Pimple, Laravel, ...) Others are based on configuration (Symfony, ZF, ...), with various formats (PHP arrays, YAML files, XML files...) Some can leverage factories... Some have a PHP API to build entries (PHP-DI, ZF, Symfony, Mouf...) Some can do auto-wiring (Laravel, PHP-DI, ...) Others can wire entries based on annotations (PHP-DI, JMS Bundle...) Some have a graphical user interface (Mouf...) Some can compile configuration files to PHP classes (Symfony, ZF...) Some can do aliasing... Some can use proxies to provide lazy loading of dependencies... So when you look at the big picture, there is a very large number of ways in which the DI problem can be tackled, and therefore a big number of different implementations. However, all the DI containers out there are answering the same need: they offer a way for the application to retrieve a set of configured objects (usually services). By standardizing the way entries are fetched from a container, frameworks and libraries using the Container PSR could work with any compatible container. That would allow end users to choose their own container based on their own preferences.","title":"2. Why bother?"},{"location":"accepted/PSR-11-container-meta/#3-scope","text":"","title":"3. Scope"},{"location":"accepted/PSR-11-container-meta/#31-goals","text":"The goal set by the Container PSR is to standardize how frameworks and libraries make use of a container to obtain objects and parameters. It is important to distinguish the two usages of a container: configuring entries fetching entries Most of the time, those two sides are not used by the same party. While it is often end users who tend to configure entries, it is generally the framework that fetches entries to build the application. This is why this interface focuses only on how entries can be fetched from a container.","title":"3.1. Goals"},{"location":"accepted/PSR-11-container-meta/#32-non-goals","text":"How entries are set in the container and how they are configured is out of the scope of this PSR. This is what makes a container implementation unique. Some containers have no configuration at all (they rely on autowiring), others rely on PHP code defined via callback, others on configuration files... This standard only focuses on how entries are fetched. Also, naming conventions used for entries are not part of the scope of this PSR. Indeed, when you look at naming conventions, there are 2 strategies: the identifier is the class name, or an interface name (used mostly by frameworks with an autowiring capability) the identifier is a common name (closer to a variable name), which is mostly used by frameworks relying on configuration. Both strategies have their strengths and weaknesses. The goal of this PSR is not to choose one convention over the other. Instead, the user can simply use aliasing to bridge the gap between 2 containers with different naming strategies.","title":"3.2. Non-goals"},{"location":"accepted/PSR-11-container-meta/#4-recommended-usage-container-psr-and-the-service-locator","text":"The PSR states that: \"users SHOULD NOT pass a container into an object, so the object can retrieve its own dependencies . Users doing so are using the container as a Service Locator. Service Locator usage is generally discouraged.\" // This is not OK, you are using the container as a service locator class BadExample { public function __construct(ContainerInterface $container) { $this->db = $container->get('db'); } } // Instead, please consider injecting directly the dependencies class GoodExample { public function __construct($db) { $this->db = $db; } } // You can then use the container to inject the $db object into your $goodExample object. In the BadExample you should not inject the container because: it makes the code less interoperable : by injecting the container, you have to use a container compatible with the Container PSR. With the other option, your code can work with ANY container. you are forcing the developer into naming its entry \"db\". This naming could conflict with another package that has the same expectations for another service. it is harder to test. it is not directly clear from your code that the BadExample class will need the \"db\" service. Dependencies are hidden. Very often, the ContainerInterface will be used by other packages. As a end-user PHP developer using a framework, it is unlikely you will ever need to use containers or type-hint on the ContainerInterface directly. Whether using the Container PSR into your code is considered a good practice or not boils down to knowing if the objects you are retrieving are dependencies of the object referencing the container or not. Here are a few more examples: class RouterExample { // ... public function __construct(ContainerInterface $container) { $this->container = $container; } public function getRoute($request) { $controllerName = $this->getContainerEntry($request->getUrl()); // This is OK, the router is finding the matching controller entry, the controller is // not a dependency of the router $controller = $this->container->get($controllerName); // ... } } In this example, the router is transforming the URL into a controller entry name, then fetches the controller from the container. A controller is not really a dependency of the router. As a rule of thumb, if your object is computing the entry name among a list of entries that can vary, your use case is certainly legitimate. As an exception, factory objects whose only purpose is to create and return new instances may use the service locator pattern. The factory must then implement an interface so that it can itself be replaced by another factory using the same interface. // ok: a factory interface + implementation to create an object interface FactoryInterface { public function newInstance(); } class ExampleFactory implements FactoryInterface { protected $container; public function __construct(ContainerInterface $container) { $this->container = $container; } public function newInstance() { return new Example($this->container->get('db')); } }","title":"4. Recommended usage: Container PSR and the Service Locator"},{"location":"accepted/PSR-11-container-meta/#5-history","text":"Before submitting the Container PSR to the PHP-FIG, the ContainerInterface was first proposed in a project named container-interop . The goal of the project was to provide a test-bed for implementing the ContainerInterface , and to pave the way for the Container PSR. In the rest of this meta document, you will see frequent references to container-interop.","title":"5. History"},{"location":"accepted/PSR-11-container-meta/#6-interface-name","text":"The interface name is the same as the one discussed for container-interop (only the namespace is changed to match the other PSRs). It has been thoroughly discussed on container-interop [4] and was decided by a vote [5] . The list of options considered with their respective votes are: ContainerInterface : +8 ProviderInterface : +2 LocatorInterface : 0 ReadableContainerInterface : -5 ServiceLocatorInterface : -6 ObjectFactory : -6 ObjectStore : -8 ConsumerInterface : -9","title":"6. Interface name"},{"location":"accepted/PSR-11-container-meta/#7-interface-methods","text":"The choice of which methods the interface would contain was made after a statistical analysis of existing containers. [6] . The summary of the analysis showed that: all containers offer a method to get an entry by its id a large majority name such method get() for all containers, the get() method has 1 mandatory parameter of type string some containers have an optional additional argument for get() , but it doesn't have the same purpose between containers a large majority of the containers offer a method to test if it can return an entry by its id a majority name such method has() for all containers offering has() , the method has exactly 1 parameter of type string a large majority of the containers throw an exception rather than returning null when an entry is not found in get() a large majority of the containers don't implement ArrayAccess The question of whether to include methods to define entries has been discussed at the very start of the container-interop project [4] . It has been judged that such methods do not belong in the interface described here because it is out of its scope (see the \"Goal\" section). As a result, the ContainerInterface contains two methods: get() , returning anything, with one mandatory string parameter. Should throw an exception if the entry is not found. has() , returning a boolean, with one mandatory string parameter.","title":"7. Interface methods"},{"location":"accepted/PSR-11-container-meta/#71-number-of-parameters-in-get-method","text":"While ContainerInterface only defines one mandatory parameter in get() , it is not incompatible with existing containers that have additional optional parameters. PHP allows an implementation to offer more parameters as long as they are optional, because the implementation does satisfy the interface. Difference with container-interop: The container-interop spec stated that: While ContainerInterface only defines one mandatory parameter in get() , implementations MAY accept additional optional parameters. This sentence was removed from PSR-11 because: It is something that stems from OO principles in PHP, so this is not directly related to PSR-11 We do not want to encourage implementors to add additional parameters as we recommend coding against the interface and not the implementation However, some implementations have extra optional parameters; that's technically legal. Such implementations are compatible with PSR-11. [11]","title":"7.1. Number of parameters in get() method"},{"location":"accepted/PSR-11-container-meta/#72-type-of-the-id-parameter","text":"The type of the $id parameter in get() and has() has been discussed in the container-interop project. While string is used in all the containers that were analyzed, it was suggested that allowing anything (such as objects) could allow containers to offer a more advanced query API. An example given was to use the container as an object builder. The $id parameter would then be an object that would describe how to create an instance. The conclusion of the discussion [7] was that this was beyond the scope of getting entries from a container without knowing how the container provided them, and it was more fit for a factory.","title":"7.2. Type of the $id parameter"},{"location":"accepted/PSR-11-container-meta/#73-exceptions-thrown","text":"This PSR provides 2 interfaces meant to be implemented by container exceptions.","title":"7.3. Exceptions thrown"},{"location":"accepted/PSR-11-container-meta/#731-base-exception","text":"The Psr\\Container\\ContainerExceptionInterface is the base interface. It SHOULD be implemented by custom exceptions thrown directly by the container. It is expected that any exception that is part of the domain of the container implements the ContainerExceptionInterface . A few examples: if a container relies on a configuration file and if that configuration file is flawed, the container might throw an InvalidFileException implementing the ContainerExceptionInterface . if a cyclic dependency is detected between dependencies, the container might throw an CyclicDependencyException implementing the ContainerExceptionInterface . However, if the exception is thrown by some code out of the container's scope (for instance an exception thrown while instantiating an entry), the container is not required to wrap this exception in a custom exception implementing the ContainerExceptionInterface . The usefulness of the base exception interface was questioned: it is not an exception one would typically catch [8] . However, most PHP-FIG members considered it to be a best practice. Base exception interface are implemented in previous PSRs and several member projects. The base exception interface was therefore kept.","title":"7.3.1 Base exception"},{"location":"accepted/PSR-11-container-meta/#732-not-found-exception","text":"A call to the get method with a non-existing id must throw an exception implementing the Psr\\Container\\NotFoundExceptionInterface . For a given identifier: if the has method returns false , then the get method MUST throw a Psr\\Container\\NotFoundExceptionInterface . if the has method returns true , this does not mean that the get method will succeed and throw no exception. It can even throw a Psr\\Container\\NotFoundExceptionInterface if one of the dependencies of the requested entry is missing. Therefore, when a user catches the Psr\\Container\\NotFoundExceptionInterface , it has 2 possible meanings [9] : the requested entry does not exist (bad request) or a dependency of the requested entry does not exist (i.e. the container is misconfigured) The user can however easily make a distinction with a call to has . In pseudo-code: if (!$container->has($id)) { // The requested instance does not exist return; } try { $entry = $container->get($id); } catch (NotFoundExceptionInterface $e) { // Since the requested entry DOES exist, a NotFoundExceptionInterface means that the container is misconfigured and a dependency is missing. }","title":"7.3.2 Not found exception"},{"location":"accepted/PSR-11-container-meta/#8-implementations","text":"At the time of writing, the following projects already implement and/or consume the container-interop version of the interface.","title":"8. Implementations"},{"location":"accepted/PSR-11-container-meta/#implementors","text":"Acclimate Aura.DI dcp-di League Container Mouf Njasm Container PHP-DI PimpleInterop XStatic Zend ServiceManager","title":"Implementors"},{"location":"accepted/PSR-11-container-meta/#middleware","text":"Alias-Container Prefixer-Container","title":"Middleware"},{"location":"accepted/PSR-11-container-meta/#consumers","text":"Behat interop.silex.di mindplay/middleman PHP-DI Invoker Prophiler Silly Slim Splash Zend Expressive This list is not comprehensive and should be only taken as an example showing that there is considerable interest in the PSR.","title":"Consumers"},{"location":"accepted/PSR-11-container-meta/#9-people","text":"","title":"9. People"},{"location":"accepted/PSR-11-container-meta/#91-editors","text":"Matthieu Napoli David N\u00e9grier","title":"9.1 Editors"},{"location":"accepted/PSR-11-container-meta/#92-sponsors","text":"Matthew Weier O'Phinney (Coordinator) Korvin Szanto","title":"9.2 Sponsors"},{"location":"accepted/PSR-11-container-meta/#93-contributors","text":"Are listed here all people that contributed in the discussions or votes (on container-interop and during migration to PSR-11), by alphabetical order: Alexandru P\u0103tr\u0103nescu Amy Stephen Ben Peachey David N\u00e9grier Don Gilbert Jason Judge Jeremy Lindblom Larry Garfield Marco Pivetta Matthieu Napoli Nelson J Morais Paul M. Jones Phil Sturgeon Stephan Hochd\u00f6rfer Taylor Otwell","title":"9.3 Contributors"},{"location":"accepted/PSR-11-container-meta/#10-relevant-links","text":"Discussion about the container PSR and the service locator Container-interop's ContainerInterface.php List of all issues Discussion about the interface name and container-interop scope Vote for the interface name Statistical analysis of existing containers method names Discussion about the method names and parameters Discussion about the usefulness of the base exception Discussion about the NotFoundExceptionInterface Discussion about get optional parameters in container-interop and on the PHP-FIG mailing list","title":"10. Relevant links"},{"location":"accepted/PSR-11-container-meta/#11-errata","text":"","title":"11. Errata"},{"location":"accepted/PSR-11-container-meta/#type-additions","text":"The 1.1 release of the psr/container package includes scalar parameter types. The 2.0 release of the package includes return types. This structure leverages PHP 7.2 covariance support to allow for a gradual upgrade process. Implementers MAY add return types to their own packages at their discretion, provided that: the return types match those in the 2.0 package. the implementation specifies a minimum PHP version of 7.2.0 or later. Implementers MAY add parameter types to their own packages in a new major release, either at the same time as adding return types or in a subsequent release, provided that: the parameter types match those in the 1.1 package. the implementation specifies a minimum PHP version of 7.2.0. the implementation depends on \"psr/container\": \"^1.1 || ^2.0\" so as to exclude the untyped 1.0 version. Implementers are encouraged but not required to transition their packages toward the 2.0 version of the package at their earliest convenience.","title":"Type additions"},{"location":"accepted/PSR-11-container/","text":"Container interface This document describes a common interface for dependency injection containers. The goal set by ContainerInterface is to standardize how frameworks and libraries make use of a container to obtain objects and parameters (called entries in the rest of this document). The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . The word implementor in this document is to be interpreted as someone implementing the ContainerInterface in a dependency injection-related library or framework. Users of dependency injection containers (DIC) are referred to as user . 1. Specification 1.1 Basics 1.1.1 Entry identifiers An entry identifier is any PHP-legal string of at least one character that uniquely identifies an item within a container. An entry identifier is an opaque string, so callers SHOULD NOT assume that the structure of the string carries any semantic meaning. 1.1.2 Reading from a container The Psr\\Container\\ContainerInterface exposes two methods: get and has . get takes one mandatory parameter: an entry identifier, which MUST be a string. get can return anything (a mixed value), or throw a NotFoundExceptionInterface if the identifier is not known to the container. Two successive calls to get with the same identifier SHOULD return the same value. However, depending on the implementor design and/or user configuration, different values might be returned, so user SHOULD NOT rely on getting the same value on 2 successive calls. has takes one unique parameter: an entry identifier, which MUST be a string. has MUST return true if an entry identifier is known to the container and false if it is not. If has($id) returns false, get($id) MUST throw a NotFoundExceptionInterface . 1.2 Exceptions Exceptions directly thrown by the container SHOULD implement the Psr\\Container\\ContainerExceptionInterface . A call to the get method with a non-existing id MUST throw a Psr\\Container\\NotFoundExceptionInterface . 1.3 Recommended usage Users SHOULD NOT pass a container into an object so that the object can retrieve its own dependencies . This means the container is used as a Service Locator which is a pattern that is generally discouraged. Please refer to section 4 of the META document for more details. 2. Package The interfaces and classes described as well as relevant exceptions are provided as part of the psr/container package. Packages providing a PSR container implementation should declare that they provide psr/container-implementation 1.0.0 . Projects requiring an implementation should require psr/container-implementation 1.0.0 . 3. Interfaces 3.1. Psr\\Container\\ContainerInterface <?php namespace Psr\\Container; /** * Describes the interface of a container that exposes methods to read its entries. */ interface ContainerInterface { /** * Finds an entry of the container by its identifier and returns it. * * @param string $id Identifier of the entry to look for. * * @throws NotFoundExceptionInterface No entry was found for **this** identifier. * @throws ContainerExceptionInterface Error while retrieving the entry. * * @return mixed Entry. */ public function get($id); /** * Returns true if the container can return an entry for the given identifier. * Returns false otherwise. * * `has($id)` returning true does not mean that `get($id)` will not throw an exception. * It does however mean that `get($id)` will not throw a `NotFoundExceptionInterface`. * * @param string $id Identifier of the entry to look for. * * @return bool */ public function has($id); } Since psr/container version 1.1 , the above interface has been updated to add argument type hints. Since psr/container version 2.0 , the above interface has been updated to add return type hints (but only to the has() method). 3.2. Psr\\Container\\ContainerExceptionInterface <?php namespace Psr\\Container; /** * Base interface representing a generic exception in a container. */ interface ContainerExceptionInterface { } 3.3. Psr\\Container\\NotFoundExceptionInterface <?php namespace Psr\\Container; /** * No entry was found in the container. */ interface NotFoundExceptionInterface extends ContainerExceptionInterface { }","title":"Container interface"},{"location":"accepted/PSR-11-container/#container-interface","text":"This document describes a common interface for dependency injection containers. The goal set by ContainerInterface is to standardize how frameworks and libraries make use of a container to obtain objects and parameters (called entries in the rest of this document). The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . The word implementor in this document is to be interpreted as someone implementing the ContainerInterface in a dependency injection-related library or framework. Users of dependency injection containers (DIC) are referred to as user .","title":"Container interface"},{"location":"accepted/PSR-11-container/#1-specification","text":"","title":"1. Specification"},{"location":"accepted/PSR-11-container/#11-basics","text":"","title":"1.1 Basics"},{"location":"accepted/PSR-11-container/#111-entry-identifiers","text":"An entry identifier is any PHP-legal string of at least one character that uniquely identifies an item within a container. An entry identifier is an opaque string, so callers SHOULD NOT assume that the structure of the string carries any semantic meaning.","title":"1.1.1 Entry identifiers"},{"location":"accepted/PSR-11-container/#112-reading-from-a-container","text":"The Psr\\Container\\ContainerInterface exposes two methods: get and has . get takes one mandatory parameter: an entry identifier, which MUST be a string. get can return anything (a mixed value), or throw a NotFoundExceptionInterface if the identifier is not known to the container. Two successive calls to get with the same identifier SHOULD return the same value. However, depending on the implementor design and/or user configuration, different values might be returned, so user SHOULD NOT rely on getting the same value on 2 successive calls. has takes one unique parameter: an entry identifier, which MUST be a string. has MUST return true if an entry identifier is known to the container and false if it is not. If has($id) returns false, get($id) MUST throw a NotFoundExceptionInterface .","title":"1.1.2 Reading from a container"},{"location":"accepted/PSR-11-container/#12-exceptions","text":"Exceptions directly thrown by the container SHOULD implement the Psr\\Container\\ContainerExceptionInterface . A call to the get method with a non-existing id MUST throw a Psr\\Container\\NotFoundExceptionInterface .","title":"1.2 Exceptions"},{"location":"accepted/PSR-11-container/#13-recommended-usage","text":"Users SHOULD NOT pass a container into an object so that the object can retrieve its own dependencies . This means the container is used as a Service Locator which is a pattern that is generally discouraged. Please refer to section 4 of the META document for more details.","title":"1.3 Recommended usage"},{"location":"accepted/PSR-11-container/#2-package","text":"The interfaces and classes described as well as relevant exceptions are provided as part of the psr/container package. Packages providing a PSR container implementation should declare that they provide psr/container-implementation 1.0.0 . Projects requiring an implementation should require psr/container-implementation 1.0.0 .","title":"2. Package"},{"location":"accepted/PSR-11-container/#3-interfaces","text":"","title":"3. Interfaces"},{"location":"accepted/PSR-11-container/#31-psrcontainercontainerinterface","text":"<?php namespace Psr\\Container; /** * Describes the interface of a container that exposes methods to read its entries. */ interface ContainerInterface { /** * Finds an entry of the container by its identifier and returns it. * * @param string $id Identifier of the entry to look for. * * @throws NotFoundExceptionInterface No entry was found for **this** identifier. * @throws ContainerExceptionInterface Error while retrieving the entry. * * @return mixed Entry. */ public function get($id); /** * Returns true if the container can return an entry for the given identifier. * Returns false otherwise. * * `has($id)` returning true does not mean that `get($id)` will not throw an exception. * It does however mean that `get($id)` will not throw a `NotFoundExceptionInterface`. * * @param string $id Identifier of the entry to look for. * * @return bool */ public function has($id); } Since psr/container version 1.1 , the above interface has been updated to add argument type hints. Since psr/container version 2.0 , the above interface has been updated to add return type hints (but only to the has() method).","title":"3.1. Psr\\Container\\ContainerInterface"},{"location":"accepted/PSR-11-container/#32-psrcontainercontainerexceptioninterface","text":"<?php namespace Psr\\Container; /** * Base interface representing a generic exception in a container. */ interface ContainerExceptionInterface { }","title":"3.2. Psr\\Container\\ContainerExceptionInterface"},{"location":"accepted/PSR-11-container/#33-psrcontainernotfoundexceptioninterface","text":"<?php namespace Psr\\Container; /** * No entry was found in the container. */ interface NotFoundExceptionInterface extends ContainerExceptionInterface { }","title":"3.3. Psr\\Container\\NotFoundExceptionInterface"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/","text":"Extended Coding Style Guide Meta Document 1. Summary This document describes the process and discussions that led to the Extended Coding Style PSR. Its goal is to explain the reasons behind each decision. 2. Why Bother? PSR-2 was accepted in 2012 and since then a number of changes have been made to PHP, most notably recent changes for PHP 7, which have implications for coding style guidelines. Whilst PSR-2 is very comprehensive of PHP functionality that existed at the time of writing, new functionality is very open to interpretation. PSR-12 seeks to provide a set way that both coding style tools can implement, projects can declare adherence to and developers can easily relate on between different projects for these coding style reducing cognitive friction. PSR-2 was created based upon the common practices of the PHP-FIG projects at the time but ultimately this meant it was a compromise of many of the different projects' guidelines. The repercussions of projects changing their coding guidelines to align with PSR-2 (Almost all projects do align with PSR-1, even if it is not explicitly stated) were seen to be too great (losing git history, huge changesets and breaking existing patches/pull requests). PSR-2 required adopters to reformat large amounts of existing code which stifled adoption. To help alleviate this issue with PSR-12, we have taken a more prescriptive approach and defined the standards for new language features as they are released. However it is for a lack of wanting to be dictatorial that we will aim to apply PSR-2 styling, rationale and stances (Described in Section 4, Approaches) in PSR-12 instead of establishing new conventions. 3. Scope 3.1. Goals This PSR shares the same goals as PSR-2. The intent of this guide is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code. When various authors collaborate across multiple projects, it helps to have one set of guidelines to be used among all those projects. Thus, the benefit of this guide is not in the rules themselves, but in the sharing of those rules. This PSR is an extension of PSR-2, and therefore also an extension of PSR-1. The basis of PSR-12 is PSR-2 and therefore a list of differences is provided below to assist with migration but it should be considered as an independent specification. This PSR will include coding style guidelines related to new functionality added to PHP after the publication of PSR-2; this includes PHP 5.5, PHP 5.6 and PHP 7.0. This PSR will also include clarifications on the text of PSR-2, as described in the PSR-2 Errata. 3.2. Non-Goals It is not the intention of this PSR to add entirely new coding style guidelines. PSR-12 will also not change anything stipulated in PSR-1 and PSR-2. 4. Approaches The overarching approach is to attempt to apply existing PSR-2 styling and rationale to new functionality as opposed to establishing new conventions. 4.1. Strict Types Declarations There was a discussion about whether or not strict types should be enforced in the standard https://github.com/cs-extended/fig-standards/issues/7. All were in agreement we should only use a MUST or MUST NOT statement and avoid the use of a SHOULD statement and nobody wanted to say that strict types could not be declared. The discussion was whether it should be considered a coding style item which should be covered or whether it was out of scope and it was decided to be out of scope of a coding style guide. 4.2. Finally and Return Types Declaration Spacing Numerous different options were suggested and they can be seen here for return type declarations or here for finally blocks and the current implementation was chosen due to consistency with other parts of the PSR-12 specification that came from PSR-2. 4.3. Enforcing short form for all type keywords PHP 7.0 introduced scalar types declaration which does not support long type aliases. Therefore it makes sense to enforce primary short type forms to be used to have uniform syntax and prevent possible confusion. 4.4. Public Survey In order to settle things using data, survey was conducted and responses from 142 people including 17 project representatives were gathered: 4.4.1. PHP-FIG Representative Results Representative Project Compound namespaces with a depth of two or more MUST not be used Header statement grouping and ordering Declare statements must each be on their own line Declare statements in PHP files containing markup Declare statements have no spaces: declare(strict_types=1); Block declare statement formatting new keyword usage, parenthesis required Return type declaration formatting Use statement leading slashes disallowed Block namespace declaration formatting General operator spacing Try, Catch, Finally formatting Anonymous class declaration formatting Keyword casing, only lower case Type keywords, short form only Alexander Makarov Yii framework \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Korvin Szanto concrete5 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Leo Feyer Contao \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Larry Garfield Drupal \u2713 \u2713 \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u274c \u2713 \u2713 Andr\u00e9 R. eZ \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Jan Schneider Horde \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Karsten Dambekalns Neos and Flow \u2713 \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Andres Gutierrez Phalcon \u274c \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Ryan Thompson PyroCMS \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u274c \u274c \u2713 \u2713 \u2713 \u2713 \u2713 Matteo Beccati Revive Adserver \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u2713 Damian Mooyman SilverStripe \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Brian Retterer Stormpath PHP SDK \u2713 \u2713 \u2713 \u274c \u274c \u2713 \u274c \u2713 \u274c \u2713 \u2713 \u2713 \u2713 \u274c \u274c Matthew Weier O'Phinney Zend Framework \u274c \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Jordi Boggiano Composer \u274c \u274c \u274c \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Ben Marks Magento \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Chuck Burgess PEAR \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Totals : 13/3 15/1 15/1 13/3 14/2 15/1 14/2 15/1 14/2 14/2 15/1 16/0 15/1 15/1 15/1 4.4.2. General non-representative voters Question For Against Percentage For Compound namespaces required depth 114 12 89.47% Header statement grouping and ordering 113 13 88.5% Declare statements must each be on their own line 120 6 95% Declare statements in PHP files containing markup 119 7 94.12% Declare statements have no spaces 116 10 91.38% Block declare statement formatting 118 8 93.22% new keyword usage, parenthesis required 116 10 91.38% Return type declaration formatting 115 11 90.43% Use statement leading slashes disallowed 118 8 93.22% Block namespace declaration formatting 120 6 95% General operator spacing 123 3 97.56% Try, Catch, Finally formatting 124 2 98.39% Anonymous class declaration formatting 117 9 92.31% Keyword casing, only lower case 124 2 98.39% Type keywords, short form only 121 5 95.87% 4.5. Multiline Function Arguments Mixed With Multiline Return A potential readability issue was raised on the mailing list . We reviewed options for changes to the specification that could provide better readability and the floated option was to require a blank line after the opening bracket of a function if the arguments and the return are both multiline. Instead it was pointed out that this specification already allows you to decide where you'd like to add blank lines and so we will leave it to the implementors to decide. 5. Changelog from PSR-2 Please note this changelog is not a verbose list of changes from PSR-2 but highlights the most notable changes. It should be considered a new specification and therefore you should read the specification for a full understanding of its contents. 5.1. New Statements Lowercase for all keywords - Section 2.5 Short form for all type keywords - Section 2.5 Use statement grouping - Section 3 Use statement blocks - Section 3 Declare statement/Strict types declaration usage - Section 3 Parentheses are always required for class instantiation - Section 4 Typed properties - Section 4.3 Return type declarations - Section 4.5 Variadic and reference argument operators - Section 4.5 Type hints - Section 4.5 Add finally block - Section 5.6 Operators - Section 6 Unary operators - Section 6.1 Binary operators - Section 6.2 Ternary operators - Section 6.3 Anonymous classes - Section 8 5.2. Clarifications and Errata Adjust 'methods' to 'methods and functions' in a number of instances - Throughout Adjust references to classes and interfaces to also include traits - Throughout StudlyCaps meaning clarified as PascalCase - Section 2.1 The last line should not be blank but contain an EOL character - Section 2.2 Blank lines may be added for readability except where explicitly forbidden within the PSR - Section 2.3 PSR-2 errata statement about multi-line arguments - Section 4 PSR-2 errata statement about extending multiple interfaces - Section 4 Forbid blank lines before/after closing/opening braces for classes - Section 4 6. People 6.1. Editor: Korvin Szanto 6.2. Sponsor: Chris Tankersley 6.3. Working Group Members: Alessandro Lai Alexander Makarov Michael Cullum Robert Deutz 6.4. Special Thanks Michael Cullum for drafting the original specification Alexandar Makarov for coordinating the draft during PHP-FIG 2.0 Cees-Jan Kiewiet for moral support 7. Votes Entrance Vote: https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!msg/php-fig/P9atZLOcUBM/_jwkvlYKEAAJ Approval Vote: https://groups.google.com/forum/#!topic/php-fig/1uaeSMaDGbk 8. Relevant Links Note: Order descending chronologically. Inspiration Mailing List Thread Initial Mailing List PSR Proposal Thread","title":"PSR 12 extended coding style guide meta"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#extended-coding-style-guide-meta-document","text":"","title":"Extended Coding Style Guide Meta Document"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#1-summary","text":"This document describes the process and discussions that led to the Extended Coding Style PSR. Its goal is to explain the reasons behind each decision.","title":"1. Summary"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#2-why-bother","text":"PSR-2 was accepted in 2012 and since then a number of changes have been made to PHP, most notably recent changes for PHP 7, which have implications for coding style guidelines. Whilst PSR-2 is very comprehensive of PHP functionality that existed at the time of writing, new functionality is very open to interpretation. PSR-12 seeks to provide a set way that both coding style tools can implement, projects can declare adherence to and developers can easily relate on between different projects for these coding style reducing cognitive friction. PSR-2 was created based upon the common practices of the PHP-FIG projects at the time but ultimately this meant it was a compromise of many of the different projects' guidelines. The repercussions of projects changing their coding guidelines to align with PSR-2 (Almost all projects do align with PSR-1, even if it is not explicitly stated) were seen to be too great (losing git history, huge changesets and breaking existing patches/pull requests). PSR-2 required adopters to reformat large amounts of existing code which stifled adoption. To help alleviate this issue with PSR-12, we have taken a more prescriptive approach and defined the standards for new language features as they are released. However it is for a lack of wanting to be dictatorial that we will aim to apply PSR-2 styling, rationale and stances (Described in Section 4, Approaches) in PSR-12 instead of establishing new conventions.","title":"2. Why Bother?"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#3-scope","text":"","title":"3. Scope"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#31-goals","text":"This PSR shares the same goals as PSR-2. The intent of this guide is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code. When various authors collaborate across multiple projects, it helps to have one set of guidelines to be used among all those projects. Thus, the benefit of this guide is not in the rules themselves, but in the sharing of those rules. This PSR is an extension of PSR-2, and therefore also an extension of PSR-1. The basis of PSR-12 is PSR-2 and therefore a list of differences is provided below to assist with migration but it should be considered as an independent specification. This PSR will include coding style guidelines related to new functionality added to PHP after the publication of PSR-2; this includes PHP 5.5, PHP 5.6 and PHP 7.0. This PSR will also include clarifications on the text of PSR-2, as described in the PSR-2 Errata.","title":"3.1. Goals"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#32-non-goals","text":"It is not the intention of this PSR to add entirely new coding style guidelines. PSR-12 will also not change anything stipulated in PSR-1 and PSR-2.","title":"3.2. Non-Goals"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#4-approaches","text":"The overarching approach is to attempt to apply existing PSR-2 styling and rationale to new functionality as opposed to establishing new conventions.","title":"4. Approaches"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#41-strict-types-declarations","text":"There was a discussion about whether or not strict types should be enforced in the standard https://github.com/cs-extended/fig-standards/issues/7. All were in agreement we should only use a MUST or MUST NOT statement and avoid the use of a SHOULD statement and nobody wanted to say that strict types could not be declared. The discussion was whether it should be considered a coding style item which should be covered or whether it was out of scope and it was decided to be out of scope of a coding style guide.","title":"4.1. Strict Types Declarations"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#42-finally-and-return-types-declaration-spacing","text":"Numerous different options were suggested and they can be seen here for return type declarations or here for finally blocks and the current implementation was chosen due to consistency with other parts of the PSR-12 specification that came from PSR-2.","title":"4.2. Finally and Return Types Declaration Spacing"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#43-enforcing-short-form-for-all-type-keywords","text":"PHP 7.0 introduced scalar types declaration which does not support long type aliases. Therefore it makes sense to enforce primary short type forms to be used to have uniform syntax and prevent possible confusion.","title":"4.3. Enforcing short form for all type keywords"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#44-public-survey","text":"In order to settle things using data, survey was conducted and responses from 142 people including 17 project representatives were gathered:","title":"4.4. Public Survey"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#441-php-fig-representative-results","text":"Representative Project Compound namespaces with a depth of two or more MUST not be used Header statement grouping and ordering Declare statements must each be on their own line Declare statements in PHP files containing markup Declare statements have no spaces: declare(strict_types=1); Block declare statement formatting new keyword usage, parenthesis required Return type declaration formatting Use statement leading slashes disallowed Block namespace declaration formatting General operator spacing Try, Catch, Finally formatting Anonymous class declaration formatting Keyword casing, only lower case Type keywords, short form only Alexander Makarov Yii framework \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Korvin Szanto concrete5 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Leo Feyer Contao \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Larry Garfield Drupal \u2713 \u2713 \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u274c \u2713 \u2713 Andr\u00e9 R. eZ \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Jan Schneider Horde \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Karsten Dambekalns Neos and Flow \u2713 \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Andres Gutierrez Phalcon \u274c \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Ryan Thompson PyroCMS \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u274c \u274c \u2713 \u2713 \u2713 \u2713 \u2713 Matteo Beccati Revive Adserver \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u2713 Damian Mooyman SilverStripe \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Brian Retterer Stormpath PHP SDK \u2713 \u2713 \u2713 \u274c \u274c \u2713 \u274c \u2713 \u274c \u2713 \u2713 \u2713 \u2713 \u274c \u274c Matthew Weier O'Phinney Zend Framework \u274c \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Jordi Boggiano Composer \u274c \u274c \u274c \u2713 \u2713 \u2713 \u274c \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Ben Marks Magento \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Chuck Burgess PEAR \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Totals : 13/3 15/1 15/1 13/3 14/2 15/1 14/2 15/1 14/2 14/2 15/1 16/0 15/1 15/1 15/1","title":"4.4.1. PHP-FIG Representative Results"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#442-general-non-representative-voters","text":"Question For Against Percentage For Compound namespaces required depth 114 12 89.47% Header statement grouping and ordering 113 13 88.5% Declare statements must each be on their own line 120 6 95% Declare statements in PHP files containing markup 119 7 94.12% Declare statements have no spaces 116 10 91.38% Block declare statement formatting 118 8 93.22% new keyword usage, parenthesis required 116 10 91.38% Return type declaration formatting 115 11 90.43% Use statement leading slashes disallowed 118 8 93.22% Block namespace declaration formatting 120 6 95% General operator spacing 123 3 97.56% Try, Catch, Finally formatting 124 2 98.39% Anonymous class declaration formatting 117 9 92.31% Keyword casing, only lower case 124 2 98.39% Type keywords, short form only 121 5 95.87%","title":"4.4.2. General non-representative voters"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#45-multiline-function-arguments-mixed-with-multiline-return","text":"A potential readability issue was raised on the mailing list . We reviewed options for changes to the specification that could provide better readability and the floated option was to require a blank line after the opening bracket of a function if the arguments and the return are both multiline. Instead it was pointed out that this specification already allows you to decide where you'd like to add blank lines and so we will leave it to the implementors to decide.","title":"4.5. Multiline Function Arguments Mixed With Multiline Return"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#5-changelog-from-psr-2","text":"Please note this changelog is not a verbose list of changes from PSR-2 but highlights the most notable changes. It should be considered a new specification and therefore you should read the specification for a full understanding of its contents.","title":"5. Changelog from PSR-2"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#51-new-statements","text":"Lowercase for all keywords - Section 2.5 Short form for all type keywords - Section 2.5 Use statement grouping - Section 3 Use statement blocks - Section 3 Declare statement/Strict types declaration usage - Section 3 Parentheses are always required for class instantiation - Section 4 Typed properties - Section 4.3 Return type declarations - Section 4.5 Variadic and reference argument operators - Section 4.5 Type hints - Section 4.5 Add finally block - Section 5.6 Operators - Section 6 Unary operators - Section 6.1 Binary operators - Section 6.2 Ternary operators - Section 6.3 Anonymous classes - Section 8","title":"5.1. New Statements"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#52-clarifications-and-errata","text":"Adjust 'methods' to 'methods and functions' in a number of instances - Throughout Adjust references to classes and interfaces to also include traits - Throughout StudlyCaps meaning clarified as PascalCase - Section 2.1 The last line should not be blank but contain an EOL character - Section 2.2 Blank lines may be added for readability except where explicitly forbidden within the PSR - Section 2.3 PSR-2 errata statement about multi-line arguments - Section 4 PSR-2 errata statement about extending multiple interfaces - Section 4 Forbid blank lines before/after closing/opening braces for classes - Section 4","title":"5.2. Clarifications and Errata"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#6-people","text":"","title":"6. People"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#61-editor","text":"Korvin Szanto","title":"6.1.  Editor:"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#62-sponsor","text":"Chris Tankersley","title":"6.2. Sponsor:"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#63-working-group-members","text":"Alessandro Lai Alexander Makarov Michael Cullum Robert Deutz","title":"6.3. Working Group Members:"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#64-special-thanks","text":"Michael Cullum for drafting the original specification Alexandar Makarov for coordinating the draft during PHP-FIG 2.0 Cees-Jan Kiewiet for moral support","title":"6.4. Special Thanks"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#7-votes","text":"Entrance Vote: https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!msg/php-fig/P9atZLOcUBM/_jwkvlYKEAAJ Approval Vote: https://groups.google.com/forum/#!topic/php-fig/1uaeSMaDGbk","title":"7. Votes"},{"location":"accepted/PSR-12-extended-coding-style-guide-meta/#8-relevant-links","text":"Note: Order descending chronologically. Inspiration Mailing List Thread Initial Mailing List PSR Proposal Thread","title":"8. Relevant Links"},{"location":"accepted/PSR-12-extended-coding-style-guide/","text":"Extended Coding Style Guide The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . Overview This specification extends, expands and replaces PSR-2 , the coding style guide and requires adherence to PSR-1 , the basic coding standard. Like PSR-2 , the intent of this specification is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code. This PSR seeks to provide a set way that coding style tools can implement, projects can declare adherence to and developers can easily relate to between different projects. When various authors collaborate across multiple projects, it helps to have one set of guidelines to be used among all those projects. Thus, the benefit of this guide is not in the rules themselves but the sharing of those rules. PSR-2 was accepted in 2012 and since then a number of changes have been made to PHP which has implications for coding style guidelines. Whilst PSR-2 is very comprehensive of PHP functionality that existed at the time of writing, new functionality is very open to interpretation. This PSR, therefore, seeks to clarify the content of PSR-2 in a more modern context with new functionality available, and make the errata to PSR-2 binding. Previous language versions Throughout this document, any instructions MAY be ignored if they do not exist in versions of PHP supported by your project. Example This example encompasses some of the rules below as a quick overview: <?php declare(strict_types=1); namespace Vendor\\Package; use Vendor\\Package\\{ClassA as A, ClassB, ClassC as C}; use Vendor\\Package\\SomeNamespace\\ClassD as D; use function Vendor\\Package\\{functionA, functionB, functionC}; use const Vendor\\Package\\{ConstantA, ConstantB, ConstantC}; class Foo extends Bar implements FooInterface { public function sampleFunction(int $a, int $b = null): array { if ($a === $b) { bar(); } elseif ($a > $b) { $foo->bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static function bar() { // method body } } 2. General 2.1 Basic Coding Standard Code MUST follow all rules outlined in PSR-1 . The term 'StudlyCaps' in PSR-1 MUST be interpreted as PascalCase where the first letter of each word is capitalized including the very first letter. 2.2 Files All PHP files MUST use the Unix LF (linefeed) line ending only. All PHP files MUST end with a non-blank line, terminated with a single LF. The closing ?> tag MUST be omitted from files containing only PHP. 2.3 Lines There MUST NOT be a hard limit on line length. The soft limit on line length MUST be 120 characters. Lines SHOULD NOT be longer than 80 characters; lines longer than that SHOULD be split into multiple subsequent lines of no more than 80 characters each. There MUST NOT be trailing whitespace at the end of lines. Blank lines MAY be added to improve readability and to indicate related blocks of code except where explicitly forbidden. There MUST NOT be more than one statement per line. 2.4 Indenting Code MUST use an indent of 4 spaces for each indent level, and MUST NOT use tabs for indenting. 2.5 Keywords and Types All PHP reserved keywords and types [1] [2] MUST be in lower case. Any new types and keywords added to future PHP versions MUST be in lower case. Short form of type keywords MUST be used i.e. bool instead of boolean , int instead of integer etc. 3. Declare Statements, Namespace, and Import Statements The header of a PHP file may consist of a number of different blocks. If present, each of the blocks below MUST be separated by a single blank line, and MUST NOT contain a blank line. Each block MUST be in the order listed below, although blocks that are not relevant may be omitted. Opening <?php tag. File-level docblock. One or more declare statements. The namespace declaration of the file. One or more class-based use import statements. One or more function-based use import statements. One or more constant-based use import statements. The remainder of the code in the file. When a file contains a mix of HTML and PHP, any of the above sections may still be used. If so, they MUST be present at the top of the file, even if the remainder of the code consists of a closing PHP tag and then a mixture of HTML and PHP. When the opening <?php tag is on the first line of the file, it MUST be on its own line with no other statements unless it is a file containing markup outside of PHP opening and closing tags. Import statements MUST never begin with a leading backslash as they must always be fully qualified. The following example illustrates a complete list of all blocks: <?php /** * This file contains an example of coding styles. */ declare(strict_types=1); namespace Vendor\\Package; use Vendor\\Package\\{ClassA as A, ClassB, ClassC as C}; use Vendor\\Package\\SomeNamespace\\ClassD as D; use Vendor\\Package\\AnotherNamespace\\ClassE as E; use function Vendor\\Package\\{functionA, functionB, functionC}; use function Another\\Vendor\\functionD; use const Vendor\\Package\\{CONSTANT_A, CONSTANT_B, CONSTANT_C}; use const Another\\Vendor\\CONSTANT_D; /** * FooBar is an example class. */ class FooBar { // ... additional PHP code ... } Compound namespaces with a depth of more than two MUST NOT be used. Therefore the following is the maximum compounding depth allowed: <?php use Vendor\\Package\\SomeNamespace\\{ SubnamespaceOne\\ClassA, SubnamespaceOne\\ClassB, SubnamespaceTwo\\ClassY, ClassZ, }; And the following would not be allowed: <?php use Vendor\\Package\\SomeNamespace\\{ SubnamespaceOne\\AnotherNamespace\\ClassA, SubnamespaceOne\\ClassB, ClassZ, }; When wishing to declare strict types in files containing markup outside PHP opening and closing tags, the declaration MUST be on the first line of the file and include an opening PHP tag, the strict types declaration and closing tag. For example: <?php declare(strict_types=1) ?> <html> <body> <?php // ... additional PHP code ... ?> </body> </html> Declare statements MUST contain no spaces and MUST be exactly declare(strict_types=1) (with an optional semi-colon terminator). Block declare statements are allowed and MUST be formatted as below. Note position of braces and spacing: declare(ticks=1) { // some code } 4. Classes, Properties, and Methods The term \"class\" refers to all classes, interfaces, and traits. Any closing brace MUST NOT be followed by any comment or statement on the same line. When instantiating a new class, parentheses MUST always be present even when there are no arguments passed to the constructor. new Foo(); 4.1 Extends and Implements The extends and implements keywords MUST be declared on the same line as the class name. The opening brace for the class MUST go on its own line; the closing brace for the class MUST go on the next line after the body. Opening braces MUST be on their own line and MUST NOT be preceded or followed by a blank line. Closing braces MUST be on their own line and MUST NOT be preceded by a blank line. <?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class ClassName extends ParentClass implements \\ArrayAccess, \\Countable { // constants, properties, methods } Lists of implements and, in the case of interfaces, extends MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one interface per line. <?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class ClassName extends ParentClass implements \\ArrayAccess, \\Countable, \\Serializable { // constants, properties, methods } 4.2 Using traits The use keyword used inside the classes to implement traits MUST be declared on the next line after the opening brace. <?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; class ClassName { use FirstTrait; } Each individual trait that is imported into a class MUST be included one-per-line and each inclusion MUST have its own use import statement. <?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; use Vendor\\Package\\SecondTrait; use Vendor\\Package\\ThirdTrait; class ClassName { use FirstTrait; use SecondTrait; use ThirdTrait; } When the class has nothing after the use import statement, the class closing brace MUST be on the next line after the use import statement. <?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; class ClassName { use FirstTrait; } Otherwise, it MUST have a blank line after the use import statement. <?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; class ClassName { use FirstTrait; private $property; } When using the insteadof and as operators they must be used as follows taking note of indentation, spacing, and new lines. <?php class Talker { use A; use B { A::smallTalk insteadof B; } use C { B::bigTalk insteadof C; C::mediumTalk as FooBar; } } 4.3 Properties and Constants Visibility MUST be declared on all properties. Visibility MUST be declared on all constants if your project PHP minimum version supports constant visibilities (PHP 7.1 or later). The var keyword MUST NOT be used to declare a property. There MUST NOT be more than one property declared per statement. Property names MUST NOT be prefixed with a single underscore to indicate protected or private visibility. That is, an underscore prefix explicitly has no meaning. There MUST be a space between type declaration and property name. A property declaration looks like the following: <?php namespace Vendor\\Package; class ClassName { public $foo = null; public static int $bar = 0; } 4.4 Methods and Functions Visibility MUST be declared on all methods. Method names MUST NOT be prefixed with a single underscore to indicate protected or private visibility. That is, an underscore prefix explicitly has no meaning. Method and function names MUST NOT be declared with space after the method name. The opening brace MUST go on its own line, and the closing brace MUST go on the next line following the body. There MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis. A method declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces: <?php namespace Vendor\\Package; class ClassName { public function fooBarBaz($arg1, &$arg2, $arg3 = []) { // method body } } A function declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces: <?php function fooBarBaz($arg1, &$arg2, $arg3 = []) { // function body } 4.5 Method and Function Arguments In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. Method and function arguments with default values MUST go at the end of the argument list. <?php namespace Vendor\\Package; class ClassName { public function foo(int $arg1, &$arg2, $arg3 = []) { // method body } } Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line. When the argument list is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them. <?php namespace Vendor\\Package; class ClassName { public function aVeryLongMethodName( ClassTypeHint $arg1, &$arg2, array $arg3 = [] ) { // method body } } When you have a return type declaration present, there MUST be one space after the colon followed by the type declaration. The colon and declaration MUST be on the same line as the argument list closing parenthesis with no spaces between the two characters. <?php declare(strict_types=1); namespace Vendor\\Package; class ReturnTypeVariations { public function functionName(int $arg1, $arg2): string { return 'foo'; } public function anotherFunction( string $foo, string $bar, int $baz ): string { return 'foo'; } } In nullable type declarations, there MUST NOT be a space between the question mark and the type. <?php declare(strict_types=1); namespace Vendor\\Package; class ReturnTypeVariations { public function functionName(?string $arg1, ?int &$arg2): ?string { return 'foo'; } } When using the reference operator & before an argument, there MUST NOT be a space after it, like in the previous example. There MUST NOT be a space between the variadic three dot operator and the argument name: public function process(string $algorithm, ...$parts) { // processing } When combining both the reference operator and the variadic three dot operator, there MUST NOT be any space between the two of them: public function process(string $algorithm, &...$parts) { // processing } 4.6 abstract , final , and static When present, the abstract and final declarations MUST precede the visibility declaration. When present, the static declaration MUST come after the visibility declaration. <?php namespace Vendor\\Package; abstract class ClassName { protected static $foo; abstract protected function zim(); final public static function bar() { // method body } } 4.7 Method and Function Calls When making a method or function call, there MUST NOT be a space between the method or function name and the opening parenthesis, there MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis. In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. <?php bar(); $foo->bar($arg1); Foo::bar($arg2, $arg3); Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line. A single argument being split across multiple lines (as might be the case with an anonymous function or array) does not constitute splitting the argument list itself. <?php $foo->bar( $longArgument, $longerArgument, $muchLongerArgument ); <?php somefunction($foo, $bar, [ // ... ], $baz); $app->get('/hello/{name}', function ($name) use ($app) { return 'Hello ' . $app->escape($name); }); 5. Control Structures The general style rules for control structures are as follows: There MUST be one space after the control structure keyword There MUST NOT be a space after the opening parenthesis There MUST NOT be a space before the closing parenthesis There MUST be one space between the closing parenthesis and the opening brace The structure body MUST be indented once The body MUST be on the next line after the opening brace The closing brace MUST be on the next line after the body The body of each structure MUST be enclosed by braces. This standardizes how the structures look and reduces the likelihood of introducing errors as new lines get added to the body. 5.1 if , elseif , else An if structure looks like the following. Note the placement of parentheses, spaces, and braces; and that else and elseif are on the same line as the closing brace from the earlier body. <?php if ($expr1) { // if body } elseif ($expr2) { // elseif body } else { // else body; } The keyword elseif SHOULD be used instead of else if so that all control keywords look like single words. Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both. <?php if ( $expr1 && $expr2 ) { // if body } elseif ( $expr3 && $expr4 ) { // elseif body } 5.2 switch , case A switch structure looks like the following. Note the placement of parentheses, spaces, and braces. The case statement MUST be indented once from switch , and the break keyword (or other terminating keywords) MUST be indented at the same level as the case body. There MUST be a comment such as // no break when fall-through is intentional in a non-empty case body. <?php switch ($expr) { case 0: echo 'First case, with a break'; break; case 1: echo 'Second case, which falls through'; // no break case 2: case 3: case 4: echo 'Third case, return instead of break'; return; default: echo 'Default case'; break; } Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both. <?php switch ( $expr1 && $expr2 ) { // structure body } 5.3 while , do while A while statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php while ($expr) { // structure body } Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both. <?php while ( $expr1 && $expr2 ) { // structure body } Similarly, a do while statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php do { // structure body; } while ($expr); Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both. <?php do { // structure body; } while ( $expr1 && $expr2 ); 5.4 for A for statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php for ($i = 0; $i < 10; $i++) { // for body } Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first expression MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. <?php for ( $i = 0; $i < 10; $i++ ) { // for body } 5.5 foreach A foreach statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php foreach ($iterable as $key => $value) { // foreach body } 5.6 try , catch , finally A try-catch-finally block looks like the following. Note the placement of parentheses, spaces, and braces. <?php try { // try body } catch (FirstThrowableType $e) { // catch body } catch (OtherThrowableType | AnotherThrowableType $e) { // catch body } finally { // finally body } 6. Operators Style rules for operators are grouped by arity (the number of operands they take). When space is permitted around an operator, multiple spaces MAY be used for readability purposes. All operators not described here are left undefined. 6.1. Unary operators The increment/decrement operators MUST NOT have any space between the operator and operand. $i++; ++$j; Type casting operators MUST NOT have any space within the parentheses: $intValue = (int) $input; 6.2. Binary operators All binary arithmetic , comparison , assignment , bitwise , logical , string , and type operators MUST be preceded and followed by at least one space: if ($a === $b) { $foo = $bar ?? $a ?? $b; } elseif ($a > $b) { $foo = $a + $b * $c; } 6.3. Ternary operators The conditional operator, also known simply as the ternary operator, MUST be preceded and followed by at least one space around both the ? and : characters: $variable = $foo ? 'foo' : 'bar'; When the middle operand of the conditional operator is omitted, the operator MUST follow the same style rules as other binary comparison operators: $variable = $foo ?: 'bar'; 7. Closures Closures MUST be declared with a space after the function keyword, and a space before and after the use keyword. The opening brace MUST go on the same line, and the closing brace MUST go on the next line following the body. There MUST NOT be a space after the opening parenthesis of the argument list or variable list, and there MUST NOT be a space before the closing parenthesis of the argument list or variable list. In the argument list and variable list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. Closure arguments with default values MUST go at the end of the argument list. If a return type is present, it MUST follow the same rules as with normal functions and methods; if the use keyword is present, the colon MUST follow the use list closing parentheses with no spaces between the two characters. A closure declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces: <?php $closureWithArgs = function ($arg1, $arg2) { // body }; $closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) { // body }; $closureWithArgsVarsAndReturn = function ($arg1, $arg2) use ($var1, $var2): bool { // body }; Argument lists and variable lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument or variable per line. When the ending list (whether of arguments or variables) is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them. The following are examples of closures with and without argument lists and variable lists split across multiple lines. <?php $longArgs_noVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) { // body }; $noArgs_longVars = function () use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_longVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_shortVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ($var1) { // body }; $shortArgs_longVars = function ($arg) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; Note that the formatting rules also apply when the closure is used directly in a function or method call as an argument. <?php $foo->bar( $arg1, function ($arg2) use ($var1) { // body }, $arg3 ); 8. Anonymous Classes Anonymous Classes MUST follow the same guidelines and principles as closures in the above section. <?php $instance = new class {}; The opening brace MAY be on the same line as the class keyword so long as the list of implements interfaces does not wrap. If the list of interfaces wraps, the brace MUST be placed on the line immediately following the last interface. <?php // Brace on the same line $instance = new class extends \\Foo implements \\HandleableInterface { // Class content }; // Brace on the next line $instance = new class extends \\Foo implements \\ArrayAccess, \\Countable, \\Serializable { // Class content };","title":"Extended Coding Style Guide"},{"location":"accepted/PSR-12-extended-coding-style-guide/#extended-coding-style-guide","text":"The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"Extended Coding Style Guide"},{"location":"accepted/PSR-12-extended-coding-style-guide/#overview","text":"This specification extends, expands and replaces PSR-2 , the coding style guide and requires adherence to PSR-1 , the basic coding standard. Like PSR-2 , the intent of this specification is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code. This PSR seeks to provide a set way that coding style tools can implement, projects can declare adherence to and developers can easily relate to between different projects. When various authors collaborate across multiple projects, it helps to have one set of guidelines to be used among all those projects. Thus, the benefit of this guide is not in the rules themselves but the sharing of those rules. PSR-2 was accepted in 2012 and since then a number of changes have been made to PHP which has implications for coding style guidelines. Whilst PSR-2 is very comprehensive of PHP functionality that existed at the time of writing, new functionality is very open to interpretation. This PSR, therefore, seeks to clarify the content of PSR-2 in a more modern context with new functionality available, and make the errata to PSR-2 binding.","title":"Overview"},{"location":"accepted/PSR-12-extended-coding-style-guide/#previous-language-versions","text":"Throughout this document, any instructions MAY be ignored if they do not exist in versions of PHP supported by your project.","title":"Previous language versions"},{"location":"accepted/PSR-12-extended-coding-style-guide/#example","text":"This example encompasses some of the rules below as a quick overview: <?php declare(strict_types=1); namespace Vendor\\Package; use Vendor\\Package\\{ClassA as A, ClassB, ClassC as C}; use Vendor\\Package\\SomeNamespace\\ClassD as D; use function Vendor\\Package\\{functionA, functionB, functionC}; use const Vendor\\Package\\{ConstantA, ConstantB, ConstantC}; class Foo extends Bar implements FooInterface { public function sampleFunction(int $a, int $b = null): array { if ($a === $b) { bar(); } elseif ($a > $b) { $foo->bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static function bar() { // method body } }","title":"Example"},{"location":"accepted/PSR-12-extended-coding-style-guide/#2-general","text":"","title":"2. General"},{"location":"accepted/PSR-12-extended-coding-style-guide/#21-basic-coding-standard","text":"Code MUST follow all rules outlined in PSR-1 . The term 'StudlyCaps' in PSR-1 MUST be interpreted as PascalCase where the first letter of each word is capitalized including the very first letter.","title":"2.1 Basic Coding Standard"},{"location":"accepted/PSR-12-extended-coding-style-guide/#22-files","text":"All PHP files MUST use the Unix LF (linefeed) line ending only. All PHP files MUST end with a non-blank line, terminated with a single LF. The closing ?> tag MUST be omitted from files containing only PHP.","title":"2.2 Files"},{"location":"accepted/PSR-12-extended-coding-style-guide/#23-lines","text":"There MUST NOT be a hard limit on line length. The soft limit on line length MUST be 120 characters. Lines SHOULD NOT be longer than 80 characters; lines longer than that SHOULD be split into multiple subsequent lines of no more than 80 characters each. There MUST NOT be trailing whitespace at the end of lines. Blank lines MAY be added to improve readability and to indicate related blocks of code except where explicitly forbidden. There MUST NOT be more than one statement per line.","title":"2.3 Lines"},{"location":"accepted/PSR-12-extended-coding-style-guide/#24-indenting","text":"Code MUST use an indent of 4 spaces for each indent level, and MUST NOT use tabs for indenting.","title":"2.4 Indenting"},{"location":"accepted/PSR-12-extended-coding-style-guide/#25-keywords-and-types","text":"All PHP reserved keywords and types [1] [2] MUST be in lower case. Any new types and keywords added to future PHP versions MUST be in lower case. Short form of type keywords MUST be used i.e. bool instead of boolean , int instead of integer etc.","title":"2.5 Keywords and Types"},{"location":"accepted/PSR-12-extended-coding-style-guide/#3-declare-statements-namespace-and-import-statements","text":"The header of a PHP file may consist of a number of different blocks. If present, each of the blocks below MUST be separated by a single blank line, and MUST NOT contain a blank line. Each block MUST be in the order listed below, although blocks that are not relevant may be omitted. Opening <?php tag. File-level docblock. One or more declare statements. The namespace declaration of the file. One or more class-based use import statements. One or more function-based use import statements. One or more constant-based use import statements. The remainder of the code in the file. When a file contains a mix of HTML and PHP, any of the above sections may still be used. If so, they MUST be present at the top of the file, even if the remainder of the code consists of a closing PHP tag and then a mixture of HTML and PHP. When the opening <?php tag is on the first line of the file, it MUST be on its own line with no other statements unless it is a file containing markup outside of PHP opening and closing tags. Import statements MUST never begin with a leading backslash as they must always be fully qualified. The following example illustrates a complete list of all blocks: <?php /** * This file contains an example of coding styles. */ declare(strict_types=1); namespace Vendor\\Package; use Vendor\\Package\\{ClassA as A, ClassB, ClassC as C}; use Vendor\\Package\\SomeNamespace\\ClassD as D; use Vendor\\Package\\AnotherNamespace\\ClassE as E; use function Vendor\\Package\\{functionA, functionB, functionC}; use function Another\\Vendor\\functionD; use const Vendor\\Package\\{CONSTANT_A, CONSTANT_B, CONSTANT_C}; use const Another\\Vendor\\CONSTANT_D; /** * FooBar is an example class. */ class FooBar { // ... additional PHP code ... } Compound namespaces with a depth of more than two MUST NOT be used. Therefore the following is the maximum compounding depth allowed: <?php use Vendor\\Package\\SomeNamespace\\{ SubnamespaceOne\\ClassA, SubnamespaceOne\\ClassB, SubnamespaceTwo\\ClassY, ClassZ, }; And the following would not be allowed: <?php use Vendor\\Package\\SomeNamespace\\{ SubnamespaceOne\\AnotherNamespace\\ClassA, SubnamespaceOne\\ClassB, ClassZ, }; When wishing to declare strict types in files containing markup outside PHP opening and closing tags, the declaration MUST be on the first line of the file and include an opening PHP tag, the strict types declaration and closing tag. For example: <?php declare(strict_types=1) ?> <html> <body> <?php // ... additional PHP code ... ?> </body> </html> Declare statements MUST contain no spaces and MUST be exactly declare(strict_types=1) (with an optional semi-colon terminator). Block declare statements are allowed and MUST be formatted as below. Note position of braces and spacing: declare(ticks=1) { // some code }","title":"3. Declare Statements, Namespace, and Import Statements"},{"location":"accepted/PSR-12-extended-coding-style-guide/#4-classes-properties-and-methods","text":"The term \"class\" refers to all classes, interfaces, and traits. Any closing brace MUST NOT be followed by any comment or statement on the same line. When instantiating a new class, parentheses MUST always be present even when there are no arguments passed to the constructor. new Foo();","title":"4. Classes, Properties, and Methods"},{"location":"accepted/PSR-12-extended-coding-style-guide/#41-extends-and-implements","text":"The extends and implements keywords MUST be declared on the same line as the class name. The opening brace for the class MUST go on its own line; the closing brace for the class MUST go on the next line after the body. Opening braces MUST be on their own line and MUST NOT be preceded or followed by a blank line. Closing braces MUST be on their own line and MUST NOT be preceded by a blank line. <?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class ClassName extends ParentClass implements \\ArrayAccess, \\Countable { // constants, properties, methods } Lists of implements and, in the case of interfaces, extends MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one interface per line. <?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class ClassName extends ParentClass implements \\ArrayAccess, \\Countable, \\Serializable { // constants, properties, methods }","title":"4.1 Extends and Implements"},{"location":"accepted/PSR-12-extended-coding-style-guide/#42-using-traits","text":"The use keyword used inside the classes to implement traits MUST be declared on the next line after the opening brace. <?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; class ClassName { use FirstTrait; } Each individual trait that is imported into a class MUST be included one-per-line and each inclusion MUST have its own use import statement. <?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; use Vendor\\Package\\SecondTrait; use Vendor\\Package\\ThirdTrait; class ClassName { use FirstTrait; use SecondTrait; use ThirdTrait; } When the class has nothing after the use import statement, the class closing brace MUST be on the next line after the use import statement. <?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; class ClassName { use FirstTrait; } Otherwise, it MUST have a blank line after the use import statement. <?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; class ClassName { use FirstTrait; private $property; } When using the insteadof and as operators they must be used as follows taking note of indentation, spacing, and new lines. <?php class Talker { use A; use B { A::smallTalk insteadof B; } use C { B::bigTalk insteadof C; C::mediumTalk as FooBar; } }","title":"4.2 Using traits"},{"location":"accepted/PSR-12-extended-coding-style-guide/#43-properties-and-constants","text":"Visibility MUST be declared on all properties. Visibility MUST be declared on all constants if your project PHP minimum version supports constant visibilities (PHP 7.1 or later). The var keyword MUST NOT be used to declare a property. There MUST NOT be more than one property declared per statement. Property names MUST NOT be prefixed with a single underscore to indicate protected or private visibility. That is, an underscore prefix explicitly has no meaning. There MUST be a space between type declaration and property name. A property declaration looks like the following: <?php namespace Vendor\\Package; class ClassName { public $foo = null; public static int $bar = 0; }","title":"4.3 Properties and Constants"},{"location":"accepted/PSR-12-extended-coding-style-guide/#44-methods-and-functions","text":"Visibility MUST be declared on all methods. Method names MUST NOT be prefixed with a single underscore to indicate protected or private visibility. That is, an underscore prefix explicitly has no meaning. Method and function names MUST NOT be declared with space after the method name. The opening brace MUST go on its own line, and the closing brace MUST go on the next line following the body. There MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis. A method declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces: <?php namespace Vendor\\Package; class ClassName { public function fooBarBaz($arg1, &$arg2, $arg3 = []) { // method body } } A function declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces: <?php function fooBarBaz($arg1, &$arg2, $arg3 = []) { // function body }","title":"4.4 Methods and Functions"},{"location":"accepted/PSR-12-extended-coding-style-guide/#45-method-and-function-arguments","text":"In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. Method and function arguments with default values MUST go at the end of the argument list. <?php namespace Vendor\\Package; class ClassName { public function foo(int $arg1, &$arg2, $arg3 = []) { // method body } } Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line. When the argument list is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them. <?php namespace Vendor\\Package; class ClassName { public function aVeryLongMethodName( ClassTypeHint $arg1, &$arg2, array $arg3 = [] ) { // method body } } When you have a return type declaration present, there MUST be one space after the colon followed by the type declaration. The colon and declaration MUST be on the same line as the argument list closing parenthesis with no spaces between the two characters. <?php declare(strict_types=1); namespace Vendor\\Package; class ReturnTypeVariations { public function functionName(int $arg1, $arg2): string { return 'foo'; } public function anotherFunction( string $foo, string $bar, int $baz ): string { return 'foo'; } } In nullable type declarations, there MUST NOT be a space between the question mark and the type. <?php declare(strict_types=1); namespace Vendor\\Package; class ReturnTypeVariations { public function functionName(?string $arg1, ?int &$arg2): ?string { return 'foo'; } } When using the reference operator & before an argument, there MUST NOT be a space after it, like in the previous example. There MUST NOT be a space between the variadic three dot operator and the argument name: public function process(string $algorithm, ...$parts) { // processing } When combining both the reference operator and the variadic three dot operator, there MUST NOT be any space between the two of them: public function process(string $algorithm, &...$parts) { // processing }","title":"4.5 Method and Function Arguments"},{"location":"accepted/PSR-12-extended-coding-style-guide/#46-abstract-final-and-static","text":"When present, the abstract and final declarations MUST precede the visibility declaration. When present, the static declaration MUST come after the visibility declaration. <?php namespace Vendor\\Package; abstract class ClassName { protected static $foo; abstract protected function zim(); final public static function bar() { // method body } }","title":"4.6 abstract, final, and static"},{"location":"accepted/PSR-12-extended-coding-style-guide/#47-method-and-function-calls","text":"When making a method or function call, there MUST NOT be a space between the method or function name and the opening parenthesis, there MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis. In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. <?php bar(); $foo->bar($arg1); Foo::bar($arg2, $arg3); Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line. A single argument being split across multiple lines (as might be the case with an anonymous function or array) does not constitute splitting the argument list itself. <?php $foo->bar( $longArgument, $longerArgument, $muchLongerArgument ); <?php somefunction($foo, $bar, [ // ... ], $baz); $app->get('/hello/{name}', function ($name) use ($app) { return 'Hello ' . $app->escape($name); });","title":"4.7 Method and Function Calls"},{"location":"accepted/PSR-12-extended-coding-style-guide/#5-control-structures","text":"The general style rules for control structures are as follows: There MUST be one space after the control structure keyword There MUST NOT be a space after the opening parenthesis There MUST NOT be a space before the closing parenthesis There MUST be one space between the closing parenthesis and the opening brace The structure body MUST be indented once The body MUST be on the next line after the opening brace The closing brace MUST be on the next line after the body The body of each structure MUST be enclosed by braces. This standardizes how the structures look and reduces the likelihood of introducing errors as new lines get added to the body.","title":"5. Control Structures"},{"location":"accepted/PSR-12-extended-coding-style-guide/#51-if-elseif-else","text":"An if structure looks like the following. Note the placement of parentheses, spaces, and braces; and that else and elseif are on the same line as the closing brace from the earlier body. <?php if ($expr1) { // if body } elseif ($expr2) { // elseif body } else { // else body; } The keyword elseif SHOULD be used instead of else if so that all control keywords look like single words. Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both. <?php if ( $expr1 && $expr2 ) { // if body } elseif ( $expr3 && $expr4 ) { // elseif body }","title":"5.1 if, elseif, else"},{"location":"accepted/PSR-12-extended-coding-style-guide/#52-switch-case","text":"A switch structure looks like the following. Note the placement of parentheses, spaces, and braces. The case statement MUST be indented once from switch , and the break keyword (or other terminating keywords) MUST be indented at the same level as the case body. There MUST be a comment such as // no break when fall-through is intentional in a non-empty case body. <?php switch ($expr) { case 0: echo 'First case, with a break'; break; case 1: echo 'Second case, which falls through'; // no break case 2: case 3: case 4: echo 'Third case, return instead of break'; return; default: echo 'Default case'; break; } Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both. <?php switch ( $expr1 && $expr2 ) { // structure body }","title":"5.2 switch, case"},{"location":"accepted/PSR-12-extended-coding-style-guide/#53-while-do-while","text":"A while statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php while ($expr) { // structure body } Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both. <?php while ( $expr1 && $expr2 ) { // structure body } Similarly, a do while statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php do { // structure body; } while ($expr); Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both. <?php do { // structure body; } while ( $expr1 && $expr2 );","title":"5.3 while, do while"},{"location":"accepted/PSR-12-extended-coding-style-guide/#54-for","text":"A for statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php for ($i = 0; $i < 10; $i++) { // for body } Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first expression MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. <?php for ( $i = 0; $i < 10; $i++ ) { // for body }","title":"5.4 for"},{"location":"accepted/PSR-12-extended-coding-style-guide/#55-foreach","text":"A foreach statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php foreach ($iterable as $key => $value) { // foreach body }","title":"5.5 foreach"},{"location":"accepted/PSR-12-extended-coding-style-guide/#56-try-catch-finally","text":"A try-catch-finally block looks like the following. Note the placement of parentheses, spaces, and braces. <?php try { // try body } catch (FirstThrowableType $e) { // catch body } catch (OtherThrowableType | AnotherThrowableType $e) { // catch body } finally { // finally body }","title":"5.6 try, catch, finally"},{"location":"accepted/PSR-12-extended-coding-style-guide/#6-operators","text":"Style rules for operators are grouped by arity (the number of operands they take). When space is permitted around an operator, multiple spaces MAY be used for readability purposes. All operators not described here are left undefined.","title":"6. Operators"},{"location":"accepted/PSR-12-extended-coding-style-guide/#61-unary-operators","text":"The increment/decrement operators MUST NOT have any space between the operator and operand. $i++; ++$j; Type casting operators MUST NOT have any space within the parentheses: $intValue = (int) $input;","title":"6.1. Unary operators"},{"location":"accepted/PSR-12-extended-coding-style-guide/#62-binary-operators","text":"All binary arithmetic , comparison , assignment , bitwise , logical , string , and type operators MUST be preceded and followed by at least one space: if ($a === $b) { $foo = $bar ?? $a ?? $b; } elseif ($a > $b) { $foo = $a + $b * $c; }","title":"6.2. Binary operators"},{"location":"accepted/PSR-12-extended-coding-style-guide/#63-ternary-operators","text":"The conditional operator, also known simply as the ternary operator, MUST be preceded and followed by at least one space around both the ? and : characters: $variable = $foo ? 'foo' : 'bar'; When the middle operand of the conditional operator is omitted, the operator MUST follow the same style rules as other binary comparison operators: $variable = $foo ?: 'bar';","title":"6.3. Ternary operators"},{"location":"accepted/PSR-12-extended-coding-style-guide/#7-closures","text":"Closures MUST be declared with a space after the function keyword, and a space before and after the use keyword. The opening brace MUST go on the same line, and the closing brace MUST go on the next line following the body. There MUST NOT be a space after the opening parenthesis of the argument list or variable list, and there MUST NOT be a space before the closing parenthesis of the argument list or variable list. In the argument list and variable list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. Closure arguments with default values MUST go at the end of the argument list. If a return type is present, it MUST follow the same rules as with normal functions and methods; if the use keyword is present, the colon MUST follow the use list closing parentheses with no spaces between the two characters. A closure declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces: <?php $closureWithArgs = function ($arg1, $arg2) { // body }; $closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) { // body }; $closureWithArgsVarsAndReturn = function ($arg1, $arg2) use ($var1, $var2): bool { // body }; Argument lists and variable lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument or variable per line. When the ending list (whether of arguments or variables) is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them. The following are examples of closures with and without argument lists and variable lists split across multiple lines. <?php $longArgs_noVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) { // body }; $noArgs_longVars = function () use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_longVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_shortVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ($var1) { // body }; $shortArgs_longVars = function ($arg) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; Note that the formatting rules also apply when the closure is used directly in a function or method call as an argument. <?php $foo->bar( $arg1, function ($arg2) use ($var1) { // body }, $arg3 );","title":"7. Closures"},{"location":"accepted/PSR-12-extended-coding-style-guide/#8-anonymous-classes","text":"Anonymous Classes MUST follow the same guidelines and principles as closures in the above section. <?php $instance = new class {}; The opening brace MAY be on the same line as the class keyword so long as the list of implements interfaces does not wrap. If the list of interfaces wraps, the brace MUST be placed on the line immediately following the last interface. <?php // Brace on the same line $instance = new class extends \\Foo implements \\HandleableInterface { // Class content }; // Brace on the next line $instance = new class extends \\Foo implements \\ArrayAccess, \\Countable, \\Serializable { // Class content };","title":"8. Anonymous Classes"},{"location":"accepted/PSR-13-links-meta/","text":"Link Definition Meta Document 1. Summary Hypermedia links are becoming an increasingly important part of the web, in both HTML contexts and various API format contexts. However, there is no single common hypermedia format, nor is there a common way to represent Links between formats. This specification aims to provide PHP developers with a simple, common way of representing a hypermedia link independently of the serialization format that is used. That in turn allows a system to serialize a response with hypermedia links into one or more wire formats independently of the process of deciding what those links should be. 2. Scope 2.1 Goals This specification aims to extract and standardize hypermedia link representation between different formats. 2.2 Non-Goals This specification does not seek to standardize or favor any particular hypermedia serialization format. 3. Design Decisions Why no mutator methods? One of the key targets for this specification is PSR-7 Response objects. Response objects by design must be immutable. Other value-object implementations likely would also require an immutable interface. Additionally, some Link Provider objects may not be value objects but other objects within a given domain, which are able to generate Links on the fly, perhaps off of a database result or other underlying representation. In those cases a writeable provider definition would be incompatible. Therefore, this specification splits accessor methods and evolvable methods into separate interfaces, allowing objects to implement just the read-only or evolvable versions as appropriate to their use case. Why is rel on a Link object multi-value? Different hypermedia standards handle multiple links with the same relationship differently. Some have a single link that has multiple rel's defined. Others have a single rel entry that then contains multiple links. Defining each Link uniquely but allowing it to have multiple rels provides a most-compatible-denominator definition. A single LinkInterface object may be serialized to one or more link entries in a given hypermedia format, as appropriate. However, specifying multiple link objects each with a single rel yet the same URI is also legal, and a hypermedia format can serialize that as appropriate, too. Why is a LinkProviderInterface needed? In many contexts, a set of links will be attached to some other object. Those objects may be used in situations where all that is relevant is their links, or some subset of their links. For example, various different value objects may be defined that represent different REST formats such as HAL, JSON-LD, or Atom. It may be useful to extract those links from such an object uniformly for further processing. For instance, next/previous links may be extracted from an object and added to a PSR-7 Response object as Link headers. Alternatively, many links would make sense to represent with a \"preload\" link relationship, which would indicate to an HTTP 2-compatible web server that the linked resources should be streamed to a client in anticipation of a subsequent request. All of those cases are independent of the payload or encoding of the object. By providing a common interface to access such links, we enable generic handling of the links themselves regardless of the value object or domain object that is producing them. 4. People 4.1 Editor(s) Larry Garfield 4.2 Sponsors Matthew Weier O'Phinney (coordinator) Marc Alexander 4.3 Contributors Evert Pot 5. Votes 6. Relevant links What's in a link? by Evert Pot FIG Link Working Group List 7. Errata 7.1 Type additions The 1.1 release of the psr/link package includes scalar parameter types. The 2.0 release of the package includes return types. This structure leverages PHP 7.2 covariance support to allow for a gradual upgrade process, but requires PHP 8.0 for type compatibility. Implementers MAY add return types to their own packages at their discretion, provided that: the return types match those in the 2.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later. Implementers MAY add parameter types to their own packages in a new major release, either at the same time as adding return types or in a subsequent release, provided that: the parameter types match those in the 1.1 package. the implementation specifies a minimum PHP version of 8.0.0 or later. the implementation depends on \"psr/link\": \"^1.1 || ^2.0\" so as to exclude the untyped 1.0 version. Implementers are encouraged but not required to transition their packages toward the 2.0 version of the package at their earliest convenience. 7.2 Attribute type handling The original specification contained an inconsistency regarding array values for attributes. The text of the specification states in section 1.2 that attribute values (as passed to EvolvableLinkInterface::withAttribute() ) could be of multiple types, some of which allowed for special handling (such as booleans or arrays). However, the docblock for that method specified that the $value parameter had to be a string, which was incorrect. To address this issue, the interface has been corrected in later releases to allow $value to be of type string|\\Stringable|int|float|bool|array . Implementers SHOULD treat a Stringable object the same as a string parameter. Implementers MAY serialize int , float , or bool in alternate, type-aware ways for a particular serialization format as appropriate. Other object types or resources remain disallowed. Multiple calls to withAttribute() with the same $name MUST override previously provided values, as the spec already states. To provide multiple values to a particular attribute, pass an array with the desired values. All other guidelines and requirements in section 1.2 remain valid.","title":"Link Definition Meta Document"},{"location":"accepted/PSR-13-links-meta/#link-definition-meta-document","text":"","title":"Link Definition Meta Document"},{"location":"accepted/PSR-13-links-meta/#1-summary","text":"Hypermedia links are becoming an increasingly important part of the web, in both HTML contexts and various API format contexts. However, there is no single common hypermedia format, nor is there a common way to represent Links between formats. This specification aims to provide PHP developers with a simple, common way of representing a hypermedia link independently of the serialization format that is used. That in turn allows a system to serialize a response with hypermedia links into one or more wire formats independently of the process of deciding what those links should be.","title":"1. Summary"},{"location":"accepted/PSR-13-links-meta/#2-scope","text":"","title":"2. Scope"},{"location":"accepted/PSR-13-links-meta/#21-goals","text":"This specification aims to extract and standardize hypermedia link representation between different formats.","title":"2.1 Goals"},{"location":"accepted/PSR-13-links-meta/#22-non-goals","text":"This specification does not seek to standardize or favor any particular hypermedia serialization format.","title":"2.2 Non-Goals"},{"location":"accepted/PSR-13-links-meta/#3-design-decisions","text":"","title":"3. Design Decisions"},{"location":"accepted/PSR-13-links-meta/#why-no-mutator-methods","text":"One of the key targets for this specification is PSR-7 Response objects. Response objects by design must be immutable. Other value-object implementations likely would also require an immutable interface. Additionally, some Link Provider objects may not be value objects but other objects within a given domain, which are able to generate Links on the fly, perhaps off of a database result or other underlying representation. In those cases a writeable provider definition would be incompatible. Therefore, this specification splits accessor methods and evolvable methods into separate interfaces, allowing objects to implement just the read-only or evolvable versions as appropriate to their use case.","title":"Why no mutator methods?"},{"location":"accepted/PSR-13-links-meta/#why-is-rel-on-a-link-object-multi-value","text":"Different hypermedia standards handle multiple links with the same relationship differently. Some have a single link that has multiple rel's defined. Others have a single rel entry that then contains multiple links. Defining each Link uniquely but allowing it to have multiple rels provides a most-compatible-denominator definition. A single LinkInterface object may be serialized to one or more link entries in a given hypermedia format, as appropriate. However, specifying multiple link objects each with a single rel yet the same URI is also legal, and a hypermedia format can serialize that as appropriate, too.","title":"Why is rel on a Link object multi-value?"},{"location":"accepted/PSR-13-links-meta/#why-is-a-linkproviderinterface-needed","text":"In many contexts, a set of links will be attached to some other object. Those objects may be used in situations where all that is relevant is their links, or some subset of their links. For example, various different value objects may be defined that represent different REST formats such as HAL, JSON-LD, or Atom. It may be useful to extract those links from such an object uniformly for further processing. For instance, next/previous links may be extracted from an object and added to a PSR-7 Response object as Link headers. Alternatively, many links would make sense to represent with a \"preload\" link relationship, which would indicate to an HTTP 2-compatible web server that the linked resources should be streamed to a client in anticipation of a subsequent request. All of those cases are independent of the payload or encoding of the object. By providing a common interface to access such links, we enable generic handling of the links themselves regardless of the value object or domain object that is producing them.","title":"Why is a LinkProviderInterface needed?"},{"location":"accepted/PSR-13-links-meta/#4-people","text":"","title":"4. People"},{"location":"accepted/PSR-13-links-meta/#41-editors","text":"Larry Garfield","title":"4.1 Editor(s)"},{"location":"accepted/PSR-13-links-meta/#42-sponsors","text":"Matthew Weier O'Phinney (coordinator) Marc Alexander","title":"4.2 Sponsors"},{"location":"accepted/PSR-13-links-meta/#43-contributors","text":"Evert Pot","title":"4.3 Contributors"},{"location":"accepted/PSR-13-links-meta/#5-votes","text":"","title":"5. Votes"},{"location":"accepted/PSR-13-links-meta/#6-relevant-links","text":"What's in a link? by Evert Pot FIG Link Working Group List","title":"6. Relevant links"},{"location":"accepted/PSR-13-links-meta/#7-errata","text":"","title":"7. Errata"},{"location":"accepted/PSR-13-links-meta/#71-type-additions","text":"The 1.1 release of the psr/link package includes scalar parameter types. The 2.0 release of the package includes return types. This structure leverages PHP 7.2 covariance support to allow for a gradual upgrade process, but requires PHP 8.0 for type compatibility. Implementers MAY add return types to their own packages at their discretion, provided that: the return types match those in the 2.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later. Implementers MAY add parameter types to their own packages in a new major release, either at the same time as adding return types or in a subsequent release, provided that: the parameter types match those in the 1.1 package. the implementation specifies a minimum PHP version of 8.0.0 or later. the implementation depends on \"psr/link\": \"^1.1 || ^2.0\" so as to exclude the untyped 1.0 version. Implementers are encouraged but not required to transition their packages toward the 2.0 version of the package at their earliest convenience.","title":"7.1 Type additions"},{"location":"accepted/PSR-13-links-meta/#72-attribute-type-handling","text":"The original specification contained an inconsistency regarding array values for attributes. The text of the specification states in section 1.2 that attribute values (as passed to EvolvableLinkInterface::withAttribute() ) could be of multiple types, some of which allowed for special handling (such as booleans or arrays). However, the docblock for that method specified that the $value parameter had to be a string, which was incorrect. To address this issue, the interface has been corrected in later releases to allow $value to be of type string|\\Stringable|int|float|bool|array . Implementers SHOULD treat a Stringable object the same as a string parameter. Implementers MAY serialize int , float , or bool in alternate, type-aware ways for a particular serialization format as appropriate. Other object types or resources remain disallowed. Multiple calls to withAttribute() with the same $name MUST override previously provided values, as the spec already states. To provide multiple values to a particular attribute, pass an array with the desired values. All other guidelines and requirements in section 1.2 remain valid.","title":"7.2 Attribute type handling"},{"location":"accepted/PSR-13-links/","text":"Link definition interfaces Hypermedia links are becoming an increasingly important part of the web, in both HTML contexts and various API format contexts. However, there is no single common hypermedia format, nor is there a common way to represent links between formats. This specification aims to provide PHP developers with a simple, common way of representing a hypermedia link independently of the serialization format that is used. That in turn allows a system to serialize a response with hypermedia links into one or more wire formats independently of the process of deciding what those links should be. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . References RFC 2119 RFC 4287 RFC 5988 RFC 6570 IANA Link Relations Registry Microformats Relations List 1. Specification 1.1 Basic links A Hypermedia Link consists of, at minimum: - A URI representing the target resource being referenced. - A relationship defining how the target resource relates to the source. Various other attributes of the Link may exist, depending on the format used. As additional attributes are not well-standardized or universal, this specification does not seek to standardize them. For the purposes of this specification, the following definitions apply. Implementing Object - An object that implements one of the interfaces defined by this specification. Serializer - A library or other system that takes one or more Link objects and produces a serialized representation of it in some defined format. 1.2 Attributes All links MAY include zero or more additional attributes beyond the URI and relationship. There is no formal registry of the values that are allowed here, and validity of values is dependent on context and often on a particular serialization format. Commonly supported values include 'hreflang', 'title', and 'type'. Serializers MAY omit attributes on a link object if required to do so by the serialization format. However, serializers SHOULD encode all provided attributes possible in order to allow for user-extension unless prevented by a serialization format's definition. Some attributes (commonly hreflang ) may appear more than once in their context. Therefore, an attribute value MAY be an array of values rather than a simple value. Serializers MAY encode that array in whatever format is appropriate for the serialized format (such as a space-separated list, comma-separated list, etc.). If a given attribute is not allowed to have multiple values in a particular context, serializers MUST use the first value provided and ignore all subsequent values. If an attribute value is boolean true , serializers MAY use abbreviated forms if appropriate and supported by a serialization format. For example, HTML permits attributes to have no value when the attribute's presence has a boolean meaning. This rule applies if and only if the attribute is boolean true , not for any other \"truthy\" value in PHP such as integer 1. If an attribute value is boolean false , serializers SHOULD omit the attribute entirely unless doing so changes the semantic meaning of the result. This rule applies if and only if the attribute is boolean false , not for any other \"falsey\" value in PHP such as integer 0. 1.3 Relationships Link relationships are defined as strings, and are either a simple keyword in case of a publicly defined relationship or an absolute URI in the case of a private relationships. In case a simple keyword is used, it SHOULD match one from the IANA registry at: http://www.iana.org/assignments/link-relations/link-relations.xhtml Optionally the microformats.org registry MAY be used, but this may not be valid in every context: http://microformats.org/wiki/existing-rel-values A relationship that is not defined in one of the above registries or a similar public registry is considered \"private\", that is, specific to a particular application or use case. Such relationships MUST use an absolute URI. 1.4 Link Templates RFC 6570 defines a format for URI templates, that is, a pattern for a URI that is expected to be filled in with values provided by a client tool. Some hypermedia formats support templated links while others do not, and may have a special way to denote that a link is a template. A Serializer for a format that does not support URI Templates MUST ignore any templated Links it encounters. 1.5 Evolvable providers In some cases, a Link Provider may need the ability to have additional links added to it. In others, a link provider is necessarily read-only, with links derived at runtime from some other data source. For that reason, modifiable providers are a secondary interface that may optionally be implemented. Additionally, some Link Provider objects, such as PSR-7 Response objects, are by design immutable. That means methods to add links to them in-place would be incompatible. Therefore, the EvolvableLinkProviderInterface 's single method requires that a new object be returned, identical to the original but with an additional Link object included. 1.6 Evolvable link objects Link objects are in most cases value objects. As such, allowing them to evolve in the same fashion as PSR-7 value objects is a useful option. For that reason, an additional EvolvableLinkInterface is included that provides methods to produce new object instances with a single change. The same model is used by PSR-7 and, thanks to PHP's copy-on-write behavior, is still CPU and memory efficient. There is no evolvable method for templated values, however, as the templated value of a link is based exclusively on the href value. It MUST NOT be set independently, but derived from whether or not the href value is an RFC 6570 link template. 2. Package The interfaces and classes described are provided as part of the psr/link package. 3. Interfaces 3.1 Psr\\Link\\LinkInterface <?php namespace Psr\\Link; /** * A readable link object. */ interface LinkInterface { /** * Returns the target of the link. * * The target link must be one of: * - An absolute URI, as defined by RFC 5988. * - A relative URI, as defined by RFC 5988. The base of the relative link * is assumed to be known based on context by the client. * - A URI template as defined by RFC 6570. * * If a URI template is returned, isTemplated() MUST return True. * * @return string */ public function getHref(); /** * Returns whether or not this is a templated link. * * @return bool * True if this link object is templated, False otherwise. */ public function isTemplated(); /** * Returns the relationship type(s) of the link. * * This method returns 0 or more relationship types for a link, expressed * as an array of strings. * * @return string[] */ public function getRels(); /** * Returns a list of attributes that describe the target URI. * * @return array * A key-value list of attributes, where the key is a string and the value * is either a PHP primitive or an array of PHP strings. If no values are * found an empty array MUST be returned. */ public function getAttributes(); } 3.2 Psr\\Link\\EvolvableLinkInterface <?php namespace Psr\\Link; /** * An evolvable link value object. */ interface EvolvableLinkInterface extends LinkInterface { /** * Returns an instance with the specified href. * * @param string $href * The href value to include. It must be one of: * - An absolute URI, as defined by RFC 5988. * - A relative URI, as defined by RFC 5988. The base of the relative link * is assumed to be known based on context by the client. * - A URI template as defined by RFC 6570. * - An object implementing __toString() that produces one of the above * values. * * An implementing library SHOULD evaluate a passed object to a string * immediately rather than waiting for it to be returned later. * * @return static */ public function withHref($href); /** * Returns an instance with the specified relationship included. * * If the specified rel is already present, this method MUST return * normally without errors, but without adding the rel a second time. * * @param string $rel * The relationship value to add. * @return static */ public function withRel($rel); /** * Returns an instance with the specified relationship excluded. * * If the specified rel is already not present, this method MUST return * normally without errors. * * @param string $rel * The relationship value to exclude. * @return static */ public function withoutRel($rel); /** * Returns an instance with the specified attribute added. * * If the specified attribute is already present, it will be overwritten * with the new value. * * @param string $attribute * The attribute to include. * @param string $value * The value of the attribute to set. * @return static */ public function withAttribute($attribute, $value); /** * Returns an instance with the specified attribute excluded. * * If the specified attribute is not present, this method MUST return * normally without errors. * * @param string $attribute * The attribute to remove. * @return static */ public function withoutAttribute($attribute); } 3.2 Psr\\Link\\LinkProviderInterface <?php namespace Psr\\Link; /** * A link provider object. */ interface LinkProviderInterface { /** * Returns an iterable of LinkInterface objects. * * The iterable may be an array or any PHP \\Traversable object. If no links * are available, an empty array or \\Traversable MUST be returned. * * @return LinkInterface[]|\\Traversable */ public function getLinks(); /** * Returns an iterable of LinkInterface objects that have a specific relationship. * * The iterable may be an array or any PHP \\Traversable object. If no links * with that relationship are available, an empty array or \\Traversable MUST be returned. * * @return LinkInterface[]|\\Traversable */ public function getLinksByRel($rel); } 3.3 Psr\\Link\\EvolvableLinkProviderInterface <?php namespace Psr\\Link; /** * An evolvable link provider value object. */ interface EvolvableLinkProviderInterface extends LinkProviderInterface { /** * Returns an instance with the specified link included. * * If the specified link is already present, this method MUST return normally * without errors. The link is present if $link is === identical to a link * object already in the collection. * * @param LinkInterface $link * A link object that should be included in this collection. * @return static */ public function withLink(LinkInterface $link); /** * Returns an instance with the specified link removed. * * If the specified link is not present, this method MUST return normally * without errors. The link is present if $link is === identical to a link * object already in the collection. * * @param LinkInterface $link * The link to remove. * @return static */ public function withoutLink(LinkInterface $link); } Since psr/link version 1.1 , the above interfaces have been updated to add argument type hints. Since psr/link version 2.0 , the above interfaces have been updated to add return type hints. References to array|\\Traversable have been replaced with iterable .","title":"Link definition interfaces"},{"location":"accepted/PSR-13-links/#link-definition-interfaces","text":"Hypermedia links are becoming an increasingly important part of the web, in both HTML contexts and various API format contexts. However, there is no single common hypermedia format, nor is there a common way to represent links between formats. This specification aims to provide PHP developers with a simple, common way of representing a hypermedia link independently of the serialization format that is used. That in turn allows a system to serialize a response with hypermedia links into one or more wire formats independently of the process of deciding what those links should be. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"Link definition interfaces"},{"location":"accepted/PSR-13-links/#references","text":"RFC 2119 RFC 4287 RFC 5988 RFC 6570 IANA Link Relations Registry Microformats Relations List","title":"References"},{"location":"accepted/PSR-13-links/#1-specification","text":"","title":"1. Specification"},{"location":"accepted/PSR-13-links/#11-basic-links","text":"A Hypermedia Link consists of, at minimum: - A URI representing the target resource being referenced. - A relationship defining how the target resource relates to the source. Various other attributes of the Link may exist, depending on the format used. As additional attributes are not well-standardized or universal, this specification does not seek to standardize them. For the purposes of this specification, the following definitions apply. Implementing Object - An object that implements one of the interfaces defined by this specification. Serializer - A library or other system that takes one or more Link objects and produces a serialized representation of it in some defined format.","title":"1.1 Basic links"},{"location":"accepted/PSR-13-links/#12-attributes","text":"All links MAY include zero or more additional attributes beyond the URI and relationship. There is no formal registry of the values that are allowed here, and validity of values is dependent on context and often on a particular serialization format. Commonly supported values include 'hreflang', 'title', and 'type'. Serializers MAY omit attributes on a link object if required to do so by the serialization format. However, serializers SHOULD encode all provided attributes possible in order to allow for user-extension unless prevented by a serialization format's definition. Some attributes (commonly hreflang ) may appear more than once in their context. Therefore, an attribute value MAY be an array of values rather than a simple value. Serializers MAY encode that array in whatever format is appropriate for the serialized format (such as a space-separated list, comma-separated list, etc.). If a given attribute is not allowed to have multiple values in a particular context, serializers MUST use the first value provided and ignore all subsequent values. If an attribute value is boolean true , serializers MAY use abbreviated forms if appropriate and supported by a serialization format. For example, HTML permits attributes to have no value when the attribute's presence has a boolean meaning. This rule applies if and only if the attribute is boolean true , not for any other \"truthy\" value in PHP such as integer 1. If an attribute value is boolean false , serializers SHOULD omit the attribute entirely unless doing so changes the semantic meaning of the result. This rule applies if and only if the attribute is boolean false , not for any other \"falsey\" value in PHP such as integer 0.","title":"1.2 Attributes"},{"location":"accepted/PSR-13-links/#13-relationships","text":"Link relationships are defined as strings, and are either a simple keyword in case of a publicly defined relationship or an absolute URI in the case of a private relationships. In case a simple keyword is used, it SHOULD match one from the IANA registry at: http://www.iana.org/assignments/link-relations/link-relations.xhtml Optionally the microformats.org registry MAY be used, but this may not be valid in every context: http://microformats.org/wiki/existing-rel-values A relationship that is not defined in one of the above registries or a similar public registry is considered \"private\", that is, specific to a particular application or use case. Such relationships MUST use an absolute URI.","title":"1.3 Relationships"},{"location":"accepted/PSR-13-links/#14-link-templates","text":"RFC 6570 defines a format for URI templates, that is, a pattern for a URI that is expected to be filled in with values provided by a client tool. Some hypermedia formats support templated links while others do not, and may have a special way to denote that a link is a template. A Serializer for a format that does not support URI Templates MUST ignore any templated Links it encounters.","title":"1.4 Link Templates"},{"location":"accepted/PSR-13-links/#15-evolvable-providers","text":"In some cases, a Link Provider may need the ability to have additional links added to it. In others, a link provider is necessarily read-only, with links derived at runtime from some other data source. For that reason, modifiable providers are a secondary interface that may optionally be implemented. Additionally, some Link Provider objects, such as PSR-7 Response objects, are by design immutable. That means methods to add links to them in-place would be incompatible. Therefore, the EvolvableLinkProviderInterface 's single method requires that a new object be returned, identical to the original but with an additional Link object included.","title":"1.5 Evolvable providers"},{"location":"accepted/PSR-13-links/#16-evolvable-link-objects","text":"Link objects are in most cases value objects. As such, allowing them to evolve in the same fashion as PSR-7 value objects is a useful option. For that reason, an additional EvolvableLinkInterface is included that provides methods to produce new object instances with a single change. The same model is used by PSR-7 and, thanks to PHP's copy-on-write behavior, is still CPU and memory efficient. There is no evolvable method for templated values, however, as the templated value of a link is based exclusively on the href value. It MUST NOT be set independently, but derived from whether or not the href value is an RFC 6570 link template.","title":"1.6 Evolvable link objects"},{"location":"accepted/PSR-13-links/#2-package","text":"The interfaces and classes described are provided as part of the psr/link package.","title":"2. Package"},{"location":"accepted/PSR-13-links/#3-interfaces","text":"","title":"3. Interfaces"},{"location":"accepted/PSR-13-links/#31-psrlinklinkinterface","text":"<?php namespace Psr\\Link; /** * A readable link object. */ interface LinkInterface { /** * Returns the target of the link. * * The target link must be one of: * - An absolute URI, as defined by RFC 5988. * - A relative URI, as defined by RFC 5988. The base of the relative link * is assumed to be known based on context by the client. * - A URI template as defined by RFC 6570. * * If a URI template is returned, isTemplated() MUST return True. * * @return string */ public function getHref(); /** * Returns whether or not this is a templated link. * * @return bool * True if this link object is templated, False otherwise. */ public function isTemplated(); /** * Returns the relationship type(s) of the link. * * This method returns 0 or more relationship types for a link, expressed * as an array of strings. * * @return string[] */ public function getRels(); /** * Returns a list of attributes that describe the target URI. * * @return array * A key-value list of attributes, where the key is a string and the value * is either a PHP primitive or an array of PHP strings. If no values are * found an empty array MUST be returned. */ public function getAttributes(); }","title":"3.1 Psr\\Link\\LinkInterface"},{"location":"accepted/PSR-13-links/#32-psrlinkevolvablelinkinterface","text":"<?php namespace Psr\\Link; /** * An evolvable link value object. */ interface EvolvableLinkInterface extends LinkInterface { /** * Returns an instance with the specified href. * * @param string $href * The href value to include. It must be one of: * - An absolute URI, as defined by RFC 5988. * - A relative URI, as defined by RFC 5988. The base of the relative link * is assumed to be known based on context by the client. * - A URI template as defined by RFC 6570. * - An object implementing __toString() that produces one of the above * values. * * An implementing library SHOULD evaluate a passed object to a string * immediately rather than waiting for it to be returned later. * * @return static */ public function withHref($href); /** * Returns an instance with the specified relationship included. * * If the specified rel is already present, this method MUST return * normally without errors, but without adding the rel a second time. * * @param string $rel * The relationship value to add. * @return static */ public function withRel($rel); /** * Returns an instance with the specified relationship excluded. * * If the specified rel is already not present, this method MUST return * normally without errors. * * @param string $rel * The relationship value to exclude. * @return static */ public function withoutRel($rel); /** * Returns an instance with the specified attribute added. * * If the specified attribute is already present, it will be overwritten * with the new value. * * @param string $attribute * The attribute to include. * @param string $value * The value of the attribute to set. * @return static */ public function withAttribute($attribute, $value); /** * Returns an instance with the specified attribute excluded. * * If the specified attribute is not present, this method MUST return * normally without errors. * * @param string $attribute * The attribute to remove. * @return static */ public function withoutAttribute($attribute); }","title":"3.2 Psr\\Link\\EvolvableLinkInterface"},{"location":"accepted/PSR-13-links/#32-psrlinklinkproviderinterface","text":"<?php namespace Psr\\Link; /** * A link provider object. */ interface LinkProviderInterface { /** * Returns an iterable of LinkInterface objects. * * The iterable may be an array or any PHP \\Traversable object. If no links * are available, an empty array or \\Traversable MUST be returned. * * @return LinkInterface[]|\\Traversable */ public function getLinks(); /** * Returns an iterable of LinkInterface objects that have a specific relationship. * * The iterable may be an array or any PHP \\Traversable object. If no links * with that relationship are available, an empty array or \\Traversable MUST be returned. * * @return LinkInterface[]|\\Traversable */ public function getLinksByRel($rel); }","title":"3.2 Psr\\Link\\LinkProviderInterface"},{"location":"accepted/PSR-13-links/#33-psrlinkevolvablelinkproviderinterface","text":"<?php namespace Psr\\Link; /** * An evolvable link provider value object. */ interface EvolvableLinkProviderInterface extends LinkProviderInterface { /** * Returns an instance with the specified link included. * * If the specified link is already present, this method MUST return normally * without errors. The link is present if $link is === identical to a link * object already in the collection. * * @param LinkInterface $link * A link object that should be included in this collection. * @return static */ public function withLink(LinkInterface $link); /** * Returns an instance with the specified link removed. * * If the specified link is not present, this method MUST return normally * without errors. The link is present if $link is === identical to a link * object already in the collection. * * @param LinkInterface $link * The link to remove. * @return static */ public function withoutLink(LinkInterface $link); } Since psr/link version 1.1 , the above interfaces have been updated to add argument type hints. Since psr/link version 2.0 , the above interfaces have been updated to add return type hints. References to array|\\Traversable have been replaced with iterable .","title":"3.3 Psr\\Link\\EvolvableLinkProviderInterface"},{"location":"accepted/PSR-14-event-dispatcher-meta/","text":"Event Dispatcher Meta Document 1. Summary The purpose of this document is to describe the rationale and logic behind the Event Dispatcher specification. 2. Why Bother? Many libraries, components, and frameworks have long supported mechanisms for allowing arbitrary third party code to interact with them. Most are variations on the classic Observer pattern, often mediated through an intermediary object or service. Others take a more Aspect-Oriented Programming (AOP) approach. Nonetheless all have the same basic concept: interrupt program flow at a fixed point to provide information to arbitrary third party libraries with information about the action being performed and allow them to either react or influence the program behavior. This is a well-established model, but a standard mechanism by which libraries do so will allow them to interoperate with more and more varied third party libraries with less effort by both the original developer and extension developers. 3. Scope 3.1 Goals Simplify and standardize the process by which libraries and components may expose themselves to extension via \"events\" so that they may be more easily incorporated into applications and frameworks. Simplify and standardize the process by which libraries and components may register an interest in responding to an Event so that they may be more easily incorporated into arbitrary applications and frameworks. To the extent feasible, ease the process for existing code bases to transition toward this specification. 3.2 Non-Goals Asynchronous systems often have a concept of an \"event loop\" to manage interleaving coroutines. That is an unrelated matter and explicitly irrelevant to this specification. Storage systems implementing an \"Event Source\" pattern also have a concept of an \"event\". That is unrelated to the Events discussed here and explicitly out of scope. Strict backward compatibility with existing event systems is not a priority and is not expected. While this specification will undoubtedly suggest implementation patterns, it does not seek to define One True Event Dispatcher Implementation, only how callers and Listeners communicate with that Dispatcher. 4. Approaches 4.1 Use cases considered The Working Group identified four possible workflows for event passing, based on use cases seen in the wild in various systems. One-way notification. (\"I did a thing, if you care.\") Object enhancement. (\"Here's a thing, please modify it before I do something with it.\") Collection. (\"Give me all your things, that I may do something with that list.\") Alternative chain. (\"Here's a thing; the first one of you that can handle it do so, then stop.\") On further review, the Working Goup determined that: Collection was a special case of object enhancement (the collection being the object that is enhanced). Alternative chain is similarly a special case of object enhancement, as the signature is identical and the dispatch workflow is nearly identical, albeit with an extra check included. One-way notification is a degenerate case of the others, or can be represented as such. Although in concept one-way notification can be done asynchronously (including delaying it through a queue), in practice, few explicit implementations of that model exist, providing fewer places from which to draw guidance on details (such as proper error handling). After much consideration, the Working Group elected not to provide an explicitly separate workflow for one-way notification as it could be adequately represented as a degenerate case of the others. 4.2 Example applications Indicating that some change in system configuration or some user action has occurred and allowing other systems to react in ways that do not affect program flow (such as sending an email or logging the action). Passing an object to a series of Listeners to allow it to be modified before it is saved to a persistence system. Passing a collection to a series of Listeners to allow them to register values with it or modify existing values so that the Emitter may act on all of the collected information. Passing some contextual information to a series of Listeners so that all of them may \"vote\" on what action to take, with the Emitter deciding based on the aggregate information provided. Passing an object to a series of Listeners and allowing any Listener to terminate the process early before other Listeners have completed. 4.3 Immutable events Initially the Working Group wished to define all Events as immutable message objects, similar to PSR-7. However, that proved problematic in all but the one-way notification case. In the other scenarios, Listeners needed a way to return data to the caller. In concept, there were three possible avenues: Make the Event mutable and modify it in place. Require that Events be evolvable (immutable but with with*() methods like PSR-7 and PSR-13) and that Listeners return the Event to pass along. Make the Event immutable, but aggregate and return the return value from each Listener. However, Stoppable Events (the alternative chain case) also needed to have a channel by which to indicate that further Listeners should not be called. That could be done either by: Modifying the Event (e.g., calling a stopPropagation() method) Returning a sentinel value from the Listener ( true or false ) to indicate that propagation should terminate. Evolving the Event to be stopped ( withPropagationStopped() ) Each of these alternatives have drawbacks. The first means that, at least for the purposes of indicating propagation status, Events must be mutable. The second requires that Listeners return a value, at least when they intend to halt event propagation; this could have ramifications with existing libraries, and potential issues in terms of documentation. The third requires that Listeners return the Event or mutated Event in all cases, and would require Dispatchers to test to ensure that the returned value is of the same type as the value passed to the Listener; it effectively puts an onus both on consumers and implementers, thus raising more potential integration issues. Additionally, a desired feature was the ability to derive whether or not to stop propagation based on values collected from the Listeners. (For example, to stop when one of them has provided a certain value, or after at least three of them have indicated a \"reject this request\" flag, or similar.) While technically possible to implement as an evolvable object, such behavior is intrinsically stateful, so would be highly cumbersome for both implementers and users. Having Listeners return evolvable Events also posed a challenge. That pattern is not used by any known implementations in PHP or elsewhere. It also relies on the Listener to remember to return the Event (additional work for the Listener author) and to not return some other, new object that might not be fully compatible with later Listeners (such as a subclass or superclass of the Event). Immutable Events also rely on the Event author to respect the admonition to be immutable. Events are, by nature, very loosely designed, and the potential for implementers to ignore that part of the spec, even inadvertently, is high. That left two possible options: Allow Events to be mutable. Require, but be unable to enforce, immutable Events with a high-ceremony interface, more work for Listener authors, and a higher potential for breakage that may not be detectable at compile time. By \"high-ceremony\", we imply that verbose syntax and/or implementations would be required. In the former case, Listener authors would need to (a) create a new Event instance with the propagation flag toggled, and (b) return the new Event instance so that the Dispatcher could examine it: function (SomeEvent $event) : SomeEvent { // do some work return $event->withPropagationStopped(); } The latter case, Dispatcher implementations, would require checks on the return value: foreach ($provider->getListenersForEvent($event) as $listener) { $returnedEvent = $listener($event); if (! $returnedEvent instanceof $event) { // This is an exceptional case! // // We now have an event of a different type, or perhaps nothing was // returned by the listener. An event of a different type might mean: // // - we need to trigger the new event // - we have an event mismatch, and should raise an exception // - we should attempt to trigger the remaining listeners anyway // // In the case of nothing being returned, this could mean any of: // // - we should continue triggering, using the original event // - we should stop triggering, and treat this as a request to // stop propagation // - we should raise an exception, because the listener did not // return what was expected // // In short, this becomes very hard to specify, or enforce. } if ($returnedEvent instanceof StoppableEventInterface && $returnedEvent->isPropagationStopped() ) { break; } } In both situations, we would be introducing more potential edge cases, with little benefit, and few language-level mechanisms to guide developers to correct implementation. Given these options, the Working Group felt mutable Events were the safer alternative. That said, there is no requirement that an Event be mutable . Implementers should provide mutator methods on an Event object if and only if it is necessary and appropriate to the use case at hand. 4.4 Listener registration Experimentation during development of the specification determined that there were a wide range of viable, legitimate means by which a Dispatcher could be informed of a Listener. A Listener: could be registered explicitly; could be registered explicitly based on reflection of its signature; could be registered with a numeric priority order; could be registered using a before/after mechanism to control ordering more precisely; could be registered from a service container; could use a pre-compile step to generate code; could be based on method names on objects in the Event itself; could be limited to certain situations or contexts based on arbitrarily complex logic (only for certain users, only on certain days, only if certain system settings are present, etc). These and other mechanisms all exist in the wild today in PHP, all are valid use cases worth supporting, and few if any can be conveniently represented as a special case of another. That is, standardizing one way, or even a small set of ways, to inform the system of a Listener turned out to be impractical if not impossible without cutting off many use cases that should be supported. The Working Group therefore chose to encapsulate the registration of Listeners behind the ListenerProviderInterface . A Provider object may have an explicit registration mechanism available, or multiple such mechanisms, or none. It could also be generated code produced by some compile step. However, that also splits the responsibility of managing the process of dispatching an Event from the process of mapping an Event to Listeners. That way different implementations may be mixed-and-matched with different Provider mechanisms as needed. It is even possible, and potentially advisable, to allow libraries to include their own Providers that get aggregated into a common Provider that aggregates their Listeners to return to the Dispatcher. That is one possible way to handle arbitrary Listener registration within an arbitrary framework, although the Working Group is clear that is not the only option. While combining the Dispatcher and Provider into a single object is a valid and permissible degenerate case, it is NOT RECOMMENDED as it reduces the flexibility of system integrators. Instead, the Provider SHOULD be composed as a dependent object. 4.5 Deferred listeners The specification requires that the callables returned by a Provider MUST all be invoked (unless propagation is explicitly stopped) before the Dispatcher returns. However, the specification also explicitly states that Listeners may enqueue Events for later processing rather than taking immediate action. It is also entirely permissible for a Provider to accept registration of a callable, but then wrap it in another callable before returning it to the Dispatcher. (In that case, the wrapper is the Listener from the Dispatcher's point of view.) That allows all of the following behaviors to be legal: Providers return callable Listeners that were provided to them. Providers return callables that create an entry in a queue that will react to the Event with another callable at some later point in time. Listeners may themselves create an entry in a queue that will react to the Event at some later point in time. Listeners or Providers may trigger an asynchronous task, if running in an environment with support for asynchronous behavior (assuming that the result of the asynchronous task is not needed by the Emitter.) Providers may perform such delay or wrapping on Listeners selectively based on arbitrary logic. The net result is that Providers and Listeners are responsible for determining when it is safe to defer a response to an Event until some later time. In that case, the Provider or Listener is explicitly opting out of being able to pass meaningful data back to the Emitter, but the Working Group determined that they were in the best position to know if it was safe to do so. While technically a side effect of the design, it is essentially the same approach used by Laravel (as of Laravel 5) and has been proven in the wild. 4.6 Return values Per the spec, a Dispatcher MUST return the Event passed by the Emitter. This is specified to provide a more ergonomic experience for users, allowing short-hands similar to the following: $event = $dispatcher->dispatch(new SomeEvent('some context')); $items = $dispatcher->dispatch(new ItemCollector())->getItems(); The EventDispatcher::dispatch() interface, however, has no return type specified. That is primarily for backward compatibility with existing implementations to make it easier for them to adopt the new interface. Additionally, as Events can be any arbitrary object the return type could only have been object , which would provide only minimal (albeit non-zero) value, as that type declaration would not provide IDEs with any useful information nor would it effectively enforce that the same Event is returned. The method return was thus left syntactically untyped. However, returning the same Event object from dispatch() is still a requirement and failure to do so is a violation of the specification. 5. People The Event Manager Working Group consisted of: 5.1 Editor Larry Garfield 5.2 Sponsor Cees-Jan Kiewiet 5.3 Working Group Members Benjamin Mack Elizabeth Smith Ryan Weaver Matthew Weier O'Phinney 6. Votes Entrance vote Review Period Initiation Acceptance 7. Relevant Links Inspiration Mailing List Thread Entrance vote Informal poll on package structure Informal poll on naming structure","title":"PSR 14 event dispatcher meta"},{"location":"accepted/PSR-14-event-dispatcher-meta/#event-dispatcher-meta-document","text":"","title":"Event Dispatcher Meta Document"},{"location":"accepted/PSR-14-event-dispatcher-meta/#1-summary","text":"The purpose of this document is to describe the rationale and logic behind the Event Dispatcher specification.","title":"1. Summary"},{"location":"accepted/PSR-14-event-dispatcher-meta/#2-why-bother","text":"Many libraries, components, and frameworks have long supported mechanisms for allowing arbitrary third party code to interact with them. Most are variations on the classic Observer pattern, often mediated through an intermediary object or service. Others take a more Aspect-Oriented Programming (AOP) approach. Nonetheless all have the same basic concept: interrupt program flow at a fixed point to provide information to arbitrary third party libraries with information about the action being performed and allow them to either react or influence the program behavior. This is a well-established model, but a standard mechanism by which libraries do so will allow them to interoperate with more and more varied third party libraries with less effort by both the original developer and extension developers.","title":"2. Why Bother?"},{"location":"accepted/PSR-14-event-dispatcher-meta/#3-scope","text":"","title":"3. Scope"},{"location":"accepted/PSR-14-event-dispatcher-meta/#31-goals","text":"Simplify and standardize the process by which libraries and components may expose themselves to extension via \"events\" so that they may be more easily incorporated into applications and frameworks. Simplify and standardize the process by which libraries and components may register an interest in responding to an Event so that they may be more easily incorporated into arbitrary applications and frameworks. To the extent feasible, ease the process for existing code bases to transition toward this specification.","title":"3.1 Goals"},{"location":"accepted/PSR-14-event-dispatcher-meta/#32-non-goals","text":"Asynchronous systems often have a concept of an \"event loop\" to manage interleaving coroutines. That is an unrelated matter and explicitly irrelevant to this specification. Storage systems implementing an \"Event Source\" pattern also have a concept of an \"event\". That is unrelated to the Events discussed here and explicitly out of scope. Strict backward compatibility with existing event systems is not a priority and is not expected. While this specification will undoubtedly suggest implementation patterns, it does not seek to define One True Event Dispatcher Implementation, only how callers and Listeners communicate with that Dispatcher.","title":"3.2 Non-Goals"},{"location":"accepted/PSR-14-event-dispatcher-meta/#4-approaches","text":"","title":"4. Approaches"},{"location":"accepted/PSR-14-event-dispatcher-meta/#41-use-cases-considered","text":"The Working Group identified four possible workflows for event passing, based on use cases seen in the wild in various systems. One-way notification. (\"I did a thing, if you care.\") Object enhancement. (\"Here's a thing, please modify it before I do something with it.\") Collection. (\"Give me all your things, that I may do something with that list.\") Alternative chain. (\"Here's a thing; the first one of you that can handle it do so, then stop.\") On further review, the Working Goup determined that: Collection was a special case of object enhancement (the collection being the object that is enhanced). Alternative chain is similarly a special case of object enhancement, as the signature is identical and the dispatch workflow is nearly identical, albeit with an extra check included. One-way notification is a degenerate case of the others, or can be represented as such. Although in concept one-way notification can be done asynchronously (including delaying it through a queue), in practice, few explicit implementations of that model exist, providing fewer places from which to draw guidance on details (such as proper error handling). After much consideration, the Working Group elected not to provide an explicitly separate workflow for one-way notification as it could be adequately represented as a degenerate case of the others.","title":"4.1 Use cases considered"},{"location":"accepted/PSR-14-event-dispatcher-meta/#42-example-applications","text":"Indicating that some change in system configuration or some user action has occurred and allowing other systems to react in ways that do not affect program flow (such as sending an email or logging the action). Passing an object to a series of Listeners to allow it to be modified before it is saved to a persistence system. Passing a collection to a series of Listeners to allow them to register values with it or modify existing values so that the Emitter may act on all of the collected information. Passing some contextual information to a series of Listeners so that all of them may \"vote\" on what action to take, with the Emitter deciding based on the aggregate information provided. Passing an object to a series of Listeners and allowing any Listener to terminate the process early before other Listeners have completed.","title":"4.2 Example applications"},{"location":"accepted/PSR-14-event-dispatcher-meta/#43-immutable-events","text":"Initially the Working Group wished to define all Events as immutable message objects, similar to PSR-7. However, that proved problematic in all but the one-way notification case. In the other scenarios, Listeners needed a way to return data to the caller. In concept, there were three possible avenues: Make the Event mutable and modify it in place. Require that Events be evolvable (immutable but with with*() methods like PSR-7 and PSR-13) and that Listeners return the Event to pass along. Make the Event immutable, but aggregate and return the return value from each Listener. However, Stoppable Events (the alternative chain case) also needed to have a channel by which to indicate that further Listeners should not be called. That could be done either by: Modifying the Event (e.g., calling a stopPropagation() method) Returning a sentinel value from the Listener ( true or false ) to indicate that propagation should terminate. Evolving the Event to be stopped ( withPropagationStopped() ) Each of these alternatives have drawbacks. The first means that, at least for the purposes of indicating propagation status, Events must be mutable. The second requires that Listeners return a value, at least when they intend to halt event propagation; this could have ramifications with existing libraries, and potential issues in terms of documentation. The third requires that Listeners return the Event or mutated Event in all cases, and would require Dispatchers to test to ensure that the returned value is of the same type as the value passed to the Listener; it effectively puts an onus both on consumers and implementers, thus raising more potential integration issues. Additionally, a desired feature was the ability to derive whether or not to stop propagation based on values collected from the Listeners. (For example, to stop when one of them has provided a certain value, or after at least three of them have indicated a \"reject this request\" flag, or similar.) While technically possible to implement as an evolvable object, such behavior is intrinsically stateful, so would be highly cumbersome for both implementers and users. Having Listeners return evolvable Events also posed a challenge. That pattern is not used by any known implementations in PHP or elsewhere. It also relies on the Listener to remember to return the Event (additional work for the Listener author) and to not return some other, new object that might not be fully compatible with later Listeners (such as a subclass or superclass of the Event). Immutable Events also rely on the Event author to respect the admonition to be immutable. Events are, by nature, very loosely designed, and the potential for implementers to ignore that part of the spec, even inadvertently, is high. That left two possible options: Allow Events to be mutable. Require, but be unable to enforce, immutable Events with a high-ceremony interface, more work for Listener authors, and a higher potential for breakage that may not be detectable at compile time. By \"high-ceremony\", we imply that verbose syntax and/or implementations would be required. In the former case, Listener authors would need to (a) create a new Event instance with the propagation flag toggled, and (b) return the new Event instance so that the Dispatcher could examine it: function (SomeEvent $event) : SomeEvent { // do some work return $event->withPropagationStopped(); } The latter case, Dispatcher implementations, would require checks on the return value: foreach ($provider->getListenersForEvent($event) as $listener) { $returnedEvent = $listener($event); if (! $returnedEvent instanceof $event) { // This is an exceptional case! // // We now have an event of a different type, or perhaps nothing was // returned by the listener. An event of a different type might mean: // // - we need to trigger the new event // - we have an event mismatch, and should raise an exception // - we should attempt to trigger the remaining listeners anyway // // In the case of nothing being returned, this could mean any of: // // - we should continue triggering, using the original event // - we should stop triggering, and treat this as a request to // stop propagation // - we should raise an exception, because the listener did not // return what was expected // // In short, this becomes very hard to specify, or enforce. } if ($returnedEvent instanceof StoppableEventInterface && $returnedEvent->isPropagationStopped() ) { break; } } In both situations, we would be introducing more potential edge cases, with little benefit, and few language-level mechanisms to guide developers to correct implementation. Given these options, the Working Group felt mutable Events were the safer alternative. That said, there is no requirement that an Event be mutable . Implementers should provide mutator methods on an Event object if and only if it is necessary and appropriate to the use case at hand.","title":"4.3 Immutable events"},{"location":"accepted/PSR-14-event-dispatcher-meta/#44-listener-registration","text":"Experimentation during development of the specification determined that there were a wide range of viable, legitimate means by which a Dispatcher could be informed of a Listener. A Listener: could be registered explicitly; could be registered explicitly based on reflection of its signature; could be registered with a numeric priority order; could be registered using a before/after mechanism to control ordering more precisely; could be registered from a service container; could use a pre-compile step to generate code; could be based on method names on objects in the Event itself; could be limited to certain situations or contexts based on arbitrarily complex logic (only for certain users, only on certain days, only if certain system settings are present, etc). These and other mechanisms all exist in the wild today in PHP, all are valid use cases worth supporting, and few if any can be conveniently represented as a special case of another. That is, standardizing one way, or even a small set of ways, to inform the system of a Listener turned out to be impractical if not impossible without cutting off many use cases that should be supported. The Working Group therefore chose to encapsulate the registration of Listeners behind the ListenerProviderInterface . A Provider object may have an explicit registration mechanism available, or multiple such mechanisms, or none. It could also be generated code produced by some compile step. However, that also splits the responsibility of managing the process of dispatching an Event from the process of mapping an Event to Listeners. That way different implementations may be mixed-and-matched with different Provider mechanisms as needed. It is even possible, and potentially advisable, to allow libraries to include their own Providers that get aggregated into a common Provider that aggregates their Listeners to return to the Dispatcher. That is one possible way to handle arbitrary Listener registration within an arbitrary framework, although the Working Group is clear that is not the only option. While combining the Dispatcher and Provider into a single object is a valid and permissible degenerate case, it is NOT RECOMMENDED as it reduces the flexibility of system integrators. Instead, the Provider SHOULD be composed as a dependent object.","title":"4.4 Listener registration"},{"location":"accepted/PSR-14-event-dispatcher-meta/#45-deferred-listeners","text":"The specification requires that the callables returned by a Provider MUST all be invoked (unless propagation is explicitly stopped) before the Dispatcher returns. However, the specification also explicitly states that Listeners may enqueue Events for later processing rather than taking immediate action. It is also entirely permissible for a Provider to accept registration of a callable, but then wrap it in another callable before returning it to the Dispatcher. (In that case, the wrapper is the Listener from the Dispatcher's point of view.) That allows all of the following behaviors to be legal: Providers return callable Listeners that were provided to them. Providers return callables that create an entry in a queue that will react to the Event with another callable at some later point in time. Listeners may themselves create an entry in a queue that will react to the Event at some later point in time. Listeners or Providers may trigger an asynchronous task, if running in an environment with support for asynchronous behavior (assuming that the result of the asynchronous task is not needed by the Emitter.) Providers may perform such delay or wrapping on Listeners selectively based on arbitrary logic. The net result is that Providers and Listeners are responsible for determining when it is safe to defer a response to an Event until some later time. In that case, the Provider or Listener is explicitly opting out of being able to pass meaningful data back to the Emitter, but the Working Group determined that they were in the best position to know if it was safe to do so. While technically a side effect of the design, it is essentially the same approach used by Laravel (as of Laravel 5) and has been proven in the wild.","title":"4.5 Deferred listeners"},{"location":"accepted/PSR-14-event-dispatcher-meta/#46-return-values","text":"Per the spec, a Dispatcher MUST return the Event passed by the Emitter. This is specified to provide a more ergonomic experience for users, allowing short-hands similar to the following: $event = $dispatcher->dispatch(new SomeEvent('some context')); $items = $dispatcher->dispatch(new ItemCollector())->getItems(); The EventDispatcher::dispatch() interface, however, has no return type specified. That is primarily for backward compatibility with existing implementations to make it easier for them to adopt the new interface. Additionally, as Events can be any arbitrary object the return type could only have been object , which would provide only minimal (albeit non-zero) value, as that type declaration would not provide IDEs with any useful information nor would it effectively enforce that the same Event is returned. The method return was thus left syntactically untyped. However, returning the same Event object from dispatch() is still a requirement and failure to do so is a violation of the specification.","title":"4.6 Return values"},{"location":"accepted/PSR-14-event-dispatcher-meta/#5-people","text":"The Event Manager Working Group consisted of:","title":"5. People"},{"location":"accepted/PSR-14-event-dispatcher-meta/#51-editor","text":"Larry Garfield","title":"5.1 Editor"},{"location":"accepted/PSR-14-event-dispatcher-meta/#52-sponsor","text":"Cees-Jan Kiewiet","title":"5.2 Sponsor"},{"location":"accepted/PSR-14-event-dispatcher-meta/#53-working-group-members","text":"Benjamin Mack Elizabeth Smith Ryan Weaver Matthew Weier O'Phinney","title":"5.3 Working Group Members"},{"location":"accepted/PSR-14-event-dispatcher-meta/#6-votes","text":"Entrance vote Review Period Initiation Acceptance","title":"6. Votes"},{"location":"accepted/PSR-14-event-dispatcher-meta/#7-relevant-links","text":"Inspiration Mailing List Thread Entrance vote Informal poll on package structure Informal poll on naming structure","title":"7. Relevant Links"},{"location":"accepted/PSR-14-event-dispatcher/","text":"Event Dispatcher Event Dispatching is a common and well-tested mechanism to allow developers to inject logic into an application easily and consistently. The goal of this PSR is to establish a common mechanism for event-based extension and collaboration so that libraries and components may be reused more freely between various applications and frameworks. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . Goal Having common interfaces for dispatching and handling events allows developers to create libraries that can interact with many frameworks and other libraries in a common fashion. Some examples: A security framework that will prevent saving/accessing data when a user doesn't have permission. A common full page caching system. Libraries that extend other libraries, regardless of what framework they are both integrated into. A logging package to track all actions taken within the application Definitions Event - An Event is a message produced by an Emitter . It may be any arbitrary PHP object. Listener - A Listener is any PHP callable that expects to be passed an Event. Zero or more Listeners may be passed the same Event. A Listener MAY enqueue some other asynchronous behavior if it so chooses. Emitter - An Emitter is any arbitrary code that wishes to dispatch an Event. This is also known as the \"calling code\". It is not represented by any particular data structure but refers to the use case. Dispatcher - A Dispatcher is a service object that is given an Event object by an Emitter. The Dispatcher is responsible for ensuring that the Event is passed to all relevant Listeners, but MUST defer determining the responsible listeners to a Listener Provider. Listener Provider - A Listener Provider is responsible for determining what Listeners are relevant for a given Event, but MUST NOT call the Listeners itself. A Listener Provider may specify zero or more relevant Listeners. Events Events are objects that act as the unit of communication between an Emitter and appropriate Listeners. Event objects MAY be mutable should the use case call for Listeners providing information back to the Emitter. However, if no such bidirectional communication is needed then it is RECOMMENDED that the Event be defined as immutable; i.e., defined such that it lacks mutator methods. Implementers MUST assume that the same object will be passed to all Listeners. It is RECOMMENDED, but NOT REQUIRED, that Event objects support lossless serialization and deserialization; $event == unserialize(serialize($event)) SHOULD hold true. Objects MAY leverage PHP\u2019s Serializable interface, __sleep() or __wakeup() magic methods, or similar language functionality if appropriate. Stoppable Events A Stoppable Event is a special case of Event that contains additional ways to prevent further Listeners from being called. It is indicated by implementing the StoppableEventInterface . An Event that implements StoppableEventInterface MUST return true from isPropagationStopped() when whatever Event it represents has been completed. It is up to the implementer of the class to determine when that is. For example, an Event that is asking for a PSR-7 RequestInterface object to be matched with a corresponding ResponseInterface object could have a setResponse(ResponseInterface $res) method for a Listener to call, which causes isPropagationStopped() to return true . Listeners A Listener may be any PHP callable. A Listener MUST have one and only one parameter, which is the Event to which it responds. Listeners SHOULD type hint that parameter as specifically as is relevant for their use case; that is, a Listener MAY type hint against an interface to indicate it is compatible with any Event type that implements that interface, or to a specific implementation of that interface. A Listener SHOULD have a void return, and SHOULD type hint that return explicitly. A Dispatcher MUST ignore return values from Listeners. A Listener MAY delegate actions to other code. That includes a Listener being a thin wrapper around an object that runs the actual business logic. A Listener MAY enqueue information from the Event for later processing by a secondary process, using cron, a queue server, or similar techniques. It MAY serialize the Event object itself to do so; however, care should be taken that not all Event objects may be safely serializable. A secondary process MUST assume that any changes it makes to an Event object will NOT propagate to other Listeners. Dispatcher A Dispatcher is a service object implementing EventDispatcherInterface . It is responsible for retrieving Listeners from a Listener Provider for the Event dispatched, and invoking each Listener with that Event. A Dispatcher: MUST call Listeners synchronously in the order they are returned from a ListenerProvider. MUST return the same Event object it was passed after it is done invoking Listeners. MUST NOT return to the Emitter until all Listeners have executed. If passed a Stoppable Event, a Dispatcher MUST call isPropagationStopped() on the Event before each Listener has been called. If that method returns true it MUST return the Event to the Emitter immediately and MUST NOT call any further Listeners. This implies that if an Event is passed to the Dispatcher that always returns true from isPropagationStopped() , zero listeners will be called. A Dispatcher SHOULD assume that any Listener returned to it from a Listener Provider is type-safe. That is, the Dispatcher SHOULD assume that calling $listener($event) will not produce a TypeError . Error handling An Exception or Error thrown by a Listener MUST block the execution of any further Listeners. An Exception or Error thrown by a Listener MUST be allowed to propagate back up to the Emitter. A Dispatcher MAY catch a thrown object to log it, allow additional action to be taken, etc., but then MUST rethrow the original throwable. Listener Provider A Listener Provider is a service object responsible for determining what Listeners are relevant to and should be called for a given Event. It may determine both what Listeners are relevant and the order in which to return them by whatever means it chooses. That MAY include: Allowing for some form of registration mechanism so that implementers may assign a Listener to an Event in a fixed order. Deriving a list of applicable Listeners through reflection based on the type and implemented interfaces of the Event. Generating a compiled list of Listeners ahead of time that may be consulted at runtime. Implementing some form of access control so that certain Listeners will only be called if the current user has a certain permission. Extracting some information from an object referenced by the Event, such as an Entity, and calling pre-defined lifecycle methods on that object. Delegating its responsibility to one or more other Listener Providers using some arbitrary logic. Any combination of the above, or other mechanisms, MAY be used as desired. Listener Providers SHOULD use the class name of an Event to differentiate one event from another. They MAY also consider any other information on the event as appropriate. Listener Providers MUST treat parent types identically to the Event's own type when determining listener applicability. In the following case: class A {} class B extends A {} $b = new B(); function listener(A $event): void {}; A Listener Provider MUST treat listener() as an applicable listener for $b , as it is type compatible, unless some other criteria prevents it from doing so. Object composition A Dispatcher SHOULD compose a Listener Provider to determine relevant listeners. It is RECOMMENDED that a Listener Provider be implemented as a distinct object from the Dispatcher but that is NOT REQUIRED. Interfaces namespace Psr\\EventDispatcher; /** * Defines a dispatcher for events. */ interface EventDispatcherInterface { /** * Provide all relevant listeners with an event to process. * * @param object $event * The object to process. * * @return object * The Event that was passed, now modified by listeners. */ public function dispatch(object $event); } namespace Psr\\EventDispatcher; /** * Mapper from an event to the listeners that are applicable to that event. */ interface ListenerProviderInterface { /** * @param object $event * An event for which to return the relevant listeners. * @return iterable<callable> * An iterable (array, iterator, or generator) of callables. Each * callable MUST be type-compatible with $event. */ public function getListenersForEvent(object $event) : iterable; } namespace Psr\\EventDispatcher; /** * An Event whose processing may be interrupted when the event has been handled. * * A Dispatcher implementation MUST check to determine if an Event * is marked as stopped after each listener is called. If it is then it should * return immediately without calling any further Listeners. */ interface StoppableEventInterface { /** * Is propagation stopped? * * This will typically only be used by the Dispatcher to determine if the * previous listener halted propagation. * * @return bool * True if the Event is complete and no further listeners should be called. * False to continue calling listeners. */ public function isPropagationStopped() : bool; }","title":"PSR 14 event dispatcher"},{"location":"accepted/PSR-14-event-dispatcher/#event-dispatcher","text":"Event Dispatching is a common and well-tested mechanism to allow developers to inject logic into an application easily and consistently. The goal of this PSR is to establish a common mechanism for event-based extension and collaboration so that libraries and components may be reused more freely between various applications and frameworks. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"Event Dispatcher"},{"location":"accepted/PSR-14-event-dispatcher/#goal","text":"Having common interfaces for dispatching and handling events allows developers to create libraries that can interact with many frameworks and other libraries in a common fashion. Some examples: A security framework that will prevent saving/accessing data when a user doesn't have permission. A common full page caching system. Libraries that extend other libraries, regardless of what framework they are both integrated into. A logging package to track all actions taken within the application","title":"Goal"},{"location":"accepted/PSR-14-event-dispatcher/#definitions","text":"Event - An Event is a message produced by an Emitter . It may be any arbitrary PHP object. Listener - A Listener is any PHP callable that expects to be passed an Event. Zero or more Listeners may be passed the same Event. A Listener MAY enqueue some other asynchronous behavior if it so chooses. Emitter - An Emitter is any arbitrary code that wishes to dispatch an Event. This is also known as the \"calling code\". It is not represented by any particular data structure but refers to the use case. Dispatcher - A Dispatcher is a service object that is given an Event object by an Emitter. The Dispatcher is responsible for ensuring that the Event is passed to all relevant Listeners, but MUST defer determining the responsible listeners to a Listener Provider. Listener Provider - A Listener Provider is responsible for determining what Listeners are relevant for a given Event, but MUST NOT call the Listeners itself. A Listener Provider may specify zero or more relevant Listeners.","title":"Definitions"},{"location":"accepted/PSR-14-event-dispatcher/#events","text":"Events are objects that act as the unit of communication between an Emitter and appropriate Listeners. Event objects MAY be mutable should the use case call for Listeners providing information back to the Emitter. However, if no such bidirectional communication is needed then it is RECOMMENDED that the Event be defined as immutable; i.e., defined such that it lacks mutator methods. Implementers MUST assume that the same object will be passed to all Listeners. It is RECOMMENDED, but NOT REQUIRED, that Event objects support lossless serialization and deserialization; $event == unserialize(serialize($event)) SHOULD hold true. Objects MAY leverage PHP\u2019s Serializable interface, __sleep() or __wakeup() magic methods, or similar language functionality if appropriate.","title":"Events"},{"location":"accepted/PSR-14-event-dispatcher/#stoppable-events","text":"A Stoppable Event is a special case of Event that contains additional ways to prevent further Listeners from being called. It is indicated by implementing the StoppableEventInterface . An Event that implements StoppableEventInterface MUST return true from isPropagationStopped() when whatever Event it represents has been completed. It is up to the implementer of the class to determine when that is. For example, an Event that is asking for a PSR-7 RequestInterface object to be matched with a corresponding ResponseInterface object could have a setResponse(ResponseInterface $res) method for a Listener to call, which causes isPropagationStopped() to return true .","title":"Stoppable Events"},{"location":"accepted/PSR-14-event-dispatcher/#listeners","text":"A Listener may be any PHP callable. A Listener MUST have one and only one parameter, which is the Event to which it responds. Listeners SHOULD type hint that parameter as specifically as is relevant for their use case; that is, a Listener MAY type hint against an interface to indicate it is compatible with any Event type that implements that interface, or to a specific implementation of that interface. A Listener SHOULD have a void return, and SHOULD type hint that return explicitly. A Dispatcher MUST ignore return values from Listeners. A Listener MAY delegate actions to other code. That includes a Listener being a thin wrapper around an object that runs the actual business logic. A Listener MAY enqueue information from the Event for later processing by a secondary process, using cron, a queue server, or similar techniques. It MAY serialize the Event object itself to do so; however, care should be taken that not all Event objects may be safely serializable. A secondary process MUST assume that any changes it makes to an Event object will NOT propagate to other Listeners.","title":"Listeners"},{"location":"accepted/PSR-14-event-dispatcher/#dispatcher","text":"A Dispatcher is a service object implementing EventDispatcherInterface . It is responsible for retrieving Listeners from a Listener Provider for the Event dispatched, and invoking each Listener with that Event. A Dispatcher: MUST call Listeners synchronously in the order they are returned from a ListenerProvider. MUST return the same Event object it was passed after it is done invoking Listeners. MUST NOT return to the Emitter until all Listeners have executed. If passed a Stoppable Event, a Dispatcher MUST call isPropagationStopped() on the Event before each Listener has been called. If that method returns true it MUST return the Event to the Emitter immediately and MUST NOT call any further Listeners. This implies that if an Event is passed to the Dispatcher that always returns true from isPropagationStopped() , zero listeners will be called. A Dispatcher SHOULD assume that any Listener returned to it from a Listener Provider is type-safe. That is, the Dispatcher SHOULD assume that calling $listener($event) will not produce a TypeError .","title":"Dispatcher"},{"location":"accepted/PSR-14-event-dispatcher/#error-handling","text":"An Exception or Error thrown by a Listener MUST block the execution of any further Listeners. An Exception or Error thrown by a Listener MUST be allowed to propagate back up to the Emitter. A Dispatcher MAY catch a thrown object to log it, allow additional action to be taken, etc., but then MUST rethrow the original throwable.","title":"Error handling"},{"location":"accepted/PSR-14-event-dispatcher/#listener-provider","text":"A Listener Provider is a service object responsible for determining what Listeners are relevant to and should be called for a given Event. It may determine both what Listeners are relevant and the order in which to return them by whatever means it chooses. That MAY include: Allowing for some form of registration mechanism so that implementers may assign a Listener to an Event in a fixed order. Deriving a list of applicable Listeners through reflection based on the type and implemented interfaces of the Event. Generating a compiled list of Listeners ahead of time that may be consulted at runtime. Implementing some form of access control so that certain Listeners will only be called if the current user has a certain permission. Extracting some information from an object referenced by the Event, such as an Entity, and calling pre-defined lifecycle methods on that object. Delegating its responsibility to one or more other Listener Providers using some arbitrary logic. Any combination of the above, or other mechanisms, MAY be used as desired. Listener Providers SHOULD use the class name of an Event to differentiate one event from another. They MAY also consider any other information on the event as appropriate. Listener Providers MUST treat parent types identically to the Event's own type when determining listener applicability. In the following case: class A {} class B extends A {} $b = new B(); function listener(A $event): void {}; A Listener Provider MUST treat listener() as an applicable listener for $b , as it is type compatible, unless some other criteria prevents it from doing so.","title":"Listener Provider"},{"location":"accepted/PSR-14-event-dispatcher/#object-composition","text":"A Dispatcher SHOULD compose a Listener Provider to determine relevant listeners. It is RECOMMENDED that a Listener Provider be implemented as a distinct object from the Dispatcher but that is NOT REQUIRED.","title":"Object composition"},{"location":"accepted/PSR-14-event-dispatcher/#interfaces","text":"namespace Psr\\EventDispatcher; /** * Defines a dispatcher for events. */ interface EventDispatcherInterface { /** * Provide all relevant listeners with an event to process. * * @param object $event * The object to process. * * @return object * The Event that was passed, now modified by listeners. */ public function dispatch(object $event); } namespace Psr\\EventDispatcher; /** * Mapper from an event to the listeners that are applicable to that event. */ interface ListenerProviderInterface { /** * @param object $event * An event for which to return the relevant listeners. * @return iterable<callable> * An iterable (array, iterator, or generator) of callables. Each * callable MUST be type-compatible with $event. */ public function getListenersForEvent(object $event) : iterable; } namespace Psr\\EventDispatcher; /** * An Event whose processing may be interrupted when the event has been handled. * * A Dispatcher implementation MUST check to determine if an Event * is marked as stopped after each listener is called. If it is then it should * return immediately without calling any further Listeners. */ interface StoppableEventInterface { /** * Is propagation stopped? * * This will typically only be used by the Dispatcher to determine if the * previous listener halted propagation. * * @return bool * True if the Event is complete and no further listeners should be called. * False to continue calling listeners. */ public function isPropagationStopped() : bool; }","title":"Interfaces"},{"location":"accepted/PSR-15-request-handlers-meta/","text":"HTTP Server Request Handlers Meta Document 1. Summary The purpose of this PSR is to define formal interfaces for HTTP server request handlers (\"request handlers\") and HTTP server request middleware (\"middleware\") that are compatible with HTTP messages as defined in PSR-7 or subsequent replacement PSRs. Note: All references to \"request handlers\" and \"middleware\" are specific to server request processing. 2. Why Bother? The HTTP messages specification does not contain any reference to request handlers or middleware. Request handlers are a fundamental part of any web application. The handler is the component that receives a request and produces a response. Nearly all code that works with HTTP messages will have some kind of request handler. Middleware has existed for many years in the PHP ecosystem. The general concept of reusable middleware was popularized by StackPHP . Since the release of HTTP messages as a PSR, many frameworks have adopted middleware that use HTTP message interfaces. Agreeing on formal request handler and middleware interfaces eliminates several problems and has a number of benefits: Provides a formal standard for developers to commit to. Enables any middleware component to run in any compatible framework. Eliminates duplication of similar interfaces defined by various frameworks. Avoids minor discrepancies in method signatures. 3. Scope 3.1 Goals Create a request handler interface that uses HTTP messages. Create a middleware interface that uses HTTP messages. Implement request handler and middleware signatures that are based on best practices. Ensure that request handlers and middleware will be compatible with any implementation of HTTP messages. 3.2 Non-Goals Attempting to define the mechanism by which HTTP responses are created. Attempting to define interfaces for client/asynchronous middleware. Attempting to define how middleware is dispatched. 4. Request Handler Approaches There are many approaches to request handlers that use HTTP messages. However, the general process is the same in all of them: Given an HTTP request, produce an HTTP response for that request. The internal requirements of that process will vary from framework to framework and application to application. This proposal makes no effort to determine what that process should be. 5. Middleware Approaches There are currently two common approaches to middleware that use HTTP messages. 5.1 Double Pass The signature used by most middleware implementations has been mostly the same and is based on Express middleware , which is defined as: fn(request, response, next): response Based on the middleware implementations already used by frameworks that have adopted this signature, the following commonalities are observed: The middleware is defined as a callable . The middleware is passed 3 arguments during invocation: A ServerRequestInterface implementation. A ResponseInterface implementation. A callable that receives the request and response to delegate to the next middleware. A significant number of projects provide and/or use exactly the same interface. This approach is often referred to as \"double pass\" in reference to both the request and response being passed to the middleware. 5.1.1 Projects Using Double Pass mindplay/middleman v1 relay/relay v1 slim/slim v3 zendframework/zend-stratigility v1 5.1.2 Middleware Implementing Double Pass bitexpert/adroit akrabat/rka-ip-address-middleware akrabat/rka-scheme-and-host-detection-middleware bear/middleware los/api-problem los/los-rate-limit monii/monii-action-handler-psr7-middleware monii/monii-nikic-fast-route-psr7-middleware monii/monii-response-assertion-psr7-middleware mtymek/blast-base-url ocramius/psr7-session oscarotero/psr7-middlewares php-middleware/block-robots php-middleware/http-authentication php-middleware/log-http-messages php-middleware/maintenance php-middleware/phpdebugbar php-middleware/request-id relay/middleware The primary downside of this interface is that the while the interface itself is a callable, there is currently no way to strictly type a closure. 5.2 Single Pass (Lambda) The other approach to middleware is much closer to StackPHP style and is defined as: fn(request, next): response Middleware taking this approach generally has the following commonalities: The middleware is defined with a specific interface with a method that takes the request for processing. The middleware is passed 2 arguments during invocation: An HTTP request message. A request handler to which the middleware can delegate the responsibility of producing an HTTP response message. In this form, middleware has no access to a response until one is generated by the request handler. Middleware can then modify the response before returning it. This approach is often referred to as \"single pass\" or \"lambda\" in reference to only the request being passed to the middleware. 5.2.1 Projects Using Single Pass There are fewer examples of this approach within projects using HTTP messages, with one notable exception. Guzzle middleware is focused on outgoing (client) requests and uses this signature: function (RequestInterface $request, array $options): ResponseInterface 5.2.2 Additional Projects Using Single Pass There are also significant projects that predate HTTP messages using this approach. StackPHP is based on Symfony HttpKernel and supports middleware with this signature: function handle(Request $request, $type, $catch): Response Note: While Stack has multiple arguments, a response object is not included. Laravel middleware uses Symfony components and supports middleware with this signature: function handle(Request $request, callable $next): Response 5.3 Comparison of Approaches The single pass approach to middleware has been well established in the PHP community for many years. This is most evident with the large number of packages that are based around StackPHP. The double pass approach is much newer but has been almost universally used by early adopters of HTTP messages (PSR-7). 5.4 Chosen Approach Despite the nearly universal adoption of the double-pass approach, there are significant issues regarding implementation. The most severe is that passing an empty response has no guarantees that the response is in a usable state. This is further exacerbated by the fact that a middleware may modify the response before passing it for further processing. Further compounding the problem is that there is no way to ensure that the response body has not been written to, which can lead to incomplete output or error responses being sent with cache headers attached. It is also possible to end up with corrupted body content when writing over existing body content if the new content is shorter than the original. The most effective way to resolve these issues is to always provide a fresh stream when modifying the body of a message. Some have argued that passing the response helps ensure dependency inversion. While it is true that it helps avoid depending on a specific implementation of HTTP messages, the problem can also be resolved by injecting factories into the middleware to create HTTP message objects, or by injecting empty message instances. With the creation of HTTP Factories in PSR-17 , a standard approach to handling dependency inversion is possible. A more subjective, but also important, concern is that existing double-pass middleware typically uses the callable type hint to refer to middleware. This makes strict typing impossible, as there is no assurance that the callable being passed implements a middleware signature, which reduces runtime safety. Due to these significant issues, the lambda approach has been chosen for this proposal. 6. Design Decisions 6.1 Request Handler Design The RequestHandlerInterface defines a single method that accepts a request and MUST return a response. The request handler MAY delegate to another handler. Why is a server request required? To make it clear that the request handler can only be used in a server side context. In an client side context, a promise would likely be returned instead of a response. Why the term \"handler\"? The term \"handler\" means something designated to manage or control. In terms of request processing, a request handler is the point where the request must be acted upon to create a response. As opposed to the term \"delegate\", which was used in a previous version of this specification, the internal behavior of this interface is not specified. As long as the request handler ultimately produces a response, it is valid. Why doesn't request handler use __invoke ? Using __invoke is less transparent than using a named method. It also makes it easier to call the request handler when it is assigned to a class variable, without using call_user_func or other less common syntax. See PHP-FIG discussion of FrameInterface for additional information. 6.2 Middleware Design The MiddlewareInterface defines a single method that accepts an HTTP request and a request handler and must return a response. The middleware may: Evolve the request before passing it to the request handler. Evolve the response received from the request handler before returning it. Create and return a response without passing the request to the request handler, thereby handling the request itself. When delegating from one middleware to another in a sequence, one approach for dispatching systems is to use an intermediary request handler composing the middleware sequence as a way to link middleware together. The final or innermost middleware will act as a gateway to application code and generate a response from its results; alternately, the middleware MAY delegate this responsibility to a dedicated request handler. Why doesn't middleware use __invoke ? Doing so would conflict with existing middleware that implements the double-pass approach and may want to implement the middleware interface for purposes of forward compatibility with this specification. Why the name process() ? We reviewed a number of existing monolithic and middleware frameworks to determine what method(s) each defined for processing incoming requests. We found the following were commonly used: __invoke (within middleware systems, such as Slim, Expressive, Relay, etc.) handle (in particular, software derived from Symfony's HttpKernel ) dispatch (Zend Framework's DispatchableInterface ) We chose to allow a forward-compatible approach for such classes to repurpose themselves as middleware (or middleware compatible with this specification), and thus needed to choose a name not in common usage. As such, we chose process , to indicate processing a request. Why is a server request required? To make it clear that the middleware can only be used in a synchronous, server side context. While not all middleware will need to use the additional methods defined by the server request interface, outbound requests are typically processed asynchronously and would typically return a promise of a response. (This is primarily due to the fact that multiple requests can be made in parallel and processed as they are returned.) It is outside the scope of this proposal to address the needs of asynchronous request/response life cycles. Attempting to define client middleware would be premature at this point. Any future proposal that is focused on client side request processing should have the opportunity to define a standard that is specific to the nature of asynchronous middleware. See PHP-FIG discussion about client vs server side middleware for additional information. What is the role of the request handler? Middleware has the following roles: Producing a response on its own. If specific request conditions are met, the middleware can produce and return a response. Returning the result of the request handler. In cases where the middleware cannot produce its own response, it can delegate to the request handler to produce one; sometimes this may involve providing a transformed request (e.g., to inject a request attribute, or the results of parsing the request body). Manipulating and returning the response produced by the request handler. In some cases, the middleware may be interested in manipulating the response the request handler returns (e.g., to gzip the response body, to add CORS headers, etc.). In such cases, the middleware will capture the response returned by the request handler, and return a transformed response on completion. In these latter two cases, the middleware may have code such as the following: // Straight delegation: return $handler->handle($request); // Capturing the response to manipulate: $response = $handler->handle($request); How the handler acts is entirely up to the developer, so long as it produces a response. In one common scenario, the handler implements a queue or a stack of middleware instances internally. In such cases, calling $handler->handle($request) will advance the internal pointer, pull the middleware associated with that pointer, and call it using $middleware->process($request, $this) . If no more middleware exists, it will generally either raise an exception or return a canned response. Another possibility is for routing middleware that matches the incoming server request to a specific handler, and then returns the response generated by executing that handler. If unable to route to a handler, it would instead execute the handler provided to the middleware. (This sort of mechanism can even be used in conjunction with middleware queues and stacks.) 6.3 Example Interface Interactions The two interfaces, RequestHandlerInterface and MiddlewareInterface , were designed to work in conjunction with one another. Middleware gains flexibility when de-coupled from any over-arching application layer, and instead only relying on the provided request handler to produce a response. Two approaches to middleware dispatch systems that the Working Group observed and/or implemented are demonstrated below. Additionally, examples of re-usable middleware are provided to demonstrate how to write middleware that is loosely-coupled. Please note that these are not suggested as definitive or exclusive approaches to defining middleware dispatch systems. Queue-based request handler In this approach, a request handler maintains a queue of middleware, and a fallback response to return if the queue is exhausted without returning a response. When executing the first middleware, the queue passes itself as a request handler to the middleware. class QueueRequestHandler implements RequestHandlerInterface { private $middleware = []; private $fallbackHandler; public function __construct(RequestHandlerInterface $fallbackHandler) { $this->fallbackHandler = $fallbackHandler; } public function add(MiddlewareInterface $middleware) { $this->middleware[] = $middleware; } public function handle(ServerRequestInterface $request): ResponseInterface { // Last middleware in the queue has called on the request handler. if (0 === count($this->middleware)) { return $this->fallbackHandler->handle($request); } $middleware = array_shift($this->middleware); return $middleware->process($request, $this); } } An application bootstrap might then look like this: // Fallback handler: $fallbackHandler = new NotFoundHandler(); // Create request handler instance: $app = new QueueRequestHandler($fallbackHandler); // Add one or more middleware: $app->add(new AuthorizationMiddleware()); $app->add(new RoutingMiddleware()); // execute it: $response = $app->handle(ServerRequestFactory::fromGlobals()); This system has two request handlers: one that will produce a response if the last middleware delegates to the request handler, and one for dispatching the middleware layers. (In this example, the RoutingMiddleware will likely execute composed handlers on a successful route match; see more on that below.) This approach has the following benefits: Middleware does not need to know anything about any other middleware or how it is composed in the application. The QueueRequestHandler is agnostic of the PSR-7 implementation in use. Middleware is executed in the order it is added to the application, making the code explicit. Generation of the \"fallback\" response is delegated to the application developer. This allows the developer to determine whether that should be a \"404 Not Found\" condition, a default page, etc. Decoration-based request handler In this approach, a request handler implementation decorates both a middleware instance and a fallback request handler to pass to it. The application is built from the outside-in, passing each request handler \"layer\" to the next outer one. class DecoratingRequestHandler implements RequestHandlerInterface { private $middleware; private $nextHandler; public function __construct(MiddlewareInterface $middleware, RequestHandlerInterface $nextHandler) { $this->middleware = $middleware; $this->nextHandler = $nextHandler; } public function handle(ServerRequestInterface $request): ResponseInterface { return $this->middleware->process($request, $this->nextHandler); } } // Create a response prototype to return if no middleware can produce a response // on its own. This could be a 404, 500, or default page. $responsePrototype = (new Response())->withStatus(404); $innerHandler = new class ($responsePrototype) implements RequestHandlerInterface { private $responsePrototype; public function __construct(ResponseInterface $responsePrototype) { $this->responsePrototype = $responsePrototype; } public function handle(ServerRequestInterface $request): ResponseInterface { return $this->responsePrototype; } }; $layer1 = new DecoratingRequestHandler(new RoutingMiddleware(), $innerHandler); $layer2 = new DecoratingRequestHandler(new AuthorizationMiddleware(), $layer1); $response = $layer2->handle(ServerRequestFactory::fromGlobals()); Similar to the queue-based middleware, request handlers serve two purposes in this system: Producing a fallback response if no other layer does. Dispatching middleware. Reusable Middleware Examples In the examples above, we have two middleware composed in each. In order for these to work in either situation, we need to write them such that they interact appropriately. Implementors of middleware striving for maximum interoperability may want to consider the following guidelines: Test the request for a required condition. If it does not satisfy that condition, use a composed prototype response or a composed response factory to generate and return a response. If pre-conditions are met, delegate creation of the response to the provided request handler, optionally providing a \"new\" request by manipulating the provided request (e.g., $handler->handle($request->withAttribute('foo', 'bar') ). Either pass the response returned by the request handler unaltered, or provide a new response by manipulating the one returned (e.g., return $response->withHeader('X-Foo-Bar', 'baz') ). The AuthorizationMiddleware is one that will exercise all three of these guidelines: If authorization is required, but the request is not authorized, it will use a composed prototype response to produce an \"unauthorized\" response. If authorization is not required, it will delegate the request to the handler without changes. If authorization is required and the request is authorized, it will delegate the request to the handler, and sign the response returned based on the request. class AuthorizationMiddleware implements MiddlewareInterface { private $authorizationMap; public function __construct(AuthorizationMap $authorizationMap) { $this->authorizationMap = $authorizationMap; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface { if (! $this->authorizationMap->needsAuthorization($request)) { return $handler->handle($request); } if (! $this->authorizationMap->isAuthorized($request)) { return $this->authorizationMap->prepareUnauthorizedResponse(); } $response = $handler->handle($request); return $this->authorizationMap->signResponse($response, $request); } } Note that the middleware is not concerned with how the request handler is implemented; it merely uses it to produce a response when pre-conditions have been met. The RoutingMiddleware implementation described below follows a similar process: it analyzes the request to see if it matches known routes. In this particular implementation, routes map to request handlers, and the middleware essentially delegates to them in order to produce a response. However, in the case that no route is matched, it will execute the handler passed to it to produce the response to return. class RoutingMiddleware implements MiddlewareInterface { private $router; public function __construct(Router $router) { $this->router = $router; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface { $result = $this->router->match($request); if ($result->isSuccess()) { return $result->getHandler()->handle($request); } return $handler->handle($request); } } 7. People This PSR was produced by a FIG Working Group with the following members: Matthew Weier O'Phinney (sponsor), mweierophinney@gmail.com Woody Gilk (editor), woody.gilk@gmail.com Glenn Eggleton Matthieu Napoli Oscar Otero Korvin Szanto Stefano Torresi The working group would also like to acknowledge the contributions of: Jason Coward, jason@opengeek.com Paul M. Jones, pmjones88@gmail.com Rasmus Schultz, rasmus@mindplay.dk 8. Votes Working Group Formation Review Period Initiation Acceptance 9. Relevant Links Note: Order descending chronologically. PHP-FIG mailing list thread The PHP League middleware proposal PHP-FIG discussion of FrameInterface PHP-FIG discussion about client vs server side middleware 10. Errata ...","title":"PSR 15 request handlers meta"},{"location":"accepted/PSR-15-request-handlers-meta/#http-server-request-handlers-meta-document","text":"","title":"HTTP Server Request Handlers Meta Document"},{"location":"accepted/PSR-15-request-handlers-meta/#1-summary","text":"The purpose of this PSR is to define formal interfaces for HTTP server request handlers (\"request handlers\") and HTTP server request middleware (\"middleware\") that are compatible with HTTP messages as defined in PSR-7 or subsequent replacement PSRs. Note: All references to \"request handlers\" and \"middleware\" are specific to server request processing.","title":"1. Summary"},{"location":"accepted/PSR-15-request-handlers-meta/#2-why-bother","text":"The HTTP messages specification does not contain any reference to request handlers or middleware. Request handlers are a fundamental part of any web application. The handler is the component that receives a request and produces a response. Nearly all code that works with HTTP messages will have some kind of request handler. Middleware has existed for many years in the PHP ecosystem. The general concept of reusable middleware was popularized by StackPHP . Since the release of HTTP messages as a PSR, many frameworks have adopted middleware that use HTTP message interfaces. Agreeing on formal request handler and middleware interfaces eliminates several problems and has a number of benefits: Provides a formal standard for developers to commit to. Enables any middleware component to run in any compatible framework. Eliminates duplication of similar interfaces defined by various frameworks. Avoids minor discrepancies in method signatures.","title":"2. Why Bother?"},{"location":"accepted/PSR-15-request-handlers-meta/#3-scope","text":"","title":"3. Scope"},{"location":"accepted/PSR-15-request-handlers-meta/#31-goals","text":"Create a request handler interface that uses HTTP messages. Create a middleware interface that uses HTTP messages. Implement request handler and middleware signatures that are based on best practices. Ensure that request handlers and middleware will be compatible with any implementation of HTTP messages.","title":"3.1 Goals"},{"location":"accepted/PSR-15-request-handlers-meta/#32-non-goals","text":"Attempting to define the mechanism by which HTTP responses are created. Attempting to define interfaces for client/asynchronous middleware. Attempting to define how middleware is dispatched.","title":"3.2 Non-Goals"},{"location":"accepted/PSR-15-request-handlers-meta/#4-request-handler-approaches","text":"There are many approaches to request handlers that use HTTP messages. However, the general process is the same in all of them: Given an HTTP request, produce an HTTP response for that request. The internal requirements of that process will vary from framework to framework and application to application. This proposal makes no effort to determine what that process should be.","title":"4. Request Handler Approaches"},{"location":"accepted/PSR-15-request-handlers-meta/#5-middleware-approaches","text":"There are currently two common approaches to middleware that use HTTP messages.","title":"5. Middleware Approaches"},{"location":"accepted/PSR-15-request-handlers-meta/#51-double-pass","text":"The signature used by most middleware implementations has been mostly the same and is based on Express middleware , which is defined as: fn(request, response, next): response Based on the middleware implementations already used by frameworks that have adopted this signature, the following commonalities are observed: The middleware is defined as a callable . The middleware is passed 3 arguments during invocation: A ServerRequestInterface implementation. A ResponseInterface implementation. A callable that receives the request and response to delegate to the next middleware. A significant number of projects provide and/or use exactly the same interface. This approach is often referred to as \"double pass\" in reference to both the request and response being passed to the middleware.","title":"5.1 Double Pass"},{"location":"accepted/PSR-15-request-handlers-meta/#511-projects-using-double-pass","text":"mindplay/middleman v1 relay/relay v1 slim/slim v3 zendframework/zend-stratigility v1","title":"5.1.1 Projects Using Double Pass"},{"location":"accepted/PSR-15-request-handlers-meta/#512-middleware-implementing-double-pass","text":"bitexpert/adroit akrabat/rka-ip-address-middleware akrabat/rka-scheme-and-host-detection-middleware bear/middleware los/api-problem los/los-rate-limit monii/monii-action-handler-psr7-middleware monii/monii-nikic-fast-route-psr7-middleware monii/monii-response-assertion-psr7-middleware mtymek/blast-base-url ocramius/psr7-session oscarotero/psr7-middlewares php-middleware/block-robots php-middleware/http-authentication php-middleware/log-http-messages php-middleware/maintenance php-middleware/phpdebugbar php-middleware/request-id relay/middleware The primary downside of this interface is that the while the interface itself is a callable, there is currently no way to strictly type a closure.","title":"5.1.2 Middleware Implementing Double Pass"},{"location":"accepted/PSR-15-request-handlers-meta/#52-single-pass-lambda","text":"The other approach to middleware is much closer to StackPHP style and is defined as: fn(request, next): response Middleware taking this approach generally has the following commonalities: The middleware is defined with a specific interface with a method that takes the request for processing. The middleware is passed 2 arguments during invocation: An HTTP request message. A request handler to which the middleware can delegate the responsibility of producing an HTTP response message. In this form, middleware has no access to a response until one is generated by the request handler. Middleware can then modify the response before returning it. This approach is often referred to as \"single pass\" or \"lambda\" in reference to only the request being passed to the middleware.","title":"5.2 Single Pass (Lambda)"},{"location":"accepted/PSR-15-request-handlers-meta/#521-projects-using-single-pass","text":"There are fewer examples of this approach within projects using HTTP messages, with one notable exception. Guzzle middleware is focused on outgoing (client) requests and uses this signature: function (RequestInterface $request, array $options): ResponseInterface","title":"5.2.1 Projects Using Single Pass"},{"location":"accepted/PSR-15-request-handlers-meta/#522-additional-projects-using-single-pass","text":"There are also significant projects that predate HTTP messages using this approach. StackPHP is based on Symfony HttpKernel and supports middleware with this signature: function handle(Request $request, $type, $catch): Response Note: While Stack has multiple arguments, a response object is not included. Laravel middleware uses Symfony components and supports middleware with this signature: function handle(Request $request, callable $next): Response","title":"5.2.2 Additional Projects Using Single Pass"},{"location":"accepted/PSR-15-request-handlers-meta/#53-comparison-of-approaches","text":"The single pass approach to middleware has been well established in the PHP community for many years. This is most evident with the large number of packages that are based around StackPHP. The double pass approach is much newer but has been almost universally used by early adopters of HTTP messages (PSR-7).","title":"5.3 Comparison of Approaches"},{"location":"accepted/PSR-15-request-handlers-meta/#54-chosen-approach","text":"Despite the nearly universal adoption of the double-pass approach, there are significant issues regarding implementation. The most severe is that passing an empty response has no guarantees that the response is in a usable state. This is further exacerbated by the fact that a middleware may modify the response before passing it for further processing. Further compounding the problem is that there is no way to ensure that the response body has not been written to, which can lead to incomplete output or error responses being sent with cache headers attached. It is also possible to end up with corrupted body content when writing over existing body content if the new content is shorter than the original. The most effective way to resolve these issues is to always provide a fresh stream when modifying the body of a message. Some have argued that passing the response helps ensure dependency inversion. While it is true that it helps avoid depending on a specific implementation of HTTP messages, the problem can also be resolved by injecting factories into the middleware to create HTTP message objects, or by injecting empty message instances. With the creation of HTTP Factories in PSR-17 , a standard approach to handling dependency inversion is possible. A more subjective, but also important, concern is that existing double-pass middleware typically uses the callable type hint to refer to middleware. This makes strict typing impossible, as there is no assurance that the callable being passed implements a middleware signature, which reduces runtime safety. Due to these significant issues, the lambda approach has been chosen for this proposal.","title":"5.4 Chosen Approach"},{"location":"accepted/PSR-15-request-handlers-meta/#6-design-decisions","text":"","title":"6. Design Decisions"},{"location":"accepted/PSR-15-request-handlers-meta/#61-request-handler-design","text":"The RequestHandlerInterface defines a single method that accepts a request and MUST return a response. The request handler MAY delegate to another handler.","title":"6.1 Request Handler Design"},{"location":"accepted/PSR-15-request-handlers-meta/#why-is-a-server-request-required","text":"To make it clear that the request handler can only be used in a server side context. In an client side context, a promise would likely be returned instead of a response.","title":"Why is a server request required?"},{"location":"accepted/PSR-15-request-handlers-meta/#why-the-term-handler","text":"The term \"handler\" means something designated to manage or control. In terms of request processing, a request handler is the point where the request must be acted upon to create a response. As opposed to the term \"delegate\", which was used in a previous version of this specification, the internal behavior of this interface is not specified. As long as the request handler ultimately produces a response, it is valid.","title":"Why the term \"handler\"?"},{"location":"accepted/PSR-15-request-handlers-meta/#why-doesnt-request-handler-use-__invoke","text":"Using __invoke is less transparent than using a named method. It also makes it easier to call the request handler when it is assigned to a class variable, without using call_user_func or other less common syntax. See PHP-FIG discussion of FrameInterface for additional information.","title":"Why doesn't request handler use __invoke?"},{"location":"accepted/PSR-15-request-handlers-meta/#62-middleware-design","text":"The MiddlewareInterface defines a single method that accepts an HTTP request and a request handler and must return a response. The middleware may: Evolve the request before passing it to the request handler. Evolve the response received from the request handler before returning it. Create and return a response without passing the request to the request handler, thereby handling the request itself. When delegating from one middleware to another in a sequence, one approach for dispatching systems is to use an intermediary request handler composing the middleware sequence as a way to link middleware together. The final or innermost middleware will act as a gateway to application code and generate a response from its results; alternately, the middleware MAY delegate this responsibility to a dedicated request handler.","title":"6.2 Middleware Design"},{"location":"accepted/PSR-15-request-handlers-meta/#why-doesnt-middleware-use-__invoke","text":"Doing so would conflict with existing middleware that implements the double-pass approach and may want to implement the middleware interface for purposes of forward compatibility with this specification.","title":"Why doesn't middleware use __invoke?"},{"location":"accepted/PSR-15-request-handlers-meta/#why-the-name-process","text":"We reviewed a number of existing monolithic and middleware frameworks to determine what method(s) each defined for processing incoming requests. We found the following were commonly used: __invoke (within middleware systems, such as Slim, Expressive, Relay, etc.) handle (in particular, software derived from Symfony's HttpKernel ) dispatch (Zend Framework's DispatchableInterface ) We chose to allow a forward-compatible approach for such classes to repurpose themselves as middleware (or middleware compatible with this specification), and thus needed to choose a name not in common usage. As such, we chose process , to indicate processing a request.","title":"Why the name process()?"},{"location":"accepted/PSR-15-request-handlers-meta/#why-is-a-server-request-required_1","text":"To make it clear that the middleware can only be used in a synchronous, server side context. While not all middleware will need to use the additional methods defined by the server request interface, outbound requests are typically processed asynchronously and would typically return a promise of a response. (This is primarily due to the fact that multiple requests can be made in parallel and processed as they are returned.) It is outside the scope of this proposal to address the needs of asynchronous request/response life cycles. Attempting to define client middleware would be premature at this point. Any future proposal that is focused on client side request processing should have the opportunity to define a standard that is specific to the nature of asynchronous middleware. See PHP-FIG discussion about client vs server side middleware for additional information.","title":"Why is a server request required?"},{"location":"accepted/PSR-15-request-handlers-meta/#what-is-the-role-of-the-request-handler","text":"Middleware has the following roles: Producing a response on its own. If specific request conditions are met, the middleware can produce and return a response. Returning the result of the request handler. In cases where the middleware cannot produce its own response, it can delegate to the request handler to produce one; sometimes this may involve providing a transformed request (e.g., to inject a request attribute, or the results of parsing the request body). Manipulating and returning the response produced by the request handler. In some cases, the middleware may be interested in manipulating the response the request handler returns (e.g., to gzip the response body, to add CORS headers, etc.). In such cases, the middleware will capture the response returned by the request handler, and return a transformed response on completion. In these latter two cases, the middleware may have code such as the following: // Straight delegation: return $handler->handle($request); // Capturing the response to manipulate: $response = $handler->handle($request); How the handler acts is entirely up to the developer, so long as it produces a response. In one common scenario, the handler implements a queue or a stack of middleware instances internally. In such cases, calling $handler->handle($request) will advance the internal pointer, pull the middleware associated with that pointer, and call it using $middleware->process($request, $this) . If no more middleware exists, it will generally either raise an exception or return a canned response. Another possibility is for routing middleware that matches the incoming server request to a specific handler, and then returns the response generated by executing that handler. If unable to route to a handler, it would instead execute the handler provided to the middleware. (This sort of mechanism can even be used in conjunction with middleware queues and stacks.)","title":"What is the role of the request handler?"},{"location":"accepted/PSR-15-request-handlers-meta/#63-example-interface-interactions","text":"The two interfaces, RequestHandlerInterface and MiddlewareInterface , were designed to work in conjunction with one another. Middleware gains flexibility when de-coupled from any over-arching application layer, and instead only relying on the provided request handler to produce a response. Two approaches to middleware dispatch systems that the Working Group observed and/or implemented are demonstrated below. Additionally, examples of re-usable middleware are provided to demonstrate how to write middleware that is loosely-coupled. Please note that these are not suggested as definitive or exclusive approaches to defining middleware dispatch systems.","title":"6.3 Example Interface Interactions"},{"location":"accepted/PSR-15-request-handlers-meta/#queue-based-request-handler","text":"In this approach, a request handler maintains a queue of middleware, and a fallback response to return if the queue is exhausted without returning a response. When executing the first middleware, the queue passes itself as a request handler to the middleware. class QueueRequestHandler implements RequestHandlerInterface { private $middleware = []; private $fallbackHandler; public function __construct(RequestHandlerInterface $fallbackHandler) { $this->fallbackHandler = $fallbackHandler; } public function add(MiddlewareInterface $middleware) { $this->middleware[] = $middleware; } public function handle(ServerRequestInterface $request): ResponseInterface { // Last middleware in the queue has called on the request handler. if (0 === count($this->middleware)) { return $this->fallbackHandler->handle($request); } $middleware = array_shift($this->middleware); return $middleware->process($request, $this); } } An application bootstrap might then look like this: // Fallback handler: $fallbackHandler = new NotFoundHandler(); // Create request handler instance: $app = new QueueRequestHandler($fallbackHandler); // Add one or more middleware: $app->add(new AuthorizationMiddleware()); $app->add(new RoutingMiddleware()); // execute it: $response = $app->handle(ServerRequestFactory::fromGlobals()); This system has two request handlers: one that will produce a response if the last middleware delegates to the request handler, and one for dispatching the middleware layers. (In this example, the RoutingMiddleware will likely execute composed handlers on a successful route match; see more on that below.) This approach has the following benefits: Middleware does not need to know anything about any other middleware or how it is composed in the application. The QueueRequestHandler is agnostic of the PSR-7 implementation in use. Middleware is executed in the order it is added to the application, making the code explicit. Generation of the \"fallback\" response is delegated to the application developer. This allows the developer to determine whether that should be a \"404 Not Found\" condition, a default page, etc.","title":"Queue-based request handler"},{"location":"accepted/PSR-15-request-handlers-meta/#decoration-based-request-handler","text":"In this approach, a request handler implementation decorates both a middleware instance and a fallback request handler to pass to it. The application is built from the outside-in, passing each request handler \"layer\" to the next outer one. class DecoratingRequestHandler implements RequestHandlerInterface { private $middleware; private $nextHandler; public function __construct(MiddlewareInterface $middleware, RequestHandlerInterface $nextHandler) { $this->middleware = $middleware; $this->nextHandler = $nextHandler; } public function handle(ServerRequestInterface $request): ResponseInterface { return $this->middleware->process($request, $this->nextHandler); } } // Create a response prototype to return if no middleware can produce a response // on its own. This could be a 404, 500, or default page. $responsePrototype = (new Response())->withStatus(404); $innerHandler = new class ($responsePrototype) implements RequestHandlerInterface { private $responsePrototype; public function __construct(ResponseInterface $responsePrototype) { $this->responsePrototype = $responsePrototype; } public function handle(ServerRequestInterface $request): ResponseInterface { return $this->responsePrototype; } }; $layer1 = new DecoratingRequestHandler(new RoutingMiddleware(), $innerHandler); $layer2 = new DecoratingRequestHandler(new AuthorizationMiddleware(), $layer1); $response = $layer2->handle(ServerRequestFactory::fromGlobals()); Similar to the queue-based middleware, request handlers serve two purposes in this system: Producing a fallback response if no other layer does. Dispatching middleware.","title":"Decoration-based request handler"},{"location":"accepted/PSR-15-request-handlers-meta/#reusable-middleware-examples","text":"In the examples above, we have two middleware composed in each. In order for these to work in either situation, we need to write them such that they interact appropriately. Implementors of middleware striving for maximum interoperability may want to consider the following guidelines: Test the request for a required condition. If it does not satisfy that condition, use a composed prototype response or a composed response factory to generate and return a response. If pre-conditions are met, delegate creation of the response to the provided request handler, optionally providing a \"new\" request by manipulating the provided request (e.g., $handler->handle($request->withAttribute('foo', 'bar') ). Either pass the response returned by the request handler unaltered, or provide a new response by manipulating the one returned (e.g., return $response->withHeader('X-Foo-Bar', 'baz') ). The AuthorizationMiddleware is one that will exercise all three of these guidelines: If authorization is required, but the request is not authorized, it will use a composed prototype response to produce an \"unauthorized\" response. If authorization is not required, it will delegate the request to the handler without changes. If authorization is required and the request is authorized, it will delegate the request to the handler, and sign the response returned based on the request. class AuthorizationMiddleware implements MiddlewareInterface { private $authorizationMap; public function __construct(AuthorizationMap $authorizationMap) { $this->authorizationMap = $authorizationMap; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface { if (! $this->authorizationMap->needsAuthorization($request)) { return $handler->handle($request); } if (! $this->authorizationMap->isAuthorized($request)) { return $this->authorizationMap->prepareUnauthorizedResponse(); } $response = $handler->handle($request); return $this->authorizationMap->signResponse($response, $request); } } Note that the middleware is not concerned with how the request handler is implemented; it merely uses it to produce a response when pre-conditions have been met. The RoutingMiddleware implementation described below follows a similar process: it analyzes the request to see if it matches known routes. In this particular implementation, routes map to request handlers, and the middleware essentially delegates to them in order to produce a response. However, in the case that no route is matched, it will execute the handler passed to it to produce the response to return. class RoutingMiddleware implements MiddlewareInterface { private $router; public function __construct(Router $router) { $this->router = $router; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface { $result = $this->router->match($request); if ($result->isSuccess()) { return $result->getHandler()->handle($request); } return $handler->handle($request); } }","title":"Reusable Middleware Examples"},{"location":"accepted/PSR-15-request-handlers-meta/#7-people","text":"This PSR was produced by a FIG Working Group with the following members: Matthew Weier O'Phinney (sponsor), mweierophinney@gmail.com Woody Gilk (editor), woody.gilk@gmail.com Glenn Eggleton Matthieu Napoli Oscar Otero Korvin Szanto Stefano Torresi The working group would also like to acknowledge the contributions of: Jason Coward, jason@opengeek.com Paul M. Jones, pmjones88@gmail.com Rasmus Schultz, rasmus@mindplay.dk","title":"7. People"},{"location":"accepted/PSR-15-request-handlers-meta/#8-votes","text":"Working Group Formation Review Period Initiation Acceptance","title":"8. Votes"},{"location":"accepted/PSR-15-request-handlers-meta/#9-relevant-links","text":"Note: Order descending chronologically. PHP-FIG mailing list thread The PHP League middleware proposal PHP-FIG discussion of FrameInterface PHP-FIG discussion about client vs server side middleware","title":"9. Relevant Links"},{"location":"accepted/PSR-15-request-handlers-meta/#10-errata","text":"...","title":"10. Errata"},{"location":"accepted/PSR-15-request-handlers/","text":"HTTP Server Request Handlers This document describes common interfaces for HTTP server request handlers (\"request handlers\") and HTTP server middleware components (\"middleware\") that use HTTP messages as described by PSR-7 or subsequent replacement PSRs. HTTP request handlers are a fundamental part of any web application. Server-side code receives a request message, processes it, and produces a response message. HTTP middleware is a way to move common request and response processing away from the application layer. The interfaces described in this document are abstractions for request handlers and middleware. Note: All references to \"request handlers\" and \"middleware\" are specific to server request processing. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . References PSR-7 RFC 2119 1. Specification 1.1 Request Handlers A request handler is an individual component that processes a request and produces a response, as defined by PSR-7. A request handler MAY throw an exception if request conditions prevent it from producing a response. The type of exception is not defined. Request handlers using this standard MUST implement the following interface: Psr\\Http\\Server\\RequestHandlerInterface 1.2 Middleware A middleware component is an individual component participating, often together with other middleware components, in the processing of an incoming request and the creation of a resulting response, as defined by PSR-7. A middleware component MAY create and return a response without delegating to a request handler, if sufficient conditions are met. Middleware using this standard MUST implement the following interface: Psr\\Http\\Server\\MiddlewareInterface 1.3 Generating Responses It is RECOMMENDED that any middleware or request handler that generates a response will either compose a prototype of a PSR-7 ResponseInterface or a factory capable of generating a ResponseInterface instance in order to prevent dependence on a specific HTTP message implementation. 1.4 Handling Exceptions It is RECOMMENDED that any application using middleware includes a component that catches exceptions and converts them into responses. This middleware SHOULD be the first component executed and wrap all further processing to ensure that a response is always generated. 2. Interfaces 2.1 Psr\\Http\\Server\\RequestHandlerInterface The following interface MUST be implemented by request handlers. namespace Psr\\Http\\Server; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; /** * Handles a server request and produces a response. * * An HTTP request handler process an HTTP request in order to produce an * HTTP response. */ interface RequestHandlerInterface { /** * Handles a request and produces a response. * * May call other collaborating code to generate the response. */ public function handle(ServerRequestInterface $request): ResponseInterface; } 2.2 Psr\\Http\\Server\\MiddlewareInterface The following interface MUST be implemented by compatible middleware components. namespace Psr\\Http\\Server; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; /** * Participant in processing a server request and response. * * An HTTP middleware component participates in processing an HTTP message: * by acting on the request, generating the response, or forwarding the * request to a subsequent middleware and possibly acting on its response. */ interface MiddlewareInterface { /** * Process an incoming server request. * * Processes an incoming server request in order to produce a response. * If unable to produce the response itself, it may delegate to the provided * request handler to do so. */ public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface; }","title":"PSR 15 request handlers"},{"location":"accepted/PSR-15-request-handlers/#http-server-request-handlers","text":"This document describes common interfaces for HTTP server request handlers (\"request handlers\") and HTTP server middleware components (\"middleware\") that use HTTP messages as described by PSR-7 or subsequent replacement PSRs. HTTP request handlers are a fundamental part of any web application. Server-side code receives a request message, processes it, and produces a response message. HTTP middleware is a way to move common request and response processing away from the application layer. The interfaces described in this document are abstractions for request handlers and middleware. Note: All references to \"request handlers\" and \"middleware\" are specific to server request processing. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"HTTP Server Request Handlers"},{"location":"accepted/PSR-15-request-handlers/#references","text":"PSR-7 RFC 2119","title":"References"},{"location":"accepted/PSR-15-request-handlers/#1-specification","text":"","title":"1. Specification"},{"location":"accepted/PSR-15-request-handlers/#11-request-handlers","text":"A request handler is an individual component that processes a request and produces a response, as defined by PSR-7. A request handler MAY throw an exception if request conditions prevent it from producing a response. The type of exception is not defined. Request handlers using this standard MUST implement the following interface: Psr\\Http\\Server\\RequestHandlerInterface","title":"1.1 Request Handlers"},{"location":"accepted/PSR-15-request-handlers/#12-middleware","text":"A middleware component is an individual component participating, often together with other middleware components, in the processing of an incoming request and the creation of a resulting response, as defined by PSR-7. A middleware component MAY create and return a response without delegating to a request handler, if sufficient conditions are met. Middleware using this standard MUST implement the following interface: Psr\\Http\\Server\\MiddlewareInterface","title":"1.2 Middleware"},{"location":"accepted/PSR-15-request-handlers/#13-generating-responses","text":"It is RECOMMENDED that any middleware or request handler that generates a response will either compose a prototype of a PSR-7 ResponseInterface or a factory capable of generating a ResponseInterface instance in order to prevent dependence on a specific HTTP message implementation.","title":"1.3 Generating Responses"},{"location":"accepted/PSR-15-request-handlers/#14-handling-exceptions","text":"It is RECOMMENDED that any application using middleware includes a component that catches exceptions and converts them into responses. This middleware SHOULD be the first component executed and wrap all further processing to ensure that a response is always generated.","title":"1.4 Handling Exceptions"},{"location":"accepted/PSR-15-request-handlers/#2-interfaces","text":"","title":"2. Interfaces"},{"location":"accepted/PSR-15-request-handlers/#21-psrhttpserverrequesthandlerinterface","text":"The following interface MUST be implemented by request handlers. namespace Psr\\Http\\Server; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; /** * Handles a server request and produces a response. * * An HTTP request handler process an HTTP request in order to produce an * HTTP response. */ interface RequestHandlerInterface { /** * Handles a request and produces a response. * * May call other collaborating code to generate the response. */ public function handle(ServerRequestInterface $request): ResponseInterface; }","title":"2.1 Psr\\Http\\Server\\RequestHandlerInterface"},{"location":"accepted/PSR-15-request-handlers/#22-psrhttpservermiddlewareinterface","text":"The following interface MUST be implemented by compatible middleware components. namespace Psr\\Http\\Server; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; /** * Participant in processing a server request and response. * * An HTTP middleware component participates in processing an HTTP message: * by acting on the request, generating the response, or forwarding the * request to a subsequent middleware and possibly acting on its response. */ interface MiddlewareInterface { /** * Process an incoming server request. * * Processes an incoming server request in order to produce a response. * If unable to produce the response itself, it may delegate to the provided * request handler to do so. */ public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface; }","title":"2.2 Psr\\Http\\Server\\MiddlewareInterface"},{"location":"accepted/PSR-16-simple-cache-meta/","text":"PSR-16 Meta Document 1. Summary Caching is a common way to improve the performance of any project, and many libraries make use or could make use of it. Interoperability at this level means libraries can drop their own caching implementations and easily rely on the one given to them by the framework, or another dedicated cache library the user picked. 2. Why Bother? PSR-6 solves this problem already, but in a rather formal and verbose way for what the most simple use cases need. This simpler approach aims to build a standardized layer of simplicity on top of the existing PSR-6 interfaces. 3. Scope 3.1 Goals A simple interface for cache operations. Basic support for operations on multiple keys for performance (round-trip-time) reasons. Providing an adapter class that turns a PSR-6 implementation into a PSR-Simple-Cache one. It should be possible to expose both caching PSRs from a caching library. 3.2 Non-Goals Solving all possible edge cases, PSR-6 does this well already. 4. Approaches The approach chosen here is very barebones by design, as it is to be used only by the most simple cases. It does not have to be implementable by all possible cache backends, nor be usable for all usages. It is merely a layer of convenience on top of PSR-6. 5. People 5.1 Editor(s) Paul Dragoonis (@dragoonis) 5.2 Sponsors Jordi Boggiano (@seldaek) - Composer (Coordinator) Fabien Potencier (@fabpot) - Symfony 5.3 Contributors For their role in the writing the initial version of this cache PSR: Evert Pot (@evert) Florin P\u0103\u021ban (@dlsniper) For being an early reviewer Daniel Messenger (@dannym87) 6. Votes Entrance Vote: https://groups.google.com/d/topic/php-fig/vyQTKHS6pJ8/discussion Acceptance Vote: https://groups.google.com/d/msg/php-fig/A8e6GvDRGIk/HQBJGEhbDQAJ 7. Relevant Links Survey of existing cache implementations , by @dragoonis 8. Errata 8.1 Throwable The 2.0 release of the psr/simple-cache package updates Psr\\SimpleCache\\CacheException to extend \\Throwable . This is considered a backwards compatible change for implementing libraries as of PHP 7.4. 8.2 Type additions The 2.0 release of the psr/simple-cache package includes scalar parameter types and increases the minimum PHP version to 8.0. This is considered a backwards compatible change for implementing libraries as PHP 7.2 introduces covariance for parameters. Any implementation of 1.0 is compatible with 2.0. For calling libraries, however, this reduces the types that they may pass (as previously any parameter that could be cast to string could be accepted) and as such requires incrementing the major version. The 3.0 release includes return types. Return types break backwards compatibility for implementing libraries as PHP does not support return type widening. Implementing libraries MAY add return types to their own packages at their discretion, provided that: the return types match those in the 3.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later the implementation depends on \"psr/simple-cache\": \"^2 || ^3\" so as to exclude the untyped 1.0 version. Implementing libraries MAY add parameter types to their own package in a new minor release, either at the same time as adding return types or in a subsequent release, provided that: the parameter types match or widen those in the 2.0 package the implementation specifies a minimum PHP version of 8.0 if using mixed or union types or later. the implementation depends on \"psr/simple-cache\": \"^2 || ^3\" so as to exclude the untyped 1.0 version. Implementing libraries are encouraged, but not required to transition their packages toward the 3.0 version of the package at their earliest convenience. Calling libraries are encouraged to ensure they are sending the correct types and to update their requirement to \"psr/simple-cache\": \"^1 || ^2 || ^3\" at their earliest convenience.","title":"PSR-16 Meta Document"},{"location":"accepted/PSR-16-simple-cache-meta/#psr-16-meta-document","text":"","title":"PSR-16 Meta Document"},{"location":"accepted/PSR-16-simple-cache-meta/#1-summary","text":"Caching is a common way to improve the performance of any project, and many libraries make use or could make use of it. Interoperability at this level means libraries can drop their own caching implementations and easily rely on the one given to them by the framework, or another dedicated cache library the user picked.","title":"1. Summary"},{"location":"accepted/PSR-16-simple-cache-meta/#2-why-bother","text":"PSR-6 solves this problem already, but in a rather formal and verbose way for what the most simple use cases need. This simpler approach aims to build a standardized layer of simplicity on top of the existing PSR-6 interfaces.","title":"2. Why Bother?"},{"location":"accepted/PSR-16-simple-cache-meta/#3-scope","text":"","title":"3. Scope"},{"location":"accepted/PSR-16-simple-cache-meta/#31-goals","text":"A simple interface for cache operations. Basic support for operations on multiple keys for performance (round-trip-time) reasons. Providing an adapter class that turns a PSR-6 implementation into a PSR-Simple-Cache one. It should be possible to expose both caching PSRs from a caching library.","title":"3.1 Goals"},{"location":"accepted/PSR-16-simple-cache-meta/#32-non-goals","text":"Solving all possible edge cases, PSR-6 does this well already.","title":"3.2 Non-Goals"},{"location":"accepted/PSR-16-simple-cache-meta/#4-approaches","text":"The approach chosen here is very barebones by design, as it is to be used only by the most simple cases. It does not have to be implementable by all possible cache backends, nor be usable for all usages. It is merely a layer of convenience on top of PSR-6.","title":"4. Approaches"},{"location":"accepted/PSR-16-simple-cache-meta/#5-people","text":"","title":"5. People"},{"location":"accepted/PSR-16-simple-cache-meta/#51-editors","text":"Paul Dragoonis (@dragoonis)","title":"5.1 Editor(s)"},{"location":"accepted/PSR-16-simple-cache-meta/#52-sponsors","text":"Jordi Boggiano (@seldaek) - Composer (Coordinator) Fabien Potencier (@fabpot) - Symfony","title":"5.2 Sponsors"},{"location":"accepted/PSR-16-simple-cache-meta/#53-contributors","text":"For their role in the writing the initial version of this cache PSR: Evert Pot (@evert) Florin P\u0103\u021ban (@dlsniper) For being an early reviewer Daniel Messenger (@dannym87)","title":"5.3 Contributors"},{"location":"accepted/PSR-16-simple-cache-meta/#6-votes","text":"Entrance Vote: https://groups.google.com/d/topic/php-fig/vyQTKHS6pJ8/discussion Acceptance Vote: https://groups.google.com/d/msg/php-fig/A8e6GvDRGIk/HQBJGEhbDQAJ","title":"6. Votes"},{"location":"accepted/PSR-16-simple-cache-meta/#7-relevant-links","text":"Survey of existing cache implementations , by @dragoonis","title":"7. Relevant Links"},{"location":"accepted/PSR-16-simple-cache-meta/#8-errata","text":"","title":"8. Errata"},{"location":"accepted/PSR-16-simple-cache-meta/#81-throwable","text":"The 2.0 release of the psr/simple-cache package updates Psr\\SimpleCache\\CacheException to extend \\Throwable . This is considered a backwards compatible change for implementing libraries as of PHP 7.4.","title":"8.1 Throwable"},{"location":"accepted/PSR-16-simple-cache-meta/#82-type-additions","text":"The 2.0 release of the psr/simple-cache package includes scalar parameter types and increases the minimum PHP version to 8.0. This is considered a backwards compatible change for implementing libraries as PHP 7.2 introduces covariance for parameters. Any implementation of 1.0 is compatible with 2.0. For calling libraries, however, this reduces the types that they may pass (as previously any parameter that could be cast to string could be accepted) and as such requires incrementing the major version. The 3.0 release includes return types. Return types break backwards compatibility for implementing libraries as PHP does not support return type widening. Implementing libraries MAY add return types to their own packages at their discretion, provided that: the return types match those in the 3.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later the implementation depends on \"psr/simple-cache\": \"^2 || ^3\" so as to exclude the untyped 1.0 version. Implementing libraries MAY add parameter types to their own package in a new minor release, either at the same time as adding return types or in a subsequent release, provided that: the parameter types match or widen those in the 2.0 package the implementation specifies a minimum PHP version of 8.0 if using mixed or union types or later. the implementation depends on \"psr/simple-cache\": \"^2 || ^3\" so as to exclude the untyped 1.0 version. Implementing libraries are encouraged, but not required to transition their packages toward the 3.0 version of the package at their earliest convenience. Calling libraries are encouraged to ensure they are sending the correct types and to update their requirement to \"psr/simple-cache\": \"^1 || ^2 || ^3\" at their earliest convenience.","title":"8.2 Type additions"},{"location":"accepted/PSR-16-simple-cache/","text":"Common Interface for Caching Libraries This document describes a simple yet extensible interface for a cache item and a cache driver. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . The final implementations MAY decorate the objects with more functionality than the one proposed but they MUST implement the indicated interfaces/functionality first. 1. Specification 1.1 Introduction Caching is a common way to improve the performance of any project, making caching libraries one of the most common features of many frameworks and libraries. Interoperability at this level means libraries can drop their own caching implementations and easily rely on the one given to them by the framework, or another dedicated cache library. PSR-6 solves this problem already, but in a rather formal and verbose way for what the most simple use cases need. This simpler approach aims to build a standardized streamlined interface for common cases. It is independent of PSR-6 but has been designed to make compatibility with PSR-6 as straightforward as possible. 1.2 Definitions Definitions for Calling Library, Implementing Library, TTL, Expiration and Key are copied from PSR-6 as the same assumptions are true. Calling Library - The library or code that actually needs the cache services. This library will utilize caching services that implement this standard's interfaces, but will otherwise have no knowledge of the implementation of those caching services. Implementing Library - This library is responsible for implementing this standard in order to provide caching services to any Calling Library. The Implementing Library MUST provide a class implementing the Psr\\SimpleCache\\CacheInterface interface. Implementing Libraries MUST support at minimum TTL functionality as described below with whole-second granularity. TTL - The Time To Live (TTL) of an item is the amount of time between when that item is stored and it is considered stale. The TTL is normally defined by an integer representing time in seconds, or a DateInterval object. Expiration - The actual time when an item is set to go stale. This is calculated by adding the TTL to the time when an object is stored. An item with a 300 second TTL stored at 1:30:00 will have an expiration of 1:35:00. Implementing Libraries MAY expire an item before its requested Expiration Time, but MUST treat an item as expired once its Expiration Time is reached. If a calling library asks for an item to be saved but does not specify an expiration time, or specifies a null expiration time or TTL, an Implementing Library MAY use a configured default duration. If no default duration has been set, the Implementing Library MUST interpret that as a request to cache the item forever, or for as long as the underlying implementation supports. If a negative or zero TTL is provided, the item MUST be deleted from the cache if it exists, as it is expired already. Key - A string of at least one character that uniquely identifies a cached item. Implementing libraries MUST support keys consisting of the characters A-Z , a-z , 0-9 , _ , and . in any order in UTF-8 encoding and a length of up to 64 characters. Implementing libraries MAY support additional characters and encodings or longer lengths, but MUST support at least that minimum. Libraries are responsible for their own escaping of key strings as appropriate, but MUST be able to return the original unmodified key string. The following characters are reserved for future extensions and MUST NOT be supported by implementing libraries: {}()/\\@: Cache - An object that implements the Psr\\SimpleCache\\CacheInterface interface. Cache Misses - A cache miss will return null and therefore detecting if one stored null is not possible. This is the main deviation from PSR-6's assumptions. 1.3 Cache Implementations MAY provide a mechanism for a user to specify a default TTL if one is not specified for a specific cache item. If no user-specified default is provided implementations MUST default to the maximum legal value allowed by the underlying implementation. If the underlying implementation does not support TTL, the user-specified TTL MUST be silently ignored. 1.4 Data Implementing libraries MUST support all serializable PHP data types, including: Strings - Character strings of arbitrary size in any PHP-compatible encoding. Integers - All integers of any size supported by PHP, up to 64-bit signed. Floats - All signed floating point values. Booleans - True and False. Null - The null value (although it will not be distinguishable from a cache miss when reading it back out). Arrays - Indexed, associative and multidimensional arrays of arbitrary depth. Objects - Any object that supports lossless serialization and deserialization such that $o == unserialize(serialize($o)). Objects MAY leverage PHP's Serializable interface, __sleep() or __wakeup() magic methods, or similar language functionality if appropriate. All data passed into the Implementing Library MUST be returned exactly as passed. That includes the variable type. That is, it is an error to return (string) 5 if (int) 5 was the value saved. Implementing Libraries MAY use PHP's serialize()/unserialize() functions internally but are not required to do so. Compatibility with them is simply used as a baseline for acceptable object values. If it is not possible to return the exact saved value for any reason, implementing libraries MUST respond with a cache miss rather than corrupted data. 2. Interfaces 2.1 CacheInterface The cache interface defines the most basic operations on a collection of cache-entries, which entails basic reading, writing and deleting individual cache items. In addition, it has methods for dealing with multiple sets of cache entries such as writing, reading or deleting multiple cache entries at a time. This is useful when you have lots of cache reads/writes to perform, and lets you perform your operations in a single call to the cache server cutting down latency times dramatically. An instance of CacheInterface corresponds to a single collection of cache items with a single key namespace, and is equivalent to a \"Pool\" in PSR-6. Different CacheInterface instances MAY be backed by the same datastore, but MUST be logically independent. <?php namespace Psr\\SimpleCache; interface CacheInterface { /** * Fetches a value from the cache. * * @param string $key The unique key of this item in the cache. * @param mixed $default Default value to return if the key does not exist. * * @return mixed The value of the item from the cache, or $default in case of cache miss. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function get($key, $default = null); /** * Persists data in the cache, uniquely referenced by a key with an optional expiration TTL time. * * @param string $key The key of the item to store. * @param mixed $value The value of the item to store. Must be serializable. * @param null|int|\\DateInterval $ttl Optional. The TTL value of this item. If no value is sent and * the driver supports TTL then the library may set a default value * for it or let the driver take care of that. * * @return bool True on success and false on failure. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function set($key, $value, $ttl = null); /** * Delete an item from the cache by its unique key. * * @param string $key The unique cache key of the item to delete. * * @return bool True if the item was successfully removed. False if there was an error. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function delete($key); /** * Wipes clean the entire cache's keys. * * @return bool True on success and false on failure. */ public function clear(); /** * Obtains multiple cache items by their unique keys. * * @param iterable $keys A list of keys that can obtained in a single operation. * @param mixed $default Default value to return for keys that do not exist. * * @return iterable A list of key => value pairs. Cache keys that do not exist or are stale will have $default as value. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if $keys is neither an array nor a Traversable, * or if any of the $keys are not a legal value. */ public function getMultiple($keys, $default = null); /** * Persists a set of key => value pairs in the cache, with an optional TTL. * * @param iterable $values A list of key => value pairs for a multiple-set operation. * @param null|int|\\DateInterval $ttl Optional. The TTL value of this item. If no value is sent and * the driver supports TTL then the library may set a default value * for it or let the driver take care of that. * * @return bool True on success and false on failure. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if $values is neither an array nor a Traversable, * or if any of the $values are not a legal value. */ public function setMultiple($values, $ttl = null); /** * Deletes multiple cache items in a single operation. * * @param iterable $keys A list of string-based keys to be deleted. * * @return bool True if the items were successfully removed. False if there was an error. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if $keys is neither an array nor a Traversable, * or if any of the $keys are not a legal value. */ public function deleteMultiple($keys); /** * Determines whether an item is present in the cache. * * NOTE: It is recommended that has() is only to be used for cache warming type purposes * and not to be used within your live applications operations for get/set, as this method * is subject to a race condition where your has() will return true and immediately after, * another script can remove it, making the state of your app out of date. * * @param string $key The cache item key. * * @return bool * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function has($key); } 2.2 CacheException <?php namespace Psr\\SimpleCache; /** * Interface used for all types of exceptions thrown by the implementing library. */ interface CacheException { } 2.3 InvalidArgumentException <?php namespace Psr\\SimpleCache; /** * Exception interface for invalid cache arguments. * * When an invalid argument is passed, it must throw an exception which implements * this interface. */ interface InvalidArgumentException extends CacheException { }","title":"PSR 16 simple cache"},{"location":"accepted/PSR-16-simple-cache/#common-interface-for-caching-libraries","text":"This document describes a simple yet extensible interface for a cache item and a cache driver. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . The final implementations MAY decorate the objects with more functionality than the one proposed but they MUST implement the indicated interfaces/functionality first.","title":"Common Interface for Caching Libraries"},{"location":"accepted/PSR-16-simple-cache/#1-specification","text":"","title":"1. Specification"},{"location":"accepted/PSR-16-simple-cache/#11-introduction","text":"Caching is a common way to improve the performance of any project, making caching libraries one of the most common features of many frameworks and libraries. Interoperability at this level means libraries can drop their own caching implementations and easily rely on the one given to them by the framework, or another dedicated cache library. PSR-6 solves this problem already, but in a rather formal and verbose way for what the most simple use cases need. This simpler approach aims to build a standardized streamlined interface for common cases. It is independent of PSR-6 but has been designed to make compatibility with PSR-6 as straightforward as possible.","title":"1.1 Introduction"},{"location":"accepted/PSR-16-simple-cache/#12-definitions","text":"Definitions for Calling Library, Implementing Library, TTL, Expiration and Key are copied from PSR-6 as the same assumptions are true. Calling Library - The library or code that actually needs the cache services. This library will utilize caching services that implement this standard's interfaces, but will otherwise have no knowledge of the implementation of those caching services. Implementing Library - This library is responsible for implementing this standard in order to provide caching services to any Calling Library. The Implementing Library MUST provide a class implementing the Psr\\SimpleCache\\CacheInterface interface. Implementing Libraries MUST support at minimum TTL functionality as described below with whole-second granularity. TTL - The Time To Live (TTL) of an item is the amount of time between when that item is stored and it is considered stale. The TTL is normally defined by an integer representing time in seconds, or a DateInterval object. Expiration - The actual time when an item is set to go stale. This is calculated by adding the TTL to the time when an object is stored. An item with a 300 second TTL stored at 1:30:00 will have an expiration of 1:35:00. Implementing Libraries MAY expire an item before its requested Expiration Time, but MUST treat an item as expired once its Expiration Time is reached. If a calling library asks for an item to be saved but does not specify an expiration time, or specifies a null expiration time or TTL, an Implementing Library MAY use a configured default duration. If no default duration has been set, the Implementing Library MUST interpret that as a request to cache the item forever, or for as long as the underlying implementation supports. If a negative or zero TTL is provided, the item MUST be deleted from the cache if it exists, as it is expired already. Key - A string of at least one character that uniquely identifies a cached item. Implementing libraries MUST support keys consisting of the characters A-Z , a-z , 0-9 , _ , and . in any order in UTF-8 encoding and a length of up to 64 characters. Implementing libraries MAY support additional characters and encodings or longer lengths, but MUST support at least that minimum. Libraries are responsible for their own escaping of key strings as appropriate, but MUST be able to return the original unmodified key string. The following characters are reserved for future extensions and MUST NOT be supported by implementing libraries: {}()/\\@: Cache - An object that implements the Psr\\SimpleCache\\CacheInterface interface. Cache Misses - A cache miss will return null and therefore detecting if one stored null is not possible. This is the main deviation from PSR-6's assumptions.","title":"1.2 Definitions"},{"location":"accepted/PSR-16-simple-cache/#13-cache","text":"Implementations MAY provide a mechanism for a user to specify a default TTL if one is not specified for a specific cache item. If no user-specified default is provided implementations MUST default to the maximum legal value allowed by the underlying implementation. If the underlying implementation does not support TTL, the user-specified TTL MUST be silently ignored.","title":"1.3 Cache"},{"location":"accepted/PSR-16-simple-cache/#14-data","text":"Implementing libraries MUST support all serializable PHP data types, including: Strings - Character strings of arbitrary size in any PHP-compatible encoding. Integers - All integers of any size supported by PHP, up to 64-bit signed. Floats - All signed floating point values. Booleans - True and False. Null - The null value (although it will not be distinguishable from a cache miss when reading it back out). Arrays - Indexed, associative and multidimensional arrays of arbitrary depth. Objects - Any object that supports lossless serialization and deserialization such that $o == unserialize(serialize($o)). Objects MAY leverage PHP's Serializable interface, __sleep() or __wakeup() magic methods, or similar language functionality if appropriate. All data passed into the Implementing Library MUST be returned exactly as passed. That includes the variable type. That is, it is an error to return (string) 5 if (int) 5 was the value saved. Implementing Libraries MAY use PHP's serialize()/unserialize() functions internally but are not required to do so. Compatibility with them is simply used as a baseline for acceptable object values. If it is not possible to return the exact saved value for any reason, implementing libraries MUST respond with a cache miss rather than corrupted data.","title":"1.4 Data"},{"location":"accepted/PSR-16-simple-cache/#2-interfaces","text":"","title":"2. Interfaces"},{"location":"accepted/PSR-16-simple-cache/#21-cacheinterface","text":"The cache interface defines the most basic operations on a collection of cache-entries, which entails basic reading, writing and deleting individual cache items. In addition, it has methods for dealing with multiple sets of cache entries such as writing, reading or deleting multiple cache entries at a time. This is useful when you have lots of cache reads/writes to perform, and lets you perform your operations in a single call to the cache server cutting down latency times dramatically. An instance of CacheInterface corresponds to a single collection of cache items with a single key namespace, and is equivalent to a \"Pool\" in PSR-6. Different CacheInterface instances MAY be backed by the same datastore, but MUST be logically independent. <?php namespace Psr\\SimpleCache; interface CacheInterface { /** * Fetches a value from the cache. * * @param string $key The unique key of this item in the cache. * @param mixed $default Default value to return if the key does not exist. * * @return mixed The value of the item from the cache, or $default in case of cache miss. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function get($key, $default = null); /** * Persists data in the cache, uniquely referenced by a key with an optional expiration TTL time. * * @param string $key The key of the item to store. * @param mixed $value The value of the item to store. Must be serializable. * @param null|int|\\DateInterval $ttl Optional. The TTL value of this item. If no value is sent and * the driver supports TTL then the library may set a default value * for it or let the driver take care of that. * * @return bool True on success and false on failure. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function set($key, $value, $ttl = null); /** * Delete an item from the cache by its unique key. * * @param string $key The unique cache key of the item to delete. * * @return bool True if the item was successfully removed. False if there was an error. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function delete($key); /** * Wipes clean the entire cache's keys. * * @return bool True on success and false on failure. */ public function clear(); /** * Obtains multiple cache items by their unique keys. * * @param iterable $keys A list of keys that can obtained in a single operation. * @param mixed $default Default value to return for keys that do not exist. * * @return iterable A list of key => value pairs. Cache keys that do not exist or are stale will have $default as value. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if $keys is neither an array nor a Traversable, * or if any of the $keys are not a legal value. */ public function getMultiple($keys, $default = null); /** * Persists a set of key => value pairs in the cache, with an optional TTL. * * @param iterable $values A list of key => value pairs for a multiple-set operation. * @param null|int|\\DateInterval $ttl Optional. The TTL value of this item. If no value is sent and * the driver supports TTL then the library may set a default value * for it or let the driver take care of that. * * @return bool True on success and false on failure. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if $values is neither an array nor a Traversable, * or if any of the $values are not a legal value. */ public function setMultiple($values, $ttl = null); /** * Deletes multiple cache items in a single operation. * * @param iterable $keys A list of string-based keys to be deleted. * * @return bool True if the items were successfully removed. False if there was an error. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if $keys is neither an array nor a Traversable, * or if any of the $keys are not a legal value. */ public function deleteMultiple($keys); /** * Determines whether an item is present in the cache. * * NOTE: It is recommended that has() is only to be used for cache warming type purposes * and not to be used within your live applications operations for get/set, as this method * is subject to a race condition where your has() will return true and immediately after, * another script can remove it, making the state of your app out of date. * * @param string $key The cache item key. * * @return bool * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function has($key); }","title":"2.1 CacheInterface"},{"location":"accepted/PSR-16-simple-cache/#22-cacheexception","text":"<?php namespace Psr\\SimpleCache; /** * Interface used for all types of exceptions thrown by the implementing library. */ interface CacheException { }","title":"2.2 CacheException"},{"location":"accepted/PSR-16-simple-cache/#23-invalidargumentexception","text":"<?php namespace Psr\\SimpleCache; /** * Exception interface for invalid cache arguments. * * When an invalid argument is passed, it must throw an exception which implements * this interface. */ interface InvalidArgumentException extends CacheException { }","title":"2.3 InvalidArgumentException"},{"location":"accepted/PSR-17-http-factory-meta/","text":"HTTP Factories Meta 1. Summary The purpose of this PSR is to provide factory interfaces that define methods to create PSR-7 objects. 2. Why Bother? The current specification for PSR-7 allows for most objects to be modified by creating immutable copies. However, there are two notable exceptions: StreamInterface is a mutable object based on a resource that only allows the resource to be written to when the resource is writable. UploadedFileInterface is a read-only object based on a resource that offers no modification capabilities. The former is a significant pain point for PSR-7 middleware, as it can leave the response in an incomplete state. If the stream attached to the response body is not seekable or not writable, there is no way to recover from an error condition in which the body has already been written to. This scenario can be avoided by providing a factory to create new streams. Due to the lack of a formal standard for HTTP object factories, a developer must rely on a specific vendor implementation in order to create these objects. Another pain point is when writing re-usable middleware or request handlers. In such cases, package authors may need to create and return a response. However, creating discrete instances then ties the package to a specific PSR-7 implementation. If these packages rely on the request factory interface instead, they can remain agnostic of the PSR-7 implementation. Creating a formal standard for factories will allow developers to avoid dependencies on specific implementations while having the ability to create new objects when necessary. 3. Scope 3.1 Goals Provide a set of interfaces that define methods to create PSR-7 compatible objects. 3.2 Non-Goals Provide a specific implementation of PSR-7 factories. 4. Approaches 4.1 Chosen Approach The factory method definition has been chosen based on whether or not the object can be modified after instantiation. For interfaces that cannot be modified, all of the object properties must be defined at the time of instantiation. In the case of UriInterface a complete URI may be passed for convenience. The method names used will not conflict. This allows for a single class to implement multiple interfaces when appropriate. 4.2 Existing Implementations All of the current implementations of PSR-7 have defined their own requirements. In most cases, the required parameters are the same or less strict than the proposed factory methods. 4.2.1 Diactoros Diactoros was one of the first HTTP Messages implementations for server usage, and was developed parallel to the PSR-7 specification. Request No required parameters, method and URI default to null . Response No required parameters, status code defaults to 200 . ServerRequest No required parameters. Contains a separate ServerRequestFactory for creating requests from globals. Stream Requires string|resource $stream for the body. UploadedFile Requires string|resource $streamOrFile , int $size , int $errorStatus . Error status must be a PHP upload constant. Uri No required parameters, string $uri is empty by default. Overall this approach is quite similar to the proposed factories. In some cases, more options are given by Diactoros which are not required for a valid object. The proposed uploaded file factory allows for size and error status to be optional. 4.2.2 Guzzle Guzzle is an HTTP Messages implementation that focuses on client usage. Request Requires both string $method and string|UriInterface $uri . Response No required parameters, status code defaults to 200 . Stream Requires resource $stream for the body. Uri No required parameters, string $uri is empty by default. Being geared towards client usage, Guzzle does not contain a ServerRequest or UploadedFile implementation. Overall this approach is also quite similar to the proposed factories. One notable difference is that Guzzle requires streams to be constructed with a resource and does not allow a string. However, it does contain a helper function stream_for that will create a stream from a string of content and a function try_fopen that will create a resource from a file path. 4.2.3 Slim Slim is a micro-framework that makes use of HTTP Messages from version 3.0 forward. Request Requires string $method , UriInterface $uri , HeadersInterface $headers , array $cookies , array $serverParams , and StreamInterface $body . Contains a factory method createFromEnvironment(Environment $environment) that is framework specific but analogous to the proposed createServerRequestFromArray . Response No required parameters, status code defaults to 200 . Stream Requires resource $stream for the body. UploadedFile Requires string $file for the source file. Contains a factory method parseUploadedFiles(array $uploadedFiles) for creating an array of UploadedFile instances from $_FILES or similar format. Also contains a factory method createFromEnvironment(Environment $env) that is framework specific and makes use of parseUploadedFiles . Uri Requires string $scheme and string $host . Contains a factory method createFromString($uri) that can be used to create a Uri from a string. Being geared towards server usage only, Slim does not contain an implementation of Request . The implementation listed above is an implementation of ServerRequest . Of the compared approaches, Slim is most different from the proposed factories. Most notably, the Request implementation contains requirements specific to the framework that are not defined in HTTP Messages specification. The factory methods that are included are generally similar with the proposed factories. 4.3 Potential Issues The most difficult task in establishing this standard will be defining the method signatures for the interfaces. As there is no clear declaration in PSR-7 as to what values are explicitly required, the properties that are read-only must be inferred based on whether the interfaces have methods to copy-and-modify the object. 5. Design Decisions 5.1 Why PHP 7? While PSR-7 does not target PHP 7, the authors of this specification note that, at the time of writing (April 2018), PHP 5.6 stopped receiving bugfixes 15 months ago, and will no longer receive security patches in 8 months; PHP 7.0 itself will stop receiving security fixes in 7 months (see the PHP supported versions document for current support details). Since specifications are meant to be long-term, the authors feel the specification should target versions that will be supported for the foreseeable future; PHP 5 will not. As such, from a security standpoint, targeting anything under PHP 7 is a disservice to users, as doing so would be tacit approval of usage of unsupported PHP versions. Additionally, and equally importantly, PHP 7 gives us the ability to provide return type hints to interfaces we define. This guarantees a strong, predicatable contract for end users, as they can assume that the values returned by implementations will be exactly what they expect. 5.2 Why multiple interfaces? Each proposed interface is (primarily) responsible for producing one PSR-7 type. This allows consumers to typehint on exactly what they need: if they need a response, they typehint on ResponseFactoryInterface ; if they need a URI, they typehint on UriFactoryInterface . In this way, users can be granular about what they need. Doing so also allows application developers to provide anonymous implementations based on the PSR-7 implementation they are using, producing only the instances they need for the specific context. This reduces boilerplate; developers do not need to write stubs for unused methods. 5.3 Why does the $reasonPhrase argument to the ResponseFactoryInterface exist? ResponseFactoryInterface::createResponse() includes an optional string argument, $reasonPhrase . In the PSR-7 specification, you can only provide a reason phrase at the same time you provide a status code, as the two are related pieces of data. The authors of this specification have chosen to mimic the PSR-7 ResponseInterface::withStatus() signature to ensure both sets of data may be present in the response created. 5.4 Why does the $serverParams argument to the ServerRequestFactoryInterface exist? ServerRequestFactoryInterface::createServerRequest() includes an optional $serverParams array argument. The reason this is provided is to ensure that an instance can be created with the server params populated. Of the data accessible via the ServerRequestInterface , the only data that does not have a mutator method is the one corresponding to the server params. As such, this data MUST be provided at initial creation. For this reason, it exists as an argument to the factory method. 5.5 Why is there no factory for creating a ServerRequestInterface from superglobals? The primary use case of ServerRequestFactoryInterface is for creating a new ServerRequestInterface instance from known data. Any solution around marshaling data from superglobals assumes that: superglobals are present superglobals follow a specific structure These two assumptions are not always true. When using asynchronous systems such as Swoole , ReactPHP , and others: will not populate standard superglobals such as $_GET , $_POST , $_COOKIE , and $_FILES will not populate $_SERVER with the same elements as a standard SAPI (such as mod_php, mod-cgi, and mod-fpm) Moreover, different standard SAPIs provide different information to $_SERVER and access to request headers, requiring different approaches for initial population of the request. As such, designing an interface for population of an instance from superglobals is out of scope of this specification, and should largely be implementation-specfic. 5.6 Why does RequestFactoryInterface::createRequest allow a string URI? The primary use case of RequestFactoryInterface is to create a request, and the only required values for any request are the request method and a URI. While RequestFactoryInterface::createRequest() can accept a UriInterface instance, it also allows a string. The rationale is two-fold. First, the majority use case is to create a request instance; creation of the URI instance is secondary. Requiring a UriInterface means users would either need to also have access to a UriFactoryInterface , or the RequestFactoryInterface would have a hard requirement on a UriFactoryInterface . The first complicates usage for consumers of the factory, the second complicates usage for either developers of the factory, or those creating the factory instance. Second, UriFactoryInterface provides exactly one way to create a UriInterface instance, and that is from a string URI. If creation of the URI is based on a string, there's no reason for the RequestFactoryInterface not to allow the same semantics. Additionally, every PSR-7 implementation surveyed at the time this proposal was developed allowed a string URI when creating a RequestInterface instance, as the value was then passed to whatever UriInterface implementation they provided. As such, accepting a string is expedient and follows existing semantics. 6. People This PSR was produced by a FIG Working Group with the following members: Woody Gilk (editor), woody.gilk@gmail.com Matthew Weier O'Phinney (sponsor), mweierophinney@gmail.com Stefano Torresi Matthieu Napoli Korvin Szanto Glenn Eggleton Oscar Otero Tobias Nyholm The working group would also like to acknowledge the contributions of: Paul M. Jones, pmjones88@gmail.com Rasmus Schultz, rasmus@mindplay.dk Roman Tsjupa, draconyster@gmail.com 7. Votes Entrance Vote Working Group Formation Review Period Initiation Acceptance Vote 8. Relevant Links Note: Order descending chronologically. PSR-7 Middleware Proposal PHP-FIG mailing list discussion of middleware ircmaxwell All About Middleware shadowhand All About PSR-7 Middleware AndrewCarterUK PSR-7 Objects Are Not Immutable shadowhand Dependency Inversion and PSR-7 Bodies PHP-FIG mailing list thread discussing factories PHP-FIG mailing list thread feedback on proposal","title":"PSR 17 http factory meta"},{"location":"accepted/PSR-17-http-factory-meta/#http-factories-meta","text":"","title":"HTTP Factories Meta"},{"location":"accepted/PSR-17-http-factory-meta/#1-summary","text":"The purpose of this PSR is to provide factory interfaces that define methods to create PSR-7 objects.","title":"1. Summary"},{"location":"accepted/PSR-17-http-factory-meta/#2-why-bother","text":"The current specification for PSR-7 allows for most objects to be modified by creating immutable copies. However, there are two notable exceptions: StreamInterface is a mutable object based on a resource that only allows the resource to be written to when the resource is writable. UploadedFileInterface is a read-only object based on a resource that offers no modification capabilities. The former is a significant pain point for PSR-7 middleware, as it can leave the response in an incomplete state. If the stream attached to the response body is not seekable or not writable, there is no way to recover from an error condition in which the body has already been written to. This scenario can be avoided by providing a factory to create new streams. Due to the lack of a formal standard for HTTP object factories, a developer must rely on a specific vendor implementation in order to create these objects. Another pain point is when writing re-usable middleware or request handlers. In such cases, package authors may need to create and return a response. However, creating discrete instances then ties the package to a specific PSR-7 implementation. If these packages rely on the request factory interface instead, they can remain agnostic of the PSR-7 implementation. Creating a formal standard for factories will allow developers to avoid dependencies on specific implementations while having the ability to create new objects when necessary.","title":"2. Why Bother?"},{"location":"accepted/PSR-17-http-factory-meta/#3-scope","text":"","title":"3. Scope"},{"location":"accepted/PSR-17-http-factory-meta/#31-goals","text":"Provide a set of interfaces that define methods to create PSR-7 compatible objects.","title":"3.1 Goals"},{"location":"accepted/PSR-17-http-factory-meta/#32-non-goals","text":"Provide a specific implementation of PSR-7 factories.","title":"3.2 Non-Goals"},{"location":"accepted/PSR-17-http-factory-meta/#4-approaches","text":"","title":"4. Approaches"},{"location":"accepted/PSR-17-http-factory-meta/#41-chosen-approach","text":"The factory method definition has been chosen based on whether or not the object can be modified after instantiation. For interfaces that cannot be modified, all of the object properties must be defined at the time of instantiation. In the case of UriInterface a complete URI may be passed for convenience. The method names used will not conflict. This allows for a single class to implement multiple interfaces when appropriate.","title":"4.1 Chosen Approach"},{"location":"accepted/PSR-17-http-factory-meta/#42-existing-implementations","text":"All of the current implementations of PSR-7 have defined their own requirements. In most cases, the required parameters are the same or less strict than the proposed factory methods.","title":"4.2 Existing Implementations"},{"location":"accepted/PSR-17-http-factory-meta/#421-diactoros","text":"Diactoros was one of the first HTTP Messages implementations for server usage, and was developed parallel to the PSR-7 specification. Request No required parameters, method and URI default to null . Response No required parameters, status code defaults to 200 . ServerRequest No required parameters. Contains a separate ServerRequestFactory for creating requests from globals. Stream Requires string|resource $stream for the body. UploadedFile Requires string|resource $streamOrFile , int $size , int $errorStatus . Error status must be a PHP upload constant. Uri No required parameters, string $uri is empty by default. Overall this approach is quite similar to the proposed factories. In some cases, more options are given by Diactoros which are not required for a valid object. The proposed uploaded file factory allows for size and error status to be optional.","title":"4.2.1 Diactoros"},{"location":"accepted/PSR-17-http-factory-meta/#422-guzzle","text":"Guzzle is an HTTP Messages implementation that focuses on client usage. Request Requires both string $method and string|UriInterface $uri . Response No required parameters, status code defaults to 200 . Stream Requires resource $stream for the body. Uri No required parameters, string $uri is empty by default. Being geared towards client usage, Guzzle does not contain a ServerRequest or UploadedFile implementation. Overall this approach is also quite similar to the proposed factories. One notable difference is that Guzzle requires streams to be constructed with a resource and does not allow a string. However, it does contain a helper function stream_for that will create a stream from a string of content and a function try_fopen that will create a resource from a file path.","title":"4.2.2 Guzzle"},{"location":"accepted/PSR-17-http-factory-meta/#423-slim","text":"Slim is a micro-framework that makes use of HTTP Messages from version 3.0 forward. Request Requires string $method , UriInterface $uri , HeadersInterface $headers , array $cookies , array $serverParams , and StreamInterface $body . Contains a factory method createFromEnvironment(Environment $environment) that is framework specific but analogous to the proposed createServerRequestFromArray . Response No required parameters, status code defaults to 200 . Stream Requires resource $stream for the body. UploadedFile Requires string $file for the source file. Contains a factory method parseUploadedFiles(array $uploadedFiles) for creating an array of UploadedFile instances from $_FILES or similar format. Also contains a factory method createFromEnvironment(Environment $env) that is framework specific and makes use of parseUploadedFiles . Uri Requires string $scheme and string $host . Contains a factory method createFromString($uri) that can be used to create a Uri from a string. Being geared towards server usage only, Slim does not contain an implementation of Request . The implementation listed above is an implementation of ServerRequest . Of the compared approaches, Slim is most different from the proposed factories. Most notably, the Request implementation contains requirements specific to the framework that are not defined in HTTP Messages specification. The factory methods that are included are generally similar with the proposed factories.","title":"4.2.3 Slim"},{"location":"accepted/PSR-17-http-factory-meta/#43-potential-issues","text":"The most difficult task in establishing this standard will be defining the method signatures for the interfaces. As there is no clear declaration in PSR-7 as to what values are explicitly required, the properties that are read-only must be inferred based on whether the interfaces have methods to copy-and-modify the object.","title":"4.3 Potential Issues"},{"location":"accepted/PSR-17-http-factory-meta/#5-design-decisions","text":"","title":"5. Design Decisions"},{"location":"accepted/PSR-17-http-factory-meta/#51-why-php-7","text":"While PSR-7 does not target PHP 7, the authors of this specification note that, at the time of writing (April 2018), PHP 5.6 stopped receiving bugfixes 15 months ago, and will no longer receive security patches in 8 months; PHP 7.0 itself will stop receiving security fixes in 7 months (see the PHP supported versions document for current support details). Since specifications are meant to be long-term, the authors feel the specification should target versions that will be supported for the foreseeable future; PHP 5 will not. As such, from a security standpoint, targeting anything under PHP 7 is a disservice to users, as doing so would be tacit approval of usage of unsupported PHP versions. Additionally, and equally importantly, PHP 7 gives us the ability to provide return type hints to interfaces we define. This guarantees a strong, predicatable contract for end users, as they can assume that the values returned by implementations will be exactly what they expect.","title":"5.1 Why PHP 7?"},{"location":"accepted/PSR-17-http-factory-meta/#52-why-multiple-interfaces","text":"Each proposed interface is (primarily) responsible for producing one PSR-7 type. This allows consumers to typehint on exactly what they need: if they need a response, they typehint on ResponseFactoryInterface ; if they need a URI, they typehint on UriFactoryInterface . In this way, users can be granular about what they need. Doing so also allows application developers to provide anonymous implementations based on the PSR-7 implementation they are using, producing only the instances they need for the specific context. This reduces boilerplate; developers do not need to write stubs for unused methods.","title":"5.2 Why multiple interfaces?"},{"location":"accepted/PSR-17-http-factory-meta/#53-why-does-the-reasonphrase-argument-to-the-responsefactoryinterface-exist","text":"ResponseFactoryInterface::createResponse() includes an optional string argument, $reasonPhrase . In the PSR-7 specification, you can only provide a reason phrase at the same time you provide a status code, as the two are related pieces of data. The authors of this specification have chosen to mimic the PSR-7 ResponseInterface::withStatus() signature to ensure both sets of data may be present in the response created.","title":"5.3 Why does the $reasonPhrase argument to the ResponseFactoryInterface exist?"},{"location":"accepted/PSR-17-http-factory-meta/#54-why-does-the-serverparams-argument-to-the-serverrequestfactoryinterface-exist","text":"ServerRequestFactoryInterface::createServerRequest() includes an optional $serverParams array argument. The reason this is provided is to ensure that an instance can be created with the server params populated. Of the data accessible via the ServerRequestInterface , the only data that does not have a mutator method is the one corresponding to the server params. As such, this data MUST be provided at initial creation. For this reason, it exists as an argument to the factory method.","title":"5.4 Why does the $serverParams argument to the ServerRequestFactoryInterface exist?"},{"location":"accepted/PSR-17-http-factory-meta/#55-why-is-there-no-factory-for-creating-a-serverrequestinterface-from-superglobals","text":"The primary use case of ServerRequestFactoryInterface is for creating a new ServerRequestInterface instance from known data. Any solution around marshaling data from superglobals assumes that: superglobals are present superglobals follow a specific structure These two assumptions are not always true. When using asynchronous systems such as Swoole , ReactPHP , and others: will not populate standard superglobals such as $_GET , $_POST , $_COOKIE , and $_FILES will not populate $_SERVER with the same elements as a standard SAPI (such as mod_php, mod-cgi, and mod-fpm) Moreover, different standard SAPIs provide different information to $_SERVER and access to request headers, requiring different approaches for initial population of the request. As such, designing an interface for population of an instance from superglobals is out of scope of this specification, and should largely be implementation-specfic.","title":"5.5 Why is there no factory for creating a ServerRequestInterface from superglobals?"},{"location":"accepted/PSR-17-http-factory-meta/#56-why-does-requestfactoryinterfacecreaterequest-allow-a-string-uri","text":"The primary use case of RequestFactoryInterface is to create a request, and the only required values for any request are the request method and a URI. While RequestFactoryInterface::createRequest() can accept a UriInterface instance, it also allows a string. The rationale is two-fold. First, the majority use case is to create a request instance; creation of the URI instance is secondary. Requiring a UriInterface means users would either need to also have access to a UriFactoryInterface , or the RequestFactoryInterface would have a hard requirement on a UriFactoryInterface . The first complicates usage for consumers of the factory, the second complicates usage for either developers of the factory, or those creating the factory instance. Second, UriFactoryInterface provides exactly one way to create a UriInterface instance, and that is from a string URI. If creation of the URI is based on a string, there's no reason for the RequestFactoryInterface not to allow the same semantics. Additionally, every PSR-7 implementation surveyed at the time this proposal was developed allowed a string URI when creating a RequestInterface instance, as the value was then passed to whatever UriInterface implementation they provided. As such, accepting a string is expedient and follows existing semantics.","title":"5.6 Why does RequestFactoryInterface::createRequest allow a string URI?"},{"location":"accepted/PSR-17-http-factory-meta/#6-people","text":"This PSR was produced by a FIG Working Group with the following members: Woody Gilk (editor), woody.gilk@gmail.com Matthew Weier O'Phinney (sponsor), mweierophinney@gmail.com Stefano Torresi Matthieu Napoli Korvin Szanto Glenn Eggleton Oscar Otero Tobias Nyholm The working group would also like to acknowledge the contributions of: Paul M. Jones, pmjones88@gmail.com Rasmus Schultz, rasmus@mindplay.dk Roman Tsjupa, draconyster@gmail.com","title":"6. People"},{"location":"accepted/PSR-17-http-factory-meta/#7-votes","text":"Entrance Vote Working Group Formation Review Period Initiation Acceptance Vote","title":"7. Votes"},{"location":"accepted/PSR-17-http-factory-meta/#8-relevant-links","text":"Note: Order descending chronologically. PSR-7 Middleware Proposal PHP-FIG mailing list discussion of middleware ircmaxwell All About Middleware shadowhand All About PSR-7 Middleware AndrewCarterUK PSR-7 Objects Are Not Immutable shadowhand Dependency Inversion and PSR-7 Bodies PHP-FIG mailing list thread discussing factories PHP-FIG mailing list thread feedback on proposal","title":"8. Relevant Links"},{"location":"accepted/PSR-17-http-factory/","text":"HTTP Factories This document describes a common standard for factories that create PSR-7 compliant HTTP objects. PSR-7 did not include a recommendation on how to create HTTP objects, which leads to difficulties when needing to create new HTTP objects within components that are not tied to a specific implementation of PSR-7. The interfaces outlined in this document describe methods by which PSR-7 objects can be instantiated. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . 1. Specification An HTTP factory is a method by which a new HTTP object, as defined by PSR-7, is created. HTTP factories MUST implement these interfaces for each object type that is provided by the package. 2. Interfaces The following interfaces MAY be implemented together within a single class or in separate classes. 2.1 RequestFactoryInterface Has the ability to create client requests. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\RequestInterface; use Psr\\Http\\Message\\UriInterface; interface RequestFactoryInterface { /** * Create a new request. * * @param string $method The HTTP method associated with the request. * @param UriInterface|string $uri The URI associated with the request. */ public function createRequest(string $method, $uri): RequestInterface; } 2.2 ResponseFactoryInterface Has the ability to create responses. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\ResponseInterface; interface ResponseFactoryInterface { /** * Create a new response. * * @param int $code The HTTP status code. Defaults to 200. * @param string $reasonPhrase The reason phrase to associate with the status code * in the generated response. If none is provided, implementations MAY use * the defaults as suggested in the HTTP specification. */ public function createResponse(int $code = 200, string $reasonPhrase = ''): ResponseInterface; } 2.3 ServerRequestFactoryInterface Has the ability to create server requests. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\UriInterface; interface ServerRequestFactoryInterface { /** * Create a new server request. * * Note that server parameters are taken precisely as given - no parsing/processing * of the given values is performed. In particular, no attempt is made to * determine the HTTP method or URI, which must be provided explicitly. * * @param string $method The HTTP method associated with the request. * @param UriInterface|string $uri The URI associated with the request. * @param array $serverParams An array of Server API (SAPI) parameters with * which to seed the generated request instance. */ public function createServerRequest(string $method, $uri, array $serverParams = []): ServerRequestInterface; } 2.4 StreamFactoryInterface Has the ability to create streams for requests and responses. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\StreamInterface; interface StreamFactoryInterface { /** * Create a new stream from a string. * * The stream SHOULD be created with a temporary resource. * * @param string $content String content with which to populate the stream. */ public function createStream(string $content = ''): StreamInterface; /** * Create a stream from an existing file. * * The file MUST be opened using the given mode, which may be any mode * supported by the `fopen` function. * * The `$filename` MAY be any string supported by `fopen()`. * * @param string $filename The filename or stream URI to use as basis of stream. * @param string $mode The mode with which to open the underlying filename/stream. * * @throws \\RuntimeException If the file cannot be opened. * @throws \\InvalidArgumentException If the mode is invalid. */ public function createStreamFromFile(string $filename, string $mode = 'r'): StreamInterface; /** * Create a new stream from an existing resource. * * The stream MUST be readable and may be writable. * * @param resource $resource The PHP resource to use as the basis for the stream. */ public function createStreamFromResource($resource): StreamInterface; } Implementations of this interface SHOULD use a temporary stream when creating resources from strings. The RECOMMENDED method for doing so is: $resource = fopen('php://temp', 'r+'); 2.5 UploadedFileFactoryInterface Has the ability to create streams for uploaded files. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\StreamInterface; use Psr\\Http\\Message\\UploadedFileInterface; interface UploadedFileFactoryInterface { /** * Create a new uploaded file. * * If a size is not provided it will be determined by checking the size of * the stream. * * @link http://php.net/manual/features.file-upload.post-method.php * @link http://php.net/manual/features.file-upload.errors.php * * @param StreamInterface $stream The underlying stream representing the * uploaded file content. * @param int $size The size of the file in bytes. * @param int $error The PHP file upload error. * @param string $clientFilename The filename as provided by the client, if any. * @param string $clientMediaType The media type as provided by the client, if any. * * @throws \\InvalidArgumentException If the file resource is not readable. */ public function createUploadedFile( StreamInterface $stream, int $size = null, int $error = \\UPLOAD_ERR_OK, string $clientFilename = null, string $clientMediaType = null ): UploadedFileInterface; } 2.6 UriFactoryInterface Has the ability to create URIs for client and server requests. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\UriInterface; interface UriFactoryInterface { /** * Create a new URI. * * @param string $uri The URI to parse. * * @throws \\InvalidArgumentException If the given URI cannot be parsed. */ public function createUri(string $uri = '') : UriInterface; }","title":"PSR 17 http factory"},{"location":"accepted/PSR-17-http-factory/#http-factories","text":"This document describes a common standard for factories that create PSR-7 compliant HTTP objects. PSR-7 did not include a recommendation on how to create HTTP objects, which leads to difficulties when needing to create new HTTP objects within components that are not tied to a specific implementation of PSR-7. The interfaces outlined in this document describe methods by which PSR-7 objects can be instantiated. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"HTTP Factories"},{"location":"accepted/PSR-17-http-factory/#1-specification","text":"An HTTP factory is a method by which a new HTTP object, as defined by PSR-7, is created. HTTP factories MUST implement these interfaces for each object type that is provided by the package.","title":"1. Specification"},{"location":"accepted/PSR-17-http-factory/#2-interfaces","text":"The following interfaces MAY be implemented together within a single class or in separate classes.","title":"2. Interfaces"},{"location":"accepted/PSR-17-http-factory/#21-requestfactoryinterface","text":"Has the ability to create client requests. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\RequestInterface; use Psr\\Http\\Message\\UriInterface; interface RequestFactoryInterface { /** * Create a new request. * * @param string $method The HTTP method associated with the request. * @param UriInterface|string $uri The URI associated with the request. */ public function createRequest(string $method, $uri): RequestInterface; }","title":"2.1 RequestFactoryInterface"},{"location":"accepted/PSR-17-http-factory/#22-responsefactoryinterface","text":"Has the ability to create responses. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\ResponseInterface; interface ResponseFactoryInterface { /** * Create a new response. * * @param int $code The HTTP status code. Defaults to 200. * @param string $reasonPhrase The reason phrase to associate with the status code * in the generated response. If none is provided, implementations MAY use * the defaults as suggested in the HTTP specification. */ public function createResponse(int $code = 200, string $reasonPhrase = ''): ResponseInterface; }","title":"2.2 ResponseFactoryInterface"},{"location":"accepted/PSR-17-http-factory/#23-serverrequestfactoryinterface","text":"Has the ability to create server requests. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\UriInterface; interface ServerRequestFactoryInterface { /** * Create a new server request. * * Note that server parameters are taken precisely as given - no parsing/processing * of the given values is performed. In particular, no attempt is made to * determine the HTTP method or URI, which must be provided explicitly. * * @param string $method The HTTP method associated with the request. * @param UriInterface|string $uri The URI associated with the request. * @param array $serverParams An array of Server API (SAPI) parameters with * which to seed the generated request instance. */ public function createServerRequest(string $method, $uri, array $serverParams = []): ServerRequestInterface; }","title":"2.3 ServerRequestFactoryInterface"},{"location":"accepted/PSR-17-http-factory/#24-streamfactoryinterface","text":"Has the ability to create streams for requests and responses. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\StreamInterface; interface StreamFactoryInterface { /** * Create a new stream from a string. * * The stream SHOULD be created with a temporary resource. * * @param string $content String content with which to populate the stream. */ public function createStream(string $content = ''): StreamInterface; /** * Create a stream from an existing file. * * The file MUST be opened using the given mode, which may be any mode * supported by the `fopen` function. * * The `$filename` MAY be any string supported by `fopen()`. * * @param string $filename The filename or stream URI to use as basis of stream. * @param string $mode The mode with which to open the underlying filename/stream. * * @throws \\RuntimeException If the file cannot be opened. * @throws \\InvalidArgumentException If the mode is invalid. */ public function createStreamFromFile(string $filename, string $mode = 'r'): StreamInterface; /** * Create a new stream from an existing resource. * * The stream MUST be readable and may be writable. * * @param resource $resource The PHP resource to use as the basis for the stream. */ public function createStreamFromResource($resource): StreamInterface; } Implementations of this interface SHOULD use a temporary stream when creating resources from strings. The RECOMMENDED method for doing so is: $resource = fopen('php://temp', 'r+');","title":"2.4 StreamFactoryInterface"},{"location":"accepted/PSR-17-http-factory/#25-uploadedfilefactoryinterface","text":"Has the ability to create streams for uploaded files. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\StreamInterface; use Psr\\Http\\Message\\UploadedFileInterface; interface UploadedFileFactoryInterface { /** * Create a new uploaded file. * * If a size is not provided it will be determined by checking the size of * the stream. * * @link http://php.net/manual/features.file-upload.post-method.php * @link http://php.net/manual/features.file-upload.errors.php * * @param StreamInterface $stream The underlying stream representing the * uploaded file content. * @param int $size The size of the file in bytes. * @param int $error The PHP file upload error. * @param string $clientFilename The filename as provided by the client, if any. * @param string $clientMediaType The media type as provided by the client, if any. * * @throws \\InvalidArgumentException If the file resource is not readable. */ public function createUploadedFile( StreamInterface $stream, int $size = null, int $error = \\UPLOAD_ERR_OK, string $clientFilename = null, string $clientMediaType = null ): UploadedFileInterface; }","title":"2.5 UploadedFileFactoryInterface"},{"location":"accepted/PSR-17-http-factory/#26-urifactoryinterface","text":"Has the ability to create URIs for client and server requests. namespace Psr\\Http\\Message; use Psr\\Http\\Message\\UriInterface; interface UriFactoryInterface { /** * Create a new URI. * * @param string $uri The URI to parse. * * @throws \\InvalidArgumentException If the given URI cannot be parsed. */ public function createUri(string $uri = '') : UriInterface; }","title":"2.6 UriFactoryInterface"},{"location":"accepted/PSR-18-http-client-meta/","text":"HTTP Client Meta Document Summary HTTP requests and responses are the two fundamental objects in web programming. All clients communicating to an external API use some form of HTTP client. Many libraries are coupled to one specific client or implement a client and/or adapter layer themselves. This leads to bad library design, version conflicts, or code unrelated to the library domain. Why bother? Thanks to PSR-7 we know how HTTP requests and responses ideally look, but nothing defines how a request should be sent and a response received. A common interface for HTTP clients will allow libraries to be decoupled from specific implementations. Scope Goals A common interface for sending PSR-7 messages and returning PSR-7 responses. Non-Goals Support for asynchronous HTTP requests is left for another future PSR. This PSR does not define how to configure an HTTP client. It only specifies the default behaviours. This PSR is neutral about the use of middleware. Asynchronous HTTP client The reason asynchronous requests are not covered by this PSR is the lack of a common standard for Promises. Promises are sufficiently complex enough that they deserve their own specification, and should not be wrapped into this one. A separate interface for asynchronous requests can be defined in a separate PSR once a Promise PSR is accepted. The method signature for asynchronous requests MUST be different from the method signature for synchronous requests because the return type of asynchronous calls will be a Promise. Thus this PSR is forwards compatible, and clients will be able to implement one or both interfaces based on the features they wish to expose. Approaches Default behavior The intention of this PSR is to provide library developers with HTTP clients that have a well defined behaviour. A library should be able to use any compliant client without special code to handle client implementation details (Liskov substitution principle). The PSR does not try to restrict nor define how to configure HTTP clients. An alternative approach would be to pass configuration to the client. That approach would have a few drawbacks: Configuration must be defined by the PSR. All clients must support the defined configuration. If no configuration is passed to the client, the behavior is unpredictable. Naming rationale The main interface behaviour is defined by the method sendRequest(RequestInterface $request): ResponseInterface . While the shorter method name send() has been proposed, this was already used by existing and very common HTTP clients like Guzzle. As such, if they are to adopt this standard, they may need to break backwards compatibility in order to implement the specification. By defining sendRequest() instead, we ensure they can adopt without any immediate BC breaks. Exception Model The domain exceptions NetworkExceptionInterface and RequestExceptionInterface define a contract very similar to each other. The chosen approach is to not let them extend each other because inheritance does not make sense in the domain model. A RequestExceptionInterface is simply not a NetworkExceptionInterface . Allowing exceptions to extend a RequestAwareException and/or ResponseAwareException interface has been discussed but that is a convenience shortcut that one should not take. One should rather catch the specific exceptions and handle them accordingly. One could be more granular when defining exceptions. For example, TimeOutException and HostNotFoundException could be subtypes of NetworkExceptionInterface . The chosen approach is not to define such subtypes because the exception handling in a consuming library would in most cases not be different between those exceptions. Throwing exceptions for 4xx and 5xx responses The initial idea was to allow the client to be configured to throw exceptions for responses with HTTP status 4xx and 5xx. That approach is not desired because consuming libraries would have to check for 4xx and 5xx responses twice: first, by verifying the status code on the response, and second by catching potential exceptions. To make the specification more predictable, it was decided that HTTP clients never will throw exceptions for 4xx and 5xx responses. Middleware and wrapping a client The specification does not put any limitations on middleware or classes that want to wrap/decorate an HTTP client. If the decorating class also implements ClientInterface then it must also follow the specification. It is temping to allow configuration or add middleware to an HTTP client so it could i.e. follow redirects or throw exceptions. If that is a decision from an application developer, they have specifically said they want to break the specification. That is an issue (or feature) the application developer should handle. Third party libraries MUST NOT assume that a HTTP client breaks the specification. Background The HTTP client PSR has been inspired and created by the php-http team . Back in 2015, they created HTTPlug as a common interface for HTTP clients. They wanted an abstraction that third party libraries could use so as not to rely on a specific HTTP client implementation. A stable version was tagged in January 2016, and the project has been widely adopted since then. With over 3 million downloads in the two years following the initial stable version, it was time to convert this \"de-facto\" standard into a formal specification. People 5.1 Editor Tobias Nyholm 5.2 Sponsors Sara Golemon 5.3 Workgroup Simon Asika (Windwalker) David Buchmann (HTTPlug) David De Boer (HTTPlug) Sara Golemon (Sponsor) Jeremy Lindblom (Guzzle) Christian L\u00fcck (Buzz react) Tobias Nyholm (Editor) Matthew Weier O'Phinney (Zend) Mark Sagi-Kazar (Guzzle) Joel Wurtz (HTTPlug) Votes Entrance vote Review Period Initiation Acceptance Proposed implementations Below are the two implementations provided by the working group to pass the review period: HTTPlug has prepared a 2.0 to make sure it is supporting the new PSR. They are just waiting for the PSR to be released: https://github.com/php-http/httplug/tree/2.x Buzz has been adapting to every version of the PSR and has their 0.17.3 release with the latest version of psr/http-client: https://github.com/kriswallsmith/Buzz","title":"PSR 18 http client meta"},{"location":"accepted/PSR-18-http-client-meta/#http-client-meta-document","text":"","title":"HTTP Client Meta Document"},{"location":"accepted/PSR-18-http-client-meta/#summary","text":"HTTP requests and responses are the two fundamental objects in web programming. All clients communicating to an external API use some form of HTTP client. Many libraries are coupled to one specific client or implement a client and/or adapter layer themselves. This leads to bad library design, version conflicts, or code unrelated to the library domain.","title":"Summary"},{"location":"accepted/PSR-18-http-client-meta/#why-bother","text":"Thanks to PSR-7 we know how HTTP requests and responses ideally look, but nothing defines how a request should be sent and a response received. A common interface for HTTP clients will allow libraries to be decoupled from specific implementations.","title":"Why bother?"},{"location":"accepted/PSR-18-http-client-meta/#scope","text":"","title":"Scope"},{"location":"accepted/PSR-18-http-client-meta/#goals","text":"A common interface for sending PSR-7 messages and returning PSR-7 responses.","title":"Goals"},{"location":"accepted/PSR-18-http-client-meta/#non-goals","text":"Support for asynchronous HTTP requests is left for another future PSR. This PSR does not define how to configure an HTTP client. It only specifies the default behaviours. This PSR is neutral about the use of middleware.","title":"Non-Goals"},{"location":"accepted/PSR-18-http-client-meta/#asynchronous-http-client","text":"The reason asynchronous requests are not covered by this PSR is the lack of a common standard for Promises. Promises are sufficiently complex enough that they deserve their own specification, and should not be wrapped into this one. A separate interface for asynchronous requests can be defined in a separate PSR once a Promise PSR is accepted. The method signature for asynchronous requests MUST be different from the method signature for synchronous requests because the return type of asynchronous calls will be a Promise. Thus this PSR is forwards compatible, and clients will be able to implement one or both interfaces based on the features they wish to expose.","title":"Asynchronous HTTP client"},{"location":"accepted/PSR-18-http-client-meta/#approaches","text":"","title":"Approaches"},{"location":"accepted/PSR-18-http-client-meta/#default-behavior","text":"The intention of this PSR is to provide library developers with HTTP clients that have a well defined behaviour. A library should be able to use any compliant client without special code to handle client implementation details (Liskov substitution principle). The PSR does not try to restrict nor define how to configure HTTP clients. An alternative approach would be to pass configuration to the client. That approach would have a few drawbacks: Configuration must be defined by the PSR. All clients must support the defined configuration. If no configuration is passed to the client, the behavior is unpredictable.","title":"Default behavior"},{"location":"accepted/PSR-18-http-client-meta/#naming-rationale","text":"The main interface behaviour is defined by the method sendRequest(RequestInterface $request): ResponseInterface . While the shorter method name send() has been proposed, this was already used by existing and very common HTTP clients like Guzzle. As such, if they are to adopt this standard, they may need to break backwards compatibility in order to implement the specification. By defining sendRequest() instead, we ensure they can adopt without any immediate BC breaks.","title":"Naming rationale"},{"location":"accepted/PSR-18-http-client-meta/#exception-model","text":"The domain exceptions NetworkExceptionInterface and RequestExceptionInterface define a contract very similar to each other. The chosen approach is to not let them extend each other because inheritance does not make sense in the domain model. A RequestExceptionInterface is simply not a NetworkExceptionInterface . Allowing exceptions to extend a RequestAwareException and/or ResponseAwareException interface has been discussed but that is a convenience shortcut that one should not take. One should rather catch the specific exceptions and handle them accordingly. One could be more granular when defining exceptions. For example, TimeOutException and HostNotFoundException could be subtypes of NetworkExceptionInterface . The chosen approach is not to define such subtypes because the exception handling in a consuming library would in most cases not be different between those exceptions.","title":"Exception Model"},{"location":"accepted/PSR-18-http-client-meta/#throwing-exceptions-for-4xx-and-5xx-responses","text":"The initial idea was to allow the client to be configured to throw exceptions for responses with HTTP status 4xx and 5xx. That approach is not desired because consuming libraries would have to check for 4xx and 5xx responses twice: first, by verifying the status code on the response, and second by catching potential exceptions. To make the specification more predictable, it was decided that HTTP clients never will throw exceptions for 4xx and 5xx responses.","title":"Throwing exceptions for 4xx and 5xx responses"},{"location":"accepted/PSR-18-http-client-meta/#middleware-and-wrapping-a-client","text":"The specification does not put any limitations on middleware or classes that want to wrap/decorate an HTTP client. If the decorating class also implements ClientInterface then it must also follow the specification. It is temping to allow configuration or add middleware to an HTTP client so it could i.e. follow redirects or throw exceptions. If that is a decision from an application developer, they have specifically said they want to break the specification. That is an issue (or feature) the application developer should handle. Third party libraries MUST NOT assume that a HTTP client breaks the specification.","title":"Middleware and wrapping a client"},{"location":"accepted/PSR-18-http-client-meta/#background","text":"The HTTP client PSR has been inspired and created by the php-http team . Back in 2015, they created HTTPlug as a common interface for HTTP clients. They wanted an abstraction that third party libraries could use so as not to rely on a specific HTTP client implementation. A stable version was tagged in January 2016, and the project has been widely adopted since then. With over 3 million downloads in the two years following the initial stable version, it was time to convert this \"de-facto\" standard into a formal specification.","title":"Background"},{"location":"accepted/PSR-18-http-client-meta/#people","text":"","title":"People"},{"location":"accepted/PSR-18-http-client-meta/#51-editor","text":"Tobias Nyholm","title":"5.1 Editor"},{"location":"accepted/PSR-18-http-client-meta/#52-sponsors","text":"Sara Golemon","title":"5.2 Sponsors"},{"location":"accepted/PSR-18-http-client-meta/#53-workgroup","text":"Simon Asika (Windwalker) David Buchmann (HTTPlug) David De Boer (HTTPlug) Sara Golemon (Sponsor) Jeremy Lindblom (Guzzle) Christian L\u00fcck (Buzz react) Tobias Nyholm (Editor) Matthew Weier O'Phinney (Zend) Mark Sagi-Kazar (Guzzle) Joel Wurtz (HTTPlug)","title":"5.3 Workgroup"},{"location":"accepted/PSR-18-http-client-meta/#votes","text":"Entrance vote Review Period Initiation Acceptance","title":"Votes"},{"location":"accepted/PSR-18-http-client-meta/#proposed-implementations","text":"Below are the two implementations provided by the working group to pass the review period: HTTPlug has prepared a 2.0 to make sure it is supporting the new PSR. They are just waiting for the PSR to be released: https://github.com/php-http/httplug/tree/2.x Buzz has been adapting to every version of the PSR and has their 0.17.3 release with the latest version of psr/http-client: https://github.com/kriswallsmith/Buzz","title":"Proposed implementations"},{"location":"accepted/PSR-18-http-client/","text":"HTTP Client This document describes a common interface for sending HTTP requests and receiving HTTP responses. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . Goal The goal of this PSR is to allow developers to create libraries decoupled from HTTP client implementations. This will make libraries more reusable as it reduces the number of dependencies and lowers the likelihood of version conflicts. A second goal is that HTTP clients can be replaced as per the Liskov substitution principle . This means that all clients MUST behave in the same way when sending a request. Definitions Client - A Client is a library that implements this specification for the purposes of sending PSR-7-compatible HTTP Request messages and returning a PSR-7-compatible HTTP Response message to a Calling library. Calling Library - A Calling Library is any code that makes use of a Client. It does not implement this specification's interfaces but consumes an object that implements them (a Client). Client A Client is an object implementing ClientInterface . A Client MAY: Choose to send an altered HTTP request from the one it was provided. For example, it could compress an outgoing message body. Choose to alter a received HTTP response before returning it to the calling library. For example, it could decompress an incoming message body. If a Client chooses to alter either the HTTP request or HTTP response, it MUST ensure that the object remains internally consistent. For example, if a Client chooses to decompress the message body then it MUST also remove the Content-Encoding header and adjust the Content-Length header. Note that as a result, since PSR-7 objects are immutable , the Calling Library MUST NOT assume that the object passed to ClientInterface::sendRequest() will be the same PHP object that is actually sent. For example, the Request object that is returned by an exception MAY be a different object than the one passed to sendRequest() , so comparison by reference (===) is not possible. A Client MUST: Reassemble a multi-step HTTP 1xx response itself so that what is returned to the Calling Library is a valid HTTP response of status code 200 or higher. Error handling A Client MUST NOT treat a well-formed HTTP request or HTTP response as an error condition. For example, response status codes in the 400 and 500 range MUST NOT cause an exception and MUST be returned to the Calling Library as normal. A Client MUST throw an instance of Psr\\Http\\Client\\ClientExceptionInterface if and only if it is unable to send the HTTP request at all or if the HTTP response could not be parsed into a PSR-7 response object. If a request cannot be sent because the request message is not a well-formed HTTP request or is missing some critical piece of information (such as a Host or Method), the Client MUST throw an instance of Psr\\Http\\Client\\RequestExceptionInterface . If the request cannot be sent due to a network failure of any kind, including a timeout, the Client MUST throw an instance of Psr\\Http\\Client\\NetworkExceptionInterface . Clients MAY throw more specific exceptions than those defined here (a TimeOutException or HostNotFoundException for example), provided they implement the appropriate interface defined above. Interfaces ClientInterface namespace Psr\\Http\\Client; use Psr\\Http\\Message\\RequestInterface; use Psr\\Http\\Message\\ResponseInterface; interface ClientInterface { /** * Sends a PSR-7 request and returns a PSR-7 response. * * @param RequestInterface $request * * @return ResponseInterface * * @throws \\Psr\\Http\\Client\\ClientExceptionInterface If an error happens while processing the request. */ public function sendRequest(RequestInterface $request): ResponseInterface; } ClientExceptionInterface namespace Psr\\Http\\Client; /** * Every HTTP client related exception MUST implement this interface. */ interface ClientExceptionInterface extends \\Throwable { } RequestExceptionInterface namespace Psr\\Http\\Client; use Psr\\Http\\Message\\RequestInterface; /** * Exception for when a request failed. * * Examples: * - Request is invalid (e.g. method is missing) * - Runtime request errors (e.g. the body stream is not seekable) */ interface RequestExceptionInterface extends ClientExceptionInterface { /** * Returns the request. * * The request object MAY be a different object from the one passed to ClientInterface::sendRequest() * * @return RequestInterface */ public function getRequest(): RequestInterface; } NetworkExceptionInterface namespace Psr\\Http\\Client; use Psr\\Http\\Message\\RequestInterface; /** * Thrown when the request cannot be completed because of network issues. * * There is no response object as this exception is thrown when no response has been received. * * Example: the target host name can not be resolved or the connection failed. */ interface NetworkExceptionInterface extends ClientExceptionInterface { /** * Returns the request. * * The request object MAY be a different object from the one passed to ClientInterface::sendRequest() * * @return RequestInterface */ public function getRequest(): RequestInterface; }","title":"PSR 18 http client"},{"location":"accepted/PSR-18-http-client/#http-client","text":"This document describes a common interface for sending HTTP requests and receiving HTTP responses. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"HTTP Client"},{"location":"accepted/PSR-18-http-client/#goal","text":"The goal of this PSR is to allow developers to create libraries decoupled from HTTP client implementations. This will make libraries more reusable as it reduces the number of dependencies and lowers the likelihood of version conflicts. A second goal is that HTTP clients can be replaced as per the Liskov substitution principle . This means that all clients MUST behave in the same way when sending a request.","title":"Goal"},{"location":"accepted/PSR-18-http-client/#definitions","text":"Client - A Client is a library that implements this specification for the purposes of sending PSR-7-compatible HTTP Request messages and returning a PSR-7-compatible HTTP Response message to a Calling library. Calling Library - A Calling Library is any code that makes use of a Client. It does not implement this specification's interfaces but consumes an object that implements them (a Client).","title":"Definitions"},{"location":"accepted/PSR-18-http-client/#client","text":"A Client is an object implementing ClientInterface . A Client MAY: Choose to send an altered HTTP request from the one it was provided. For example, it could compress an outgoing message body. Choose to alter a received HTTP response before returning it to the calling library. For example, it could decompress an incoming message body. If a Client chooses to alter either the HTTP request or HTTP response, it MUST ensure that the object remains internally consistent. For example, if a Client chooses to decompress the message body then it MUST also remove the Content-Encoding header and adjust the Content-Length header. Note that as a result, since PSR-7 objects are immutable , the Calling Library MUST NOT assume that the object passed to ClientInterface::sendRequest() will be the same PHP object that is actually sent. For example, the Request object that is returned by an exception MAY be a different object than the one passed to sendRequest() , so comparison by reference (===) is not possible. A Client MUST: Reassemble a multi-step HTTP 1xx response itself so that what is returned to the Calling Library is a valid HTTP response of status code 200 or higher.","title":"Client"},{"location":"accepted/PSR-18-http-client/#error-handling","text":"A Client MUST NOT treat a well-formed HTTP request or HTTP response as an error condition. For example, response status codes in the 400 and 500 range MUST NOT cause an exception and MUST be returned to the Calling Library as normal. A Client MUST throw an instance of Psr\\Http\\Client\\ClientExceptionInterface if and only if it is unable to send the HTTP request at all or if the HTTP response could not be parsed into a PSR-7 response object. If a request cannot be sent because the request message is not a well-formed HTTP request or is missing some critical piece of information (such as a Host or Method), the Client MUST throw an instance of Psr\\Http\\Client\\RequestExceptionInterface . If the request cannot be sent due to a network failure of any kind, including a timeout, the Client MUST throw an instance of Psr\\Http\\Client\\NetworkExceptionInterface . Clients MAY throw more specific exceptions than those defined here (a TimeOutException or HostNotFoundException for example), provided they implement the appropriate interface defined above.","title":"Error handling"},{"location":"accepted/PSR-18-http-client/#interfaces","text":"","title":"Interfaces"},{"location":"accepted/PSR-18-http-client/#clientinterface","text":"namespace Psr\\Http\\Client; use Psr\\Http\\Message\\RequestInterface; use Psr\\Http\\Message\\ResponseInterface; interface ClientInterface { /** * Sends a PSR-7 request and returns a PSR-7 response. * * @param RequestInterface $request * * @return ResponseInterface * * @throws \\Psr\\Http\\Client\\ClientExceptionInterface If an error happens while processing the request. */ public function sendRequest(RequestInterface $request): ResponseInterface; }","title":"ClientInterface"},{"location":"accepted/PSR-18-http-client/#clientexceptioninterface","text":"namespace Psr\\Http\\Client; /** * Every HTTP client related exception MUST implement this interface. */ interface ClientExceptionInterface extends \\Throwable { }","title":"ClientExceptionInterface"},{"location":"accepted/PSR-18-http-client/#requestexceptioninterface","text":"namespace Psr\\Http\\Client; use Psr\\Http\\Message\\RequestInterface; /** * Exception for when a request failed. * * Examples: * - Request is invalid (e.g. method is missing) * - Runtime request errors (e.g. the body stream is not seekable) */ interface RequestExceptionInterface extends ClientExceptionInterface { /** * Returns the request. * * The request object MAY be a different object from the one passed to ClientInterface::sendRequest() * * @return RequestInterface */ public function getRequest(): RequestInterface; }","title":"RequestExceptionInterface"},{"location":"accepted/PSR-18-http-client/#networkexceptioninterface","text":"namespace Psr\\Http\\Client; use Psr\\Http\\Message\\RequestInterface; /** * Thrown when the request cannot be completed because of network issues. * * There is no response object as this exception is thrown when no response has been received. * * Example: the target host name can not be resolved or the connection failed. */ interface NetworkExceptionInterface extends ClientExceptionInterface { /** * Returns the request. * * The request object MAY be a different object from the one passed to ClientInterface::sendRequest() * * @return RequestInterface */ public function getRequest(): RequestInterface; }","title":"NetworkExceptionInterface"},{"location":"accepted/PSR-2-coding-style-guide-meta/","text":"PSR-2 Meta Document 1. Summary The intent of this guide is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code. The style rules herein are derived from commonalities among the various member projects. When various authors collaborate across multiple projects, it helps to have one set of guidelines to be used among all those projects. Thus, the benefit of this guide is not in the rules themselves, but in the sharing of those rules. 2. Votes Acceptance Vote: ML 3. Errata 3.1 - Multi-line Arguments (09/08/2013) Using one or more multi-line arguments (i.e: arrays or anonymous functions) does not constitute splitting the argument list itself, therefore Section 4.6 is not automatically enforced. Arrays and anonymous functions are able to span multiple lines. The following examples are perfectly valid in PSR-2: <?php somefunction($foo, $bar, [ // ... ], $baz); $app->get('/hello/{name}', function ($name) use ($app) { return 'Hello '.$app->escape($name); }); 3.2 - Extending Multiple Interfaces (10/17/2013) When extending multiple interfaces, the list of extends should be treated the same as a list of implements , as declared in Section 4.1.","title":"PSR-2 Meta Document"},{"location":"accepted/PSR-2-coding-style-guide-meta/#psr-2-meta-document","text":"","title":"PSR-2 Meta Document"},{"location":"accepted/PSR-2-coding-style-guide-meta/#1-summary","text":"The intent of this guide is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code. The style rules herein are derived from commonalities among the various member projects. When various authors collaborate across multiple projects, it helps to have one set of guidelines to be used among all those projects. Thus, the benefit of this guide is not in the rules themselves, but in the sharing of those rules.","title":"1. Summary"},{"location":"accepted/PSR-2-coding-style-guide-meta/#2-votes","text":"Acceptance Vote: ML","title":"2. Votes"},{"location":"accepted/PSR-2-coding-style-guide-meta/#3-errata","text":"","title":"3. Errata"},{"location":"accepted/PSR-2-coding-style-guide-meta/#31-multi-line-arguments-09082013","text":"Using one or more multi-line arguments (i.e: arrays or anonymous functions) does not constitute splitting the argument list itself, therefore Section 4.6 is not automatically enforced. Arrays and anonymous functions are able to span multiple lines. The following examples are perfectly valid in PSR-2: <?php somefunction($foo, $bar, [ // ... ], $baz); $app->get('/hello/{name}', function ($name) use ($app) { return 'Hello '.$app->escape($name); });","title":"3.1 - Multi-line Arguments (09/08/2013)"},{"location":"accepted/PSR-2-coding-style-guide-meta/#32-extending-multiple-interfaces-10172013","text":"When extending multiple interfaces, the list of extends should be treated the same as a list of implements , as declared in Section 4.1.","title":"3.2 - Extending Multiple Interfaces (10/17/2013)"},{"location":"accepted/PSR-2-coding-style-guide/","text":"Coding Style Guide Deprecated - As of 2019-08-10 PSR-2 has been marked as deprecated. PSR-12 is now recommended as an alternative. This guide extends and expands on PSR-1 , the basic coding standard. The intent of this guide is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code. The style rules herein are derived from commonalities among the various member projects. When various authors collaborate across multiple projects, it helps to have one set of guidelines to be used among all those projects. Thus, the benefit of this guide is not in the rules themselves, but in the sharing of those rules. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . 1. Overview Code MUST follow a \"coding style guide\" PSR [[PSR-1]]. Code MUST use 4 spaces for indenting, not tabs. There MUST NOT be a hard limit on line length; the soft limit MUST be 120 characters; lines SHOULD be 80 characters or less. There MUST be one blank line after the namespace declaration, and there MUST be one blank line after the block of use declarations. Opening braces for classes MUST go on the next line, and closing braces MUST go on the next line after the body. Opening braces for methods MUST go on the next line, and closing braces MUST go on the next line after the body. Visibility MUST be declared on all properties and methods; abstract and final MUST be declared before the visibility; static MUST be declared after the visibility. Control structure keywords MUST have one space after them; method and function calls MUST NOT. Opening braces for control structures MUST go on the same line, and closing braces MUST go on the next line after the body. Opening parentheses for control structures MUST NOT have a space after them, and closing parentheses for control structures MUST NOT have a space before. 1.1. Example This example encompasses some of the rules below as a quick overview: <?php namespace Vendor\\Package; use FooInterface; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class Foo extends Bar implements FooInterface { public function sampleMethod($a, $b = null) { if ($a === $b) { bar(); } elseif ($a > $b) { $foo->bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static function bar() { // method body } } 2. General 2.1. Basic Coding Standard Code MUST follow all rules outlined in PSR-1 . 2.2. Files All PHP files MUST use the Unix LF (linefeed) line ending. All PHP files MUST end with a single blank line. The closing ?> tag MUST be omitted from files containing only PHP. 2.3. Lines There MUST NOT be a hard limit on line length. The soft limit on line length MUST be 120 characters; automated style checkers MUST warn but MUST NOT error at the soft limit. Lines SHOULD NOT be longer than 80 characters; lines longer than that SHOULD be split into multiple subsequent lines of no more than 80 characters each. There MUST NOT be trailing whitespace at the end of non-blank lines. Blank lines MAY be added to improve readability and to indicate related blocks of code. There MUST NOT be more than one statement per line. 2.4. Indenting Code MUST use an indent of 4 spaces, and MUST NOT use tabs for indenting. N.b.: Using only spaces, and not mixing spaces with tabs, helps to avoid problems with diffs, patches, history, and annotations. The use of spaces also makes it easy to insert fine-grained sub-indentation for inter-line alignment. 2.5. Keywords and True/False/Null PHP keywords MUST be in lower case. The PHP constants true , false , and null MUST be in lower case. 3. Namespace and Use Declarations When present, there MUST be one blank line after the namespace declaration. When present, all use declarations MUST go after the namespace declaration. There MUST be one use keyword per declaration. There MUST be one blank line after the use block. For example: <?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; // ... additional PHP code ... 4. Classes, Properties, and Methods The term \"class\" refers to all classes, interfaces, and traits. 4.1. Extends and Implements The extends and implements keywords MUST be declared on the same line as the class name. The opening brace for the class MUST go on its own line; the closing brace for the class MUST go on the next line after the body. <?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class ClassName extends ParentClass implements \\ArrayAccess, \\Countable { // constants, properties, methods } Lists of implements MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one interface per line. <?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class ClassName extends ParentClass implements \\ArrayAccess, \\Countable, \\Serializable { // constants, properties, methods } 4.2. Properties Visibility MUST be declared on all properties. The var keyword MUST NOT be used to declare a property. There MUST NOT be more than one property declared per statement. Property names SHOULD NOT be prefixed with a single underscore to indicate protected or private visibility. A property declaration looks like the following. <?php namespace Vendor\\Package; class ClassName { public $foo = null; } 4.3. Methods Visibility MUST be declared on all methods. Method names SHOULD NOT be prefixed with a single underscore to indicate protected or private visibility. Method names MUST NOT be declared with a space after the method name. The opening brace MUST go on its own line, and the closing brace MUST go on the next line following the body. There MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis. A method declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces: <?php namespace Vendor\\Package; class ClassName { public function fooBarBaz($arg1, &$arg2, $arg3 = []) { // method body } } 4.4. Method Arguments In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. Method arguments with default values MUST go at the end of the argument list. <?php namespace Vendor\\Package; class ClassName { public function foo($arg1, &$arg2, $arg3 = []) { // method body } } Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line. When the argument list is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them. <?php namespace Vendor\\Package; class ClassName { public function aVeryLongMethodName( ClassTypeHint $arg1, &$arg2, array $arg3 = [] ) { // method body } } 4.5. abstract , final , and static When present, the abstract and final declarations MUST precede the visibility declaration. When present, the static declaration MUST come after the visibility declaration. <?php namespace Vendor\\Package; abstract class ClassName { protected static $foo; abstract protected function zim(); final public static function bar() { // method body } } 4.6. Method and Function Calls When making a method or function call, there MUST NOT be a space between the method or function name and the opening parenthesis, there MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis. In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. <?php bar(); $foo->bar($arg1); Foo::bar($arg2, $arg3); Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line. <?php $foo->bar( $longArgument, $longerArgument, $muchLongerArgument ); 5. Control Structures The general style rules for control structures are as follows: There MUST be one space after the control structure keyword There MUST NOT be a space after the opening parenthesis There MUST NOT be a space before the closing parenthesis There MUST be one space between the closing parenthesis and the opening brace The structure body MUST be indented once The closing brace MUST be on the next line after the body The body of each structure MUST be enclosed by braces. This standardizes how the structures look, and reduces the likelihood of introducing errors as new lines get added to the body. 5.1. if , elseif , else An if structure looks like the following. Note the placement of parentheses, spaces, and braces; and that else and elseif are on the same line as the closing brace from the earlier body. <?php if ($expr1) { // if body } elseif ($expr2) { // elseif body } else { // else body; } The keyword elseif SHOULD be used instead of else if so that all control keywords look like single words. 5.2. switch , case A switch structure looks like the following. Note the placement of parentheses, spaces, and braces. The case statement MUST be indented once from switch , and the break keyword (or other terminating keyword) MUST be indented at the same level as the case body. There MUST be a comment such as // no break when fall-through is intentional in a non-empty case body. <?php switch ($expr) { case 0: echo 'First case, with a break'; break; case 1: echo 'Second case, which falls through'; // no break case 2: case 3: case 4: echo 'Third case, return instead of break'; return; default: echo 'Default case'; break; } 5.3. while , do while A while statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php while ($expr) { // structure body } Similarly, a do while statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php do { // structure body; } while ($expr); 5.4. for A for statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php for ($i = 0; $i < 10; $i++) { // for body } 5.5. foreach A foreach statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php foreach ($iterable as $key => $value) { // foreach body } 5.6. try , catch A try catch block looks like the following. Note the placement of parentheses, spaces, and braces. <?php try { // try body } catch (FirstExceptionType $e) { // catch body } catch (OtherExceptionType $e) { // catch body } 6. Closures Closures MUST be declared with a space after the function keyword, and a space before and after the use keyword. The opening brace MUST go on the same line, and the closing brace MUST go on the next line following the body. There MUST NOT be a space after the opening parenthesis of the argument list or variable list, and there MUST NOT be a space before the closing parenthesis of the argument list or variable list. In the argument list and variable list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. Closure arguments with default values MUST go at the end of the argument list. A closure declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces: <?php $closureWithArgs = function ($arg1, $arg2) { // body }; $closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) { // body }; Argument lists and variable lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument or variable per line. When the ending list (whether of arguments or variables) is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them. The following are examples of closures with and without argument lists and variable lists split across multiple lines. <?php $longArgs_noVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) { // body }; $noArgs_longVars = function () use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_longVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_shortVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ($var1) { // body }; $shortArgs_longVars = function ($arg) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; Note that the formatting rules also apply when the closure is used directly in a function or method call as an argument. <?php $foo->bar( $arg1, function ($arg2) use ($var1) { // body }, $arg3 ); 7. Conclusion There are many elements of style and practice intentionally omitted by this guide. These include but are not limited to: Declaration of global variables and global constants Declaration of functions Operators and assignment Inter-line alignment Comments and documentation blocks Class name prefixes and suffixes Best practices Future recommendations MAY revise and extend this guide to address those or other elements of style and practice. Appendix A. Survey In writing this style guide, the group took a survey of member projects to determine common practices. The survey is retained herein for posterity. A.1. Survey Data url,http://www.horde.org/apps/horde/docs/CODING_STANDARDS,http://pear.php.net/manual/en/standards.php,http://solarphp.com/manual/appendix-standards.style,http://framework.zend.com/manual/en/coding-standard.html,https://symfony.com/doc/2.0/contributing/code/standards.html,http://www.ppi.io/docs/coding-standards.html,https://github.com/ezsystems/ezp-next/wiki/codingstandards,http://book.cakephp.org/2.0/en/contributing/cakephp-coding-conventions.html,https://github.com/UnionOfRAD/lithium/wiki/Spec%3A-Coding,http://drupal.org/coding-standards,http://code.google.com/p/sabredav/,http://area51.phpbb.com/docs/31x/coding-guidelines.html,https://docs.google.com/a/zikula.org/document/edit?authkey=CPCU0Us&hgd=1&id=1fcqb93Sn-hR9c0mkN6m_tyWnmEvoswKBtSc0tKkZmJA,http://www.chisimba.com,n/a,https://github.com/Respect/project-info/blob/master/coding-standards-sample.php,n/a,Object Calisthenics for PHP,http://doc.nette.org/en/coding-standard,http://flow3.typo3.org,https://github.com/propelorm/Propel2/wiki/Coding-Standards,http://developer.joomla.org/coding-standards.html voting,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,no,no,no,?,yes,no,yes indent_type,4,4,4,4,4,tab,4,tab,tab,2,4,tab,4,4,4,4,4,4,tab,tab,4,tab line_length_limit_soft,75,75,75,75,no,85,120,120,80,80,80,no,100,80,80,?,?,120,80,120,no,150 line_length_limit_hard,85,85,85,85,no,no,no,no,100,?,no,no,no,100,100,?,120,120,no,no,no,no class_names,studly,studly,studly,studly,studly,studly,studly,studly,studly,studly,studly,lower_under,studly,lower,studly,studly,studly,studly,?,studly,studly,studly class_brace_line,next,next,next,next,next,same,next,same,same,same,same,next,next,next,next,next,next,next,next,same,next,next constant_names,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper true_false_null,lower,lower,lower,lower,lower,lower,lower,lower,lower,upper,lower,lower,lower,upper,lower,lower,lower,lower,lower,upper,lower,lower method_names,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,lower_under,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel method_brace_line,next,next,next,next,next,same,next,same,same,same,same,next,next,same,next,next,next,next,next,same,next,next control_brace_line,same,same,same,same,same,same,next,same,same,same,same,next,same,same,next,same,same,same,same,same,same,next control_space_after,yes,yes,yes,yes,yes,no,yes,yes,yes,yes,no,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes always_use_control_braces,yes,yes,yes,yes,yes,yes,no,yes,yes,yes,no,yes,yes,yes,yes,no,yes,yes,yes,yes,yes,yes else_elseif_line,same,same,same,same,same,same,next,same,same,next,same,next,same,next,next,same,same,same,same,same,same,next case_break_indent_from_switch,0/1,0/1,0/1,1/2,1/2,1/2,1/2,1/1,1/1,1/2,1/2,1/1,1/2,1/2,1/2,1/2,1/2,1/2,0/1,1/1,1/2,1/2 function_space_after,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no closing_php_tag_required,no,no,no,no,no,no,no,no,yes,no,no,no,no,yes,no,no,no,no,no,yes,no,no line_endings,LF,LF,LF,LF,LF,LF,LF,LF,?,LF,?,LF,LF,LF,LF,?,,LF,?,LF,LF,LF static_or_visibility_first,static,?,static,either,either,either,visibility,visibility,visibility,either,static,either,?,visibility,?,?,either,either,visibility,visibility,static,? control_space_parens,no,no,no,no,no,no,yes,no,no,no,no,no,no,yes,?,no,no,no,no,no,no,no blank_line_after_php,no,no,no,no,yes,no,no,no,no,yes,yes,no,no,yes,?,yes,yes,no,yes,no,yes,no class_method_control_brace,next/next/same,next/next/same,next/next/same,next/next/same,next/next/same,same/same/same,next/next/next,same/same/same,same/same/same,same/same/same,same/same/same,next/next/next,next/next/same,next/same/same,next/next/next,next/next/same,next/next/same,next/next/same,next/next/same,same/same/same,next/next/same,next/next/next A.2. Survey Legend indent_type : The type of indenting. tab = \"Use a tab\", 2 or 4 = \"number of spaces\" line_length_limit_soft : The \"soft\" line length limit, in characters. ? = not discernible or no response, no means no limit. line_length_limit_hard : The \"hard\" line length limit, in characters. ? = not discernible or no response, no means no limit. class_names : How classes are named. lower = lowercase only, lower_under = lowercase with underscore separators, studly = StudlyCase. class_brace_line : Does the opening brace for a class go on the same line as the class keyword, or on the next line after it? constant_names : How are class constants named? upper = Uppercase with underscore separators. true_false_null : Are the true , false , and null keywords spelled as all lower case, or all upper case? method_names : How are methods named? camel = camelCase , lower_under = lowercase with underscore separators. method_brace_line : Does the opening brace for a method go on the same line as the method name, or on the next line? control_brace_line : Does the opening brace for a control structure go on the same line, or on the next line? control_space_after : Is there a space after the control structure keyword? always_use_control_braces : Do control structures always use braces? else_elseif_line : When using else or elseif , does it go on the same line as the previous closing brace, or does it go on the next line? case_break_indent_from_switch : How many times are case and break indented from an opening switch statement? function_space_after : Do function calls have a space after the function name and before the opening parenthesis? closing_php_tag_required : In files containing only PHP, is the closing ?> tag required? line_endings : What type of line ending is used? static_or_visibility_first : When declaring a method, does static come first, or does the visibility come first? control_space_parens : In a control structure expression, is there a space after the opening parenthesis and a space before the closing parenthesis? yes = if ( $expr ) , no = if ($expr) . blank_line_after_php : Is there a blank line after the opening PHP tag? class_method_control_brace : A summary of what line the opening braces go on for classes, methods, and control structures. A.3. Survey Results indent_type: tab: 7 2: 1 4: 14 line_length_limit_soft: ?: 2 no: 3 75: 4 80: 6 85: 1 100: 1 120: 4 150: 1 line_length_limit_hard: ?: 2 no: 11 85: 4 100: 3 120: 2 class_names: ?: 1 lower: 1 lower_under: 1 studly: 19 class_brace_line: next: 16 same: 6 constant_names: upper: 22 true_false_null: lower: 19 upper: 3 method_names: camel: 21 lower_under: 1 method_brace_line: next: 15 same: 7 control_brace_line: next: 4 same: 18 control_space_after: no: 2 yes: 20 always_use_control_braces: no: 3 yes: 19 else_elseif_line: next: 6 same: 16 case_break_indent_from_switch: 0/1: 4 1/1: 4 1/2: 14 function_space_after: no: 22 closing_php_tag_required: no: 19 yes: 3 line_endings: ?: 5 LF: 17 static_or_visibility_first: ?: 5 either: 7 static: 4 visibility: 6 control_space_parens: ?: 1 no: 19 yes: 2 blank_line_after_php: ?: 1 no: 13 yes: 8 class_method_control_brace: next/next/next: 4 next/next/same: 11 next/same/same: 1 same/same/same: 6","title":"Coding Style Guide"},{"location":"accepted/PSR-2-coding-style-guide/#coding-style-guide","text":"Deprecated - As of 2019-08-10 PSR-2 has been marked as deprecated. PSR-12 is now recommended as an alternative. This guide extends and expands on PSR-1 , the basic coding standard. The intent of this guide is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code. The style rules herein are derived from commonalities among the various member projects. When various authors collaborate across multiple projects, it helps to have one set of guidelines to be used among all those projects. Thus, the benefit of this guide is not in the rules themselves, but in the sharing of those rules. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"Coding Style Guide"},{"location":"accepted/PSR-2-coding-style-guide/#1-overview","text":"Code MUST follow a \"coding style guide\" PSR [[PSR-1]]. Code MUST use 4 spaces for indenting, not tabs. There MUST NOT be a hard limit on line length; the soft limit MUST be 120 characters; lines SHOULD be 80 characters or less. There MUST be one blank line after the namespace declaration, and there MUST be one blank line after the block of use declarations. Opening braces for classes MUST go on the next line, and closing braces MUST go on the next line after the body. Opening braces for methods MUST go on the next line, and closing braces MUST go on the next line after the body. Visibility MUST be declared on all properties and methods; abstract and final MUST be declared before the visibility; static MUST be declared after the visibility. Control structure keywords MUST have one space after them; method and function calls MUST NOT. Opening braces for control structures MUST go on the same line, and closing braces MUST go on the next line after the body. Opening parentheses for control structures MUST NOT have a space after them, and closing parentheses for control structures MUST NOT have a space before.","title":"1. Overview"},{"location":"accepted/PSR-2-coding-style-guide/#11-example","text":"This example encompasses some of the rules below as a quick overview: <?php namespace Vendor\\Package; use FooInterface; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class Foo extends Bar implements FooInterface { public function sampleMethod($a, $b = null) { if ($a === $b) { bar(); } elseif ($a > $b) { $foo->bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static function bar() { // method body } }","title":"1.1. Example"},{"location":"accepted/PSR-2-coding-style-guide/#2-general","text":"","title":"2. General"},{"location":"accepted/PSR-2-coding-style-guide/#21-basic-coding-standard","text":"Code MUST follow all rules outlined in PSR-1 .","title":"2.1. Basic Coding Standard"},{"location":"accepted/PSR-2-coding-style-guide/#22-files","text":"All PHP files MUST use the Unix LF (linefeed) line ending. All PHP files MUST end with a single blank line. The closing ?> tag MUST be omitted from files containing only PHP.","title":"2.2. Files"},{"location":"accepted/PSR-2-coding-style-guide/#23-lines","text":"There MUST NOT be a hard limit on line length. The soft limit on line length MUST be 120 characters; automated style checkers MUST warn but MUST NOT error at the soft limit. Lines SHOULD NOT be longer than 80 characters; lines longer than that SHOULD be split into multiple subsequent lines of no more than 80 characters each. There MUST NOT be trailing whitespace at the end of non-blank lines. Blank lines MAY be added to improve readability and to indicate related blocks of code. There MUST NOT be more than one statement per line.","title":"2.3. Lines"},{"location":"accepted/PSR-2-coding-style-guide/#24-indenting","text":"Code MUST use an indent of 4 spaces, and MUST NOT use tabs for indenting. N.b.: Using only spaces, and not mixing spaces with tabs, helps to avoid problems with diffs, patches, history, and annotations. The use of spaces also makes it easy to insert fine-grained sub-indentation for inter-line alignment.","title":"2.4. Indenting"},{"location":"accepted/PSR-2-coding-style-guide/#25-keywords-and-truefalsenull","text":"PHP keywords MUST be in lower case. The PHP constants true , false , and null MUST be in lower case.","title":"2.5. Keywords and True/False/Null"},{"location":"accepted/PSR-2-coding-style-guide/#3-namespace-and-use-declarations","text":"When present, there MUST be one blank line after the namespace declaration. When present, all use declarations MUST go after the namespace declaration. There MUST be one use keyword per declaration. There MUST be one blank line after the use block. For example: <?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; // ... additional PHP code ...","title":"3. Namespace and Use Declarations"},{"location":"accepted/PSR-2-coding-style-guide/#4-classes-properties-and-methods","text":"The term \"class\" refers to all classes, interfaces, and traits.","title":"4. Classes, Properties, and Methods"},{"location":"accepted/PSR-2-coding-style-guide/#41-extends-and-implements","text":"The extends and implements keywords MUST be declared on the same line as the class name. The opening brace for the class MUST go on its own line; the closing brace for the class MUST go on the next line after the body. <?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class ClassName extends ParentClass implements \\ArrayAccess, \\Countable { // constants, properties, methods } Lists of implements MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one interface per line. <?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class ClassName extends ParentClass implements \\ArrayAccess, \\Countable, \\Serializable { // constants, properties, methods }","title":"4.1. Extends and Implements"},{"location":"accepted/PSR-2-coding-style-guide/#42-properties","text":"Visibility MUST be declared on all properties. The var keyword MUST NOT be used to declare a property. There MUST NOT be more than one property declared per statement. Property names SHOULD NOT be prefixed with a single underscore to indicate protected or private visibility. A property declaration looks like the following. <?php namespace Vendor\\Package; class ClassName { public $foo = null; }","title":"4.2. Properties"},{"location":"accepted/PSR-2-coding-style-guide/#43-methods","text":"Visibility MUST be declared on all methods. Method names SHOULD NOT be prefixed with a single underscore to indicate protected or private visibility. Method names MUST NOT be declared with a space after the method name. The opening brace MUST go on its own line, and the closing brace MUST go on the next line following the body. There MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis. A method declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces: <?php namespace Vendor\\Package; class ClassName { public function fooBarBaz($arg1, &$arg2, $arg3 = []) { // method body } }","title":"4.3. Methods"},{"location":"accepted/PSR-2-coding-style-guide/#44-method-arguments","text":"In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. Method arguments with default values MUST go at the end of the argument list. <?php namespace Vendor\\Package; class ClassName { public function foo($arg1, &$arg2, $arg3 = []) { // method body } } Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line. When the argument list is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them. <?php namespace Vendor\\Package; class ClassName { public function aVeryLongMethodName( ClassTypeHint $arg1, &$arg2, array $arg3 = [] ) { // method body } }","title":"4.4. Method Arguments"},{"location":"accepted/PSR-2-coding-style-guide/#45-abstract-final-and-static","text":"When present, the abstract and final declarations MUST precede the visibility declaration. When present, the static declaration MUST come after the visibility declaration. <?php namespace Vendor\\Package; abstract class ClassName { protected static $foo; abstract protected function zim(); final public static function bar() { // method body } }","title":"4.5. abstract, final, and static"},{"location":"accepted/PSR-2-coding-style-guide/#46-method-and-function-calls","text":"When making a method or function call, there MUST NOT be a space between the method or function name and the opening parenthesis, there MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis. In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. <?php bar(); $foo->bar($arg1); Foo::bar($arg2, $arg3); Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line. <?php $foo->bar( $longArgument, $longerArgument, $muchLongerArgument );","title":"4.6. Method and Function Calls"},{"location":"accepted/PSR-2-coding-style-guide/#5-control-structures","text":"The general style rules for control structures are as follows: There MUST be one space after the control structure keyword There MUST NOT be a space after the opening parenthesis There MUST NOT be a space before the closing parenthesis There MUST be one space between the closing parenthesis and the opening brace The structure body MUST be indented once The closing brace MUST be on the next line after the body The body of each structure MUST be enclosed by braces. This standardizes how the structures look, and reduces the likelihood of introducing errors as new lines get added to the body.","title":"5. Control Structures"},{"location":"accepted/PSR-2-coding-style-guide/#51-if-elseif-else","text":"An if structure looks like the following. Note the placement of parentheses, spaces, and braces; and that else and elseif are on the same line as the closing brace from the earlier body. <?php if ($expr1) { // if body } elseif ($expr2) { // elseif body } else { // else body; } The keyword elseif SHOULD be used instead of else if so that all control keywords look like single words.","title":"5.1. if, elseif, else"},{"location":"accepted/PSR-2-coding-style-guide/#52-switch-case","text":"A switch structure looks like the following. Note the placement of parentheses, spaces, and braces. The case statement MUST be indented once from switch , and the break keyword (or other terminating keyword) MUST be indented at the same level as the case body. There MUST be a comment such as // no break when fall-through is intentional in a non-empty case body. <?php switch ($expr) { case 0: echo 'First case, with a break'; break; case 1: echo 'Second case, which falls through'; // no break case 2: case 3: case 4: echo 'Third case, return instead of break'; return; default: echo 'Default case'; break; }","title":"5.2. switch, case"},{"location":"accepted/PSR-2-coding-style-guide/#53-while-do-while","text":"A while statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php while ($expr) { // structure body } Similarly, a do while statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php do { // structure body; } while ($expr);","title":"5.3. while, do while"},{"location":"accepted/PSR-2-coding-style-guide/#54-for","text":"A for statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php for ($i = 0; $i < 10; $i++) { // for body }","title":"5.4. for"},{"location":"accepted/PSR-2-coding-style-guide/#55-foreach","text":"A foreach statement looks like the following. Note the placement of parentheses, spaces, and braces. <?php foreach ($iterable as $key => $value) { // foreach body }","title":"5.5. foreach"},{"location":"accepted/PSR-2-coding-style-guide/#56-try-catch","text":"A try catch block looks like the following. Note the placement of parentheses, spaces, and braces. <?php try { // try body } catch (FirstExceptionType $e) { // catch body } catch (OtherExceptionType $e) { // catch body }","title":"5.6. try, catch"},{"location":"accepted/PSR-2-coding-style-guide/#6-closures","text":"Closures MUST be declared with a space after the function keyword, and a space before and after the use keyword. The opening brace MUST go on the same line, and the closing brace MUST go on the next line following the body. There MUST NOT be a space after the opening parenthesis of the argument list or variable list, and there MUST NOT be a space before the closing parenthesis of the argument list or variable list. In the argument list and variable list, there MUST NOT be a space before each comma, and there MUST be one space after each comma. Closure arguments with default values MUST go at the end of the argument list. A closure declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces: <?php $closureWithArgs = function ($arg1, $arg2) { // body }; $closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) { // body }; Argument lists and variable lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument or variable per line. When the ending list (whether of arguments or variables) is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them. The following are examples of closures with and without argument lists and variable lists split across multiple lines. <?php $longArgs_noVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) { // body }; $noArgs_longVars = function () use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_longVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_shortVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ($var1) { // body }; $shortArgs_longVars = function ($arg) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; Note that the formatting rules also apply when the closure is used directly in a function or method call as an argument. <?php $foo->bar( $arg1, function ($arg2) use ($var1) { // body }, $arg3 );","title":"6. Closures"},{"location":"accepted/PSR-2-coding-style-guide/#7-conclusion","text":"There are many elements of style and practice intentionally omitted by this guide. These include but are not limited to: Declaration of global variables and global constants Declaration of functions Operators and assignment Inter-line alignment Comments and documentation blocks Class name prefixes and suffixes Best practices Future recommendations MAY revise and extend this guide to address those or other elements of style and practice.","title":"7. Conclusion"},{"location":"accepted/PSR-2-coding-style-guide/#appendix-a-survey","text":"In writing this style guide, the group took a survey of member projects to determine common practices. The survey is retained herein for posterity.","title":"Appendix A. Survey"},{"location":"accepted/PSR-2-coding-style-guide/#a1-survey-data","text":"url,http://www.horde.org/apps/horde/docs/CODING_STANDARDS,http://pear.php.net/manual/en/standards.php,http://solarphp.com/manual/appendix-standards.style,http://framework.zend.com/manual/en/coding-standard.html,https://symfony.com/doc/2.0/contributing/code/standards.html,http://www.ppi.io/docs/coding-standards.html,https://github.com/ezsystems/ezp-next/wiki/codingstandards,http://book.cakephp.org/2.0/en/contributing/cakephp-coding-conventions.html,https://github.com/UnionOfRAD/lithium/wiki/Spec%3A-Coding,http://drupal.org/coding-standards,http://code.google.com/p/sabredav/,http://area51.phpbb.com/docs/31x/coding-guidelines.html,https://docs.google.com/a/zikula.org/document/edit?authkey=CPCU0Us&hgd=1&id=1fcqb93Sn-hR9c0mkN6m_tyWnmEvoswKBtSc0tKkZmJA,http://www.chisimba.com,n/a,https://github.com/Respect/project-info/blob/master/coding-standards-sample.php,n/a,Object Calisthenics for PHP,http://doc.nette.org/en/coding-standard,http://flow3.typo3.org,https://github.com/propelorm/Propel2/wiki/Coding-Standards,http://developer.joomla.org/coding-standards.html voting,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,no,no,no,?,yes,no,yes indent_type,4,4,4,4,4,tab,4,tab,tab,2,4,tab,4,4,4,4,4,4,tab,tab,4,tab line_length_limit_soft,75,75,75,75,no,85,120,120,80,80,80,no,100,80,80,?,?,120,80,120,no,150 line_length_limit_hard,85,85,85,85,no,no,no,no,100,?,no,no,no,100,100,?,120,120,no,no,no,no class_names,studly,studly,studly,studly,studly,studly,studly,studly,studly,studly,studly,lower_under,studly,lower,studly,studly,studly,studly,?,studly,studly,studly class_brace_line,next,next,next,next,next,same,next,same,same,same,same,next,next,next,next,next,next,next,next,same,next,next constant_names,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper true_false_null,lower,lower,lower,lower,lower,lower,lower,lower,lower,upper,lower,lower,lower,upper,lower,lower,lower,lower,lower,upper,lower,lower method_names,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,lower_under,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel method_brace_line,next,next,next,next,next,same,next,same,same,same,same,next,next,same,next,next,next,next,next,same,next,next control_brace_line,same,same,same,same,same,same,next,same,same,same,same,next,same,same,next,same,same,same,same,same,same,next control_space_after,yes,yes,yes,yes,yes,no,yes,yes,yes,yes,no,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes always_use_control_braces,yes,yes,yes,yes,yes,yes,no,yes,yes,yes,no,yes,yes,yes,yes,no,yes,yes,yes,yes,yes,yes else_elseif_line,same,same,same,same,same,same,next,same,same,next,same,next,same,next,next,same,same,same,same,same,same,next case_break_indent_from_switch,0/1,0/1,0/1,1/2,1/2,1/2,1/2,1/1,1/1,1/2,1/2,1/1,1/2,1/2,1/2,1/2,1/2,1/2,0/1,1/1,1/2,1/2 function_space_after,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no closing_php_tag_required,no,no,no,no,no,no,no,no,yes,no,no,no,no,yes,no,no,no,no,no,yes,no,no line_endings,LF,LF,LF,LF,LF,LF,LF,LF,?,LF,?,LF,LF,LF,LF,?,,LF,?,LF,LF,LF static_or_visibility_first,static,?,static,either,either,either,visibility,visibility,visibility,either,static,either,?,visibility,?,?,either,either,visibility,visibility,static,? control_space_parens,no,no,no,no,no,no,yes,no,no,no,no,no,no,yes,?,no,no,no,no,no,no,no blank_line_after_php,no,no,no,no,yes,no,no,no,no,yes,yes,no,no,yes,?,yes,yes,no,yes,no,yes,no class_method_control_brace,next/next/same,next/next/same,next/next/same,next/next/same,next/next/same,same/same/same,next/next/next,same/same/same,same/same/same,same/same/same,same/same/same,next/next/next,next/next/same,next/same/same,next/next/next,next/next/same,next/next/same,next/next/same,next/next/same,same/same/same,next/next/same,next/next/next","title":"A.1. Survey Data"},{"location":"accepted/PSR-2-coding-style-guide/#a2-survey-legend","text":"indent_type : The type of indenting. tab = \"Use a tab\", 2 or 4 = \"number of spaces\" line_length_limit_soft : The \"soft\" line length limit, in characters. ? = not discernible or no response, no means no limit. line_length_limit_hard : The \"hard\" line length limit, in characters. ? = not discernible or no response, no means no limit. class_names : How classes are named. lower = lowercase only, lower_under = lowercase with underscore separators, studly = StudlyCase. class_brace_line : Does the opening brace for a class go on the same line as the class keyword, or on the next line after it? constant_names : How are class constants named? upper = Uppercase with underscore separators. true_false_null : Are the true , false , and null keywords spelled as all lower case, or all upper case? method_names : How are methods named? camel = camelCase , lower_under = lowercase with underscore separators. method_brace_line : Does the opening brace for a method go on the same line as the method name, or on the next line? control_brace_line : Does the opening brace for a control structure go on the same line, or on the next line? control_space_after : Is there a space after the control structure keyword? always_use_control_braces : Do control structures always use braces? else_elseif_line : When using else or elseif , does it go on the same line as the previous closing brace, or does it go on the next line? case_break_indent_from_switch : How many times are case and break indented from an opening switch statement? function_space_after : Do function calls have a space after the function name and before the opening parenthesis? closing_php_tag_required : In files containing only PHP, is the closing ?> tag required? line_endings : What type of line ending is used? static_or_visibility_first : When declaring a method, does static come first, or does the visibility come first? control_space_parens : In a control structure expression, is there a space after the opening parenthesis and a space before the closing parenthesis? yes = if ( $expr ) , no = if ($expr) . blank_line_after_php : Is there a blank line after the opening PHP tag? class_method_control_brace : A summary of what line the opening braces go on for classes, methods, and control structures.","title":"A.2. Survey Legend"},{"location":"accepted/PSR-2-coding-style-guide/#a3-survey-results","text":"indent_type: tab: 7 2: 1 4: 14 line_length_limit_soft: ?: 2 no: 3 75: 4 80: 6 85: 1 100: 1 120: 4 150: 1 line_length_limit_hard: ?: 2 no: 11 85: 4 100: 3 120: 2 class_names: ?: 1 lower: 1 lower_under: 1 studly: 19 class_brace_line: next: 16 same: 6 constant_names: upper: 22 true_false_null: lower: 19 upper: 3 method_names: camel: 21 lower_under: 1 method_brace_line: next: 15 same: 7 control_brace_line: next: 4 same: 18 control_space_after: no: 2 yes: 20 always_use_control_braces: no: 3 yes: 19 else_elseif_line: next: 6 same: 16 case_break_indent_from_switch: 0/1: 4 1/1: 4 1/2: 14 function_space_after: no: 22 closing_php_tag_required: no: 19 yes: 3 line_endings: ?: 5 LF: 17 static_or_visibility_first: ?: 5 either: 7 static: 4 visibility: 6 control_space_parens: ?: 1 no: 19 yes: 2 blank_line_after_php: ?: 1 no: 13 yes: 8 class_method_control_brace: next/next/next: 4 next/next/same: 11 next/same/same: 1 same/same/same: 6","title":"A.3. Survey Results"},{"location":"accepted/PSR-3-logger-interface-meta/","text":"Logger Meta Document 1. Summary The logger interface defines a common interface for logging system messages from an application or library. This metadocument was written post-hoc, as PSR-3 was originally passed before meta-documents were standard practice. 2. Design Decisions Static log messages It is the intent of this specification that the message passed to a logging method always be a static value. Any context-specific variability (such as a username, timestamp, or other information) should be provided via the $context array only, and the string should use a placeholder to reference it. The intent of this design is twofold. One, the message is then readily available to translation systems to create localized versions of log messages. Two, context-specific data may contain user input, and thus requires escaping. That escaping will be necessarily different if the log message is stored in a database for later rendering in HTML, serialized to JSON, serialized to a syslog message string, etc. It is the responsibility of the logging implementation to ensure that $context data that is shown to the user is appropriately escaped. 3. People 3.1 Editor(s) Jordi Boggiano 4. Votes Approval vote 5. Errata 5.1 Type additions The 2.0 release of the psr/log package includes scalar parameter types. The 3.0 release of the package includes return types. This structure leverages PHP 7.2 covariance support to allow for a gradual upgrade process, but requires PHP 8.0 for type compatibility. Implementers MAY add return types to their own packages at their discretion, provided that: the return types match those in the 3.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later. Implementers MAY add parameter types to their own packages in a new major release, either at the same time as adding return types or in a subsequent release, provided that: the parameter types match those in the 2.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later. the implementation depends on \"psr/log\": \"^2.0 || ^3.0\" so as to exclude the untyped 1.0 version. Implementers are encouraged but not required to transition their packages toward the 3.0 version of the package at their earliest convenience.","title":"Logger Meta Document"},{"location":"accepted/PSR-3-logger-interface-meta/#logger-meta-document","text":"","title":"Logger Meta Document"},{"location":"accepted/PSR-3-logger-interface-meta/#1-summary","text":"The logger interface defines a common interface for logging system messages from an application or library. This metadocument was written post-hoc, as PSR-3 was originally passed before meta-documents were standard practice.","title":"1. Summary"},{"location":"accepted/PSR-3-logger-interface-meta/#2-design-decisions","text":"","title":"2. Design Decisions"},{"location":"accepted/PSR-3-logger-interface-meta/#static-log-messages","text":"It is the intent of this specification that the message passed to a logging method always be a static value. Any context-specific variability (such as a username, timestamp, or other information) should be provided via the $context array only, and the string should use a placeholder to reference it. The intent of this design is twofold. One, the message is then readily available to translation systems to create localized versions of log messages. Two, context-specific data may contain user input, and thus requires escaping. That escaping will be necessarily different if the log message is stored in a database for later rendering in HTML, serialized to JSON, serialized to a syslog message string, etc. It is the responsibility of the logging implementation to ensure that $context data that is shown to the user is appropriately escaped.","title":"Static log messages"},{"location":"accepted/PSR-3-logger-interface-meta/#3-people","text":"","title":"3. People"},{"location":"accepted/PSR-3-logger-interface-meta/#31-editors","text":"Jordi Boggiano","title":"3.1 Editor(s)"},{"location":"accepted/PSR-3-logger-interface-meta/#4-votes","text":"Approval vote","title":"4. Votes"},{"location":"accepted/PSR-3-logger-interface-meta/#5-errata","text":"","title":"5. Errata"},{"location":"accepted/PSR-3-logger-interface-meta/#51-type-additions","text":"The 2.0 release of the psr/log package includes scalar parameter types. The 3.0 release of the package includes return types. This structure leverages PHP 7.2 covariance support to allow for a gradual upgrade process, but requires PHP 8.0 for type compatibility. Implementers MAY add return types to their own packages at their discretion, provided that: the return types match those in the 3.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later. Implementers MAY add parameter types to their own packages in a new major release, either at the same time as adding return types or in a subsequent release, provided that: the parameter types match those in the 2.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later. the implementation depends on \"psr/log\": \"^2.0 || ^3.0\" so as to exclude the untyped 1.0 version. Implementers are encouraged but not required to transition their packages toward the 3.0 version of the package at their earliest convenience.","title":"5.1 Type additions"},{"location":"accepted/PSR-3-logger-interface/","text":"Logger Interface This document describes a common interface for logging libraries. The main goal is to allow libraries to receive a Psr\\Log\\LoggerInterface object and write logs to it in a simple and universal way. Frameworks and CMSs that have custom needs MAY extend the interface for their own purpose, but SHOULD remain compatible with this document. This ensures that the third-party libraries an application uses can write to the centralized application logs. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . The word implementor in this document is to be interpreted as someone implementing the LoggerInterface in a log-related library or framework. Users of loggers are referred to as user . 1. Specification 1.1 Basics The LoggerInterface exposes eight methods to write logs to the eight RFC 5424 levels (debug, info, notice, warning, error, critical, alert, emergency). A ninth method, log , accepts a log level as the first argument. Calling this method with one of the log level constants MUST have the same result as calling the level-specific method. Calling this method with a level not defined by this specification MUST throw a Psr\\Log\\InvalidArgumentException if the implementation does not know about the level. Users SHOULD NOT use a custom level without knowing for sure the current implementation supports it. 1.2 Message Every method accepts a string as the message, or an object with a __toString() method. Implementors MAY have special handling for the passed objects. If that is not the case, implementors MUST cast it to a string. The message MAY contain placeholders which implementors MAY replace with values from the context array. Placeholder names MUST correspond to keys in the context array. Placeholder names MUST be delimited with a single opening brace { and a single closing brace } . There MUST NOT be any whitespace between the delimiters and the placeholder name. Placeholder names SHOULD be composed only of the characters A-Z , a-z , 0-9 , underscore _ , and period . . The use of other characters is reserved for future modifications of the placeholders specification. Implementors MAY use placeholders to implement various escaping strategies and translate logs for display. Users SHOULD NOT pre-escape placeholder values since they can not know in which context the data will be displayed. The following is an example implementation of placeholder interpolation provided for reference purposes only: ~~~php <?php /* * Interpolates context values into the message placeholders. / function interpolate($message, array $context = array()) { // build a replacement array with braces around the context keys $replace = array(); foreach ($context as $key => $val) { // check that the value can be cast to string if (!is_array($val) && (!is_object($val) || method_exists($val, '__toString'))) { $replace['{' . $key . '}'] = $val; } } // interpolate replacement values into the message and return return strtr($message, $replace); } // a message with brace-delimited placeholder names $message = \"User {username} created\"; // a context array of placeholder names => replacement values $context = array('username' => 'bolivar'); // echoes \"User bolivar created\" echo interpolate($message, $context); ~~~ 1.3 Context Every method accepts an array as context data. This is meant to hold any extraneous information that does not fit well in a string. The array can contain anything. Implementors MUST ensure they treat context data with as much lenience as possible. A given value in the context MUST NOT throw an exception nor raise any php error, warning or notice. If an Exception object is passed in the context data, it MUST be in the 'exception' key. Logging exceptions is a common pattern and this allows implementors to extract a stack trace from the exception when the log backend supports it. Implementors MUST still verify that the 'exception' key is actually an Exception before using it as such, as it MAY contain anything. 1.4 Helper classes and interfaces The Psr\\Log\\AbstractLogger class lets you implement the LoggerInterface very easily by extending it and implementing the generic log method. The other eight methods are forwarding the message and context to it. Similarly, using the Psr\\Log\\LoggerTrait only requires you to implement the generic log method. Note that since traits can not implement interfaces, in this case you still have to implement LoggerInterface . The Psr\\Log\\NullLogger is provided together with the interface. It MAY be used by users of the interface to provide a fall-back \"black hole\" implementation if no logger is given to them. However, conditional logging may be a better approach if context data creation is expensive. The Psr\\Log\\LoggerAwareInterface only contains a setLogger(LoggerInterface $logger) method and can be used by frameworks to auto-wire arbitrary instances with a logger. The Psr\\Log\\LoggerAwareTrait trait can be used to implement the equivalent interface easily in any class. It gives you access to $this->logger . The Psr\\Log\\LogLevel class holds constants for the eight log levels. 2. Package The interfaces and classes described as well as relevant exception classes and a test suite to verify your implementation are provided as part of the psr/log package. 3. Psr\\Log\\LoggerInterface <?php namespace Psr\\Log; /** * Describes a logger instance. * * The message MUST be a string or object implementing __toString(). * * The message MAY contain placeholders in the form: {foo} where foo * will be replaced by the context data in key \"foo\". * * The context array can contain arbitrary data, the only assumption that * can be made by implementors is that if an Exception instance is given * to produce a stack trace, it MUST be in a key named \"exception\". * * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md * for the full interface specification. */ interface LoggerInterface { /** * System is unusable. * * @param string $message * @param array $context * @return void */ public function emergency($message, array $context = array()); /** * Action must be taken immediately. * * Example: Entire website down, database unavailable, etc. This should * trigger the SMS alerts and wake you up. * * @param string $message * @param array $context * @return void */ public function alert($message, array $context = array()); /** * Critical conditions. * * Example: Application component unavailable, unexpected exception. * * @param string $message * @param array $context * @return void */ public function critical($message, array $context = array()); /** * Runtime errors that do not require immediate action but should typically * be logged and monitored. * * @param string $message * @param array $context * @return void */ public function error($message, array $context = array()); /** * Exceptional occurrences that are not errors. * * Example: Use of deprecated APIs, poor use of an API, undesirable things * that are not necessarily wrong. * * @param string $message * @param array $context * @return void */ public function warning($message, array $context = array()); /** * Normal but significant events. * * @param string $message * @param array $context * @return void */ public function notice($message, array $context = array()); /** * Interesting events. * * Example: User logs in, SQL logs. * * @param string $message * @param array $context * @return void */ public function info($message, array $context = array()); /** * Detailed debug information. * * @param string $message * @param array $context * @return void */ public function debug($message, array $context = array()); /** * Logs with an arbitrary level. * * @param mixed $level * @param string $message * @param array $context * @return void */ public function log($level, $message, array $context = array()); } 4. Psr\\Log\\LoggerAwareInterface <?php namespace Psr\\Log; /** * Describes a logger-aware instance. */ interface LoggerAwareInterface { /** * Sets a logger instance on the object. * * @param LoggerInterface $logger * @return void */ public function setLogger(LoggerInterface $logger); } 5. Psr\\Log\\LogLevel <?php namespace Psr\\Log; /** * Describes log levels. */ class LogLevel { const EMERGENCY = 'emergency'; const ALERT = 'alert'; const CRITICAL = 'critical'; const ERROR = 'error'; const WARNING = 'warning'; const NOTICE = 'notice'; const INFO = 'info'; const DEBUG = 'debug'; }","title":"PSR 3 logger interface"},{"location":"accepted/PSR-3-logger-interface/#logger-interface","text":"This document describes a common interface for logging libraries. The main goal is to allow libraries to receive a Psr\\Log\\LoggerInterface object and write logs to it in a simple and universal way. Frameworks and CMSs that have custom needs MAY extend the interface for their own purpose, but SHOULD remain compatible with this document. This ensures that the third-party libraries an application uses can write to the centralized application logs. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . The word implementor in this document is to be interpreted as someone implementing the LoggerInterface in a log-related library or framework. Users of loggers are referred to as user .","title":"Logger Interface"},{"location":"accepted/PSR-3-logger-interface/#1-specification","text":"","title":"1. Specification"},{"location":"accepted/PSR-3-logger-interface/#11-basics","text":"The LoggerInterface exposes eight methods to write logs to the eight RFC 5424 levels (debug, info, notice, warning, error, critical, alert, emergency). A ninth method, log , accepts a log level as the first argument. Calling this method with one of the log level constants MUST have the same result as calling the level-specific method. Calling this method with a level not defined by this specification MUST throw a Psr\\Log\\InvalidArgumentException if the implementation does not know about the level. Users SHOULD NOT use a custom level without knowing for sure the current implementation supports it.","title":"1.1 Basics"},{"location":"accepted/PSR-3-logger-interface/#12-message","text":"Every method accepts a string as the message, or an object with a __toString() method. Implementors MAY have special handling for the passed objects. If that is not the case, implementors MUST cast it to a string. The message MAY contain placeholders which implementors MAY replace with values from the context array. Placeholder names MUST correspond to keys in the context array. Placeholder names MUST be delimited with a single opening brace { and a single closing brace } . There MUST NOT be any whitespace between the delimiters and the placeholder name. Placeholder names SHOULD be composed only of the characters A-Z , a-z , 0-9 , underscore _ , and period . . The use of other characters is reserved for future modifications of the placeholders specification. Implementors MAY use placeholders to implement various escaping strategies and translate logs for display. Users SHOULD NOT pre-escape placeholder values since they can not know in which context the data will be displayed. The following is an example implementation of placeholder interpolation provided for reference purposes only: ~~~php <?php /* * Interpolates context values into the message placeholders. / function interpolate($message, array $context = array()) { // build a replacement array with braces around the context keys $replace = array(); foreach ($context as $key => $val) { // check that the value can be cast to string if (!is_array($val) && (!is_object($val) || method_exists($val, '__toString'))) { $replace['{' . $key . '}'] = $val; } } // interpolate replacement values into the message and return return strtr($message, $replace); } // a message with brace-delimited placeholder names $message = \"User {username} created\"; // a context array of placeholder names => replacement values $context = array('username' => 'bolivar'); // echoes \"User bolivar created\" echo interpolate($message, $context); ~~~","title":"1.2 Message"},{"location":"accepted/PSR-3-logger-interface/#13-context","text":"Every method accepts an array as context data. This is meant to hold any extraneous information that does not fit well in a string. The array can contain anything. Implementors MUST ensure they treat context data with as much lenience as possible. A given value in the context MUST NOT throw an exception nor raise any php error, warning or notice. If an Exception object is passed in the context data, it MUST be in the 'exception' key. Logging exceptions is a common pattern and this allows implementors to extract a stack trace from the exception when the log backend supports it. Implementors MUST still verify that the 'exception' key is actually an Exception before using it as such, as it MAY contain anything.","title":"1.3 Context"},{"location":"accepted/PSR-3-logger-interface/#14-helper-classes-and-interfaces","text":"The Psr\\Log\\AbstractLogger class lets you implement the LoggerInterface very easily by extending it and implementing the generic log method. The other eight methods are forwarding the message and context to it. Similarly, using the Psr\\Log\\LoggerTrait only requires you to implement the generic log method. Note that since traits can not implement interfaces, in this case you still have to implement LoggerInterface . The Psr\\Log\\NullLogger is provided together with the interface. It MAY be used by users of the interface to provide a fall-back \"black hole\" implementation if no logger is given to them. However, conditional logging may be a better approach if context data creation is expensive. The Psr\\Log\\LoggerAwareInterface only contains a setLogger(LoggerInterface $logger) method and can be used by frameworks to auto-wire arbitrary instances with a logger. The Psr\\Log\\LoggerAwareTrait trait can be used to implement the equivalent interface easily in any class. It gives you access to $this->logger . The Psr\\Log\\LogLevel class holds constants for the eight log levels.","title":"1.4 Helper classes and interfaces"},{"location":"accepted/PSR-3-logger-interface/#2-package","text":"The interfaces and classes described as well as relevant exception classes and a test suite to verify your implementation are provided as part of the psr/log package.","title":"2. Package"},{"location":"accepted/PSR-3-logger-interface/#3-psrlogloggerinterface","text":"<?php namespace Psr\\Log; /** * Describes a logger instance. * * The message MUST be a string or object implementing __toString(). * * The message MAY contain placeholders in the form: {foo} where foo * will be replaced by the context data in key \"foo\". * * The context array can contain arbitrary data, the only assumption that * can be made by implementors is that if an Exception instance is given * to produce a stack trace, it MUST be in a key named \"exception\". * * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md * for the full interface specification. */ interface LoggerInterface { /** * System is unusable. * * @param string $message * @param array $context * @return void */ public function emergency($message, array $context = array()); /** * Action must be taken immediately. * * Example: Entire website down, database unavailable, etc. This should * trigger the SMS alerts and wake you up. * * @param string $message * @param array $context * @return void */ public function alert($message, array $context = array()); /** * Critical conditions. * * Example: Application component unavailable, unexpected exception. * * @param string $message * @param array $context * @return void */ public function critical($message, array $context = array()); /** * Runtime errors that do not require immediate action but should typically * be logged and monitored. * * @param string $message * @param array $context * @return void */ public function error($message, array $context = array()); /** * Exceptional occurrences that are not errors. * * Example: Use of deprecated APIs, poor use of an API, undesirable things * that are not necessarily wrong. * * @param string $message * @param array $context * @return void */ public function warning($message, array $context = array()); /** * Normal but significant events. * * @param string $message * @param array $context * @return void */ public function notice($message, array $context = array()); /** * Interesting events. * * Example: User logs in, SQL logs. * * @param string $message * @param array $context * @return void */ public function info($message, array $context = array()); /** * Detailed debug information. * * @param string $message * @param array $context * @return void */ public function debug($message, array $context = array()); /** * Logs with an arbitrary level. * * @param mixed $level * @param string $message * @param array $context * @return void */ public function log($level, $message, array $context = array()); }","title":"3. Psr\\Log\\LoggerInterface"},{"location":"accepted/PSR-3-logger-interface/#4-psrlogloggerawareinterface","text":"<?php namespace Psr\\Log; /** * Describes a logger-aware instance. */ interface LoggerAwareInterface { /** * Sets a logger instance on the object. * * @param LoggerInterface $logger * @return void */ public function setLogger(LoggerInterface $logger); }","title":"4. Psr\\Log\\LoggerAwareInterface"},{"location":"accepted/PSR-3-logger-interface/#5-psrlogloglevel","text":"<?php namespace Psr\\Log; /** * Describes log levels. */ class LogLevel { const EMERGENCY = 'emergency'; const ALERT = 'alert'; const CRITICAL = 'critical'; const ERROR = 'error'; const WARNING = 'warning'; const NOTICE = 'notice'; const INFO = 'info'; const DEBUG = 'debug'; }","title":"5. Psr\\Log\\LogLevel"},{"location":"accepted/PSR-4-autoloader-examples/","text":"Example Implementations of PSR-4 The following examples illustrate PSR-4 compliant code: Closure Example <?php /** * An example of a project-specific implementation. * * After registering this autoload function with SPL, the following line * would cause the function to attempt to load the \\Foo\\Bar\\Baz\\Qux class * from /path/to/project/src/Baz/Qux.php: * * new \\Foo\\Bar\\Baz\\Qux; * * @param string $class The fully-qualified class name. * @return void */ spl_autoload_register(function ($class) { // project-specific namespace prefix $prefix = 'Foo\\\\Bar\\\\'; // base directory for the namespace prefix $base_dir = __DIR__ . '/src/'; // does the class use the namespace prefix? $len = strlen($prefix); if (strncmp($prefix, $class, $len) !== 0) { // no, move to the next registered autoloader return; } // get the relative class name $relative_class = substr($class, $len); // replace the namespace prefix with the base directory, replace namespace // separators with directory separators in the relative class name, append // with .php $file = $base_dir . str_replace('\\\\', '/', $relative_class) . '.php'; // if the file exists, require it if (file_exists($file)) { require $file; } }); Class Example The following is an example class implementation to handle multiple namespaces: <?php namespace Example; /** * An example of a general-purpose implementation that includes the optional * functionality of allowing multiple base directories for a single namespace * prefix. * * Given a foo-bar package of classes in the file system at the following * paths ... * * /path/to/packages/foo-bar/ * src/ * Baz.php # Foo\\Bar\\Baz * Qux/ * Quux.php # Foo\\Bar\\Qux\\Quux * tests/ * BazTest.php # Foo\\Bar\\BazTest * Qux/ * QuuxTest.php # Foo\\Bar\\Qux\\QuuxTest * * ... add the path to the class files for the \\Foo\\Bar\\ namespace prefix * as follows: * * <?php * // instantiate the loader * $loader = new \\Example\\Psr4AutoloaderClass; * * // register the autoloader * $loader->register(); * * // register the base directories for the namespace prefix * $loader->addNamespace('Foo\\Bar', '/path/to/packages/foo-bar/src'); * $loader->addNamespace('Foo\\Bar', '/path/to/packages/foo-bar/tests'); * * The following line would cause the autoloader to attempt to load the * \\Foo\\Bar\\Qux\\Quux class from /path/to/packages/foo-bar/src/Qux/Quux.php: * * <?php * new \\Foo\\Bar\\Qux\\Quux; * * The following line would cause the autoloader to attempt to load the * \\Foo\\Bar\\Qux\\QuuxTest class from /path/to/packages/foo-bar/tests/Qux/QuuxTest.php: * * <?php * new \\Foo\\Bar\\Qux\\QuuxTest; */ class Psr4AutoloaderClass { /** * An associative array where the key is a namespace prefix and the value * is an array of base directories for classes in that namespace. * * @var array */ protected $prefixes = array(); /** * Register loader with SPL autoloader stack. * * @return void */ public function register() { spl_autoload_register(array($this, 'loadClass')); } /** * Adds a base directory for a namespace prefix. * * @param string $prefix The namespace prefix. * @param string $base_dir A base directory for class files in the * namespace. * @param bool $prepend If true, prepend the base directory to the stack * instead of appending it; this causes it to be searched first rather * than last. * @return void */ public function addNamespace($prefix, $base_dir, $prepend = false) { // normalize namespace prefix $prefix = trim($prefix, '\\\\') . '\\\\'; // normalize the base directory with a trailing separator $base_dir = rtrim($base_dir, DIRECTORY_SEPARATOR) . '/'; // initialize the namespace prefix array if (isset($this->prefixes[$prefix]) === false) { $this->prefixes[$prefix] = array(); } // retain the base directory for the namespace prefix if ($prepend) { array_unshift($this->prefixes[$prefix], $base_dir); } else { array_push($this->prefixes[$prefix], $base_dir); } } /** * Loads the class file for a given class name. * * @param string $class The fully-qualified class name. * @return mixed The mapped file name on success, or boolean false on * failure. */ public function loadClass($class) { // the current namespace prefix $prefix = $class; // work backwards through the namespace names of the fully-qualified // class name to find a mapped file name while (false !== $pos = strrpos($prefix, '\\\\')) { // retain the trailing namespace separator in the prefix $prefix = substr($class, 0, $pos + 1); // the rest is the relative class name $relative_class = substr($class, $pos + 1); // try to load a mapped file for the prefix and relative class $mapped_file = $this->loadMappedFile($prefix, $relative_class); if ($mapped_file) { return $mapped_file; } // remove the trailing namespace separator for the next iteration // of strrpos() $prefix = rtrim($prefix, '\\\\'); } // never found a mapped file return false; } /** * Load the mapped file for a namespace prefix and relative class. * * @param string $prefix The namespace prefix. * @param string $relative_class The relative class name. * @return mixed Boolean false if no mapped file can be loaded, or the * name of the mapped file that was loaded. */ protected function loadMappedFile($prefix, $relative_class) { // are there any base directories for this namespace prefix? if (isset($this->prefixes[$prefix]) === false) { return false; } // look through base directories for this namespace prefix foreach ($this->prefixes[$prefix] as $base_dir) { // replace the namespace prefix with the base directory, // replace namespace separators with directory separators // in the relative class name, append with .php $file = $base_dir . str_replace('\\\\', '/', $relative_class) . '.php'; // if the mapped file exists, require it if ($this->requireFile($file)) { // yes, we're done return $file; } } // never found it return false; } /** * If a file exists, require it from the file system. * * @param string $file The file to require. * @return bool True if the file exists, false if not. */ protected function requireFile($file) { if (file_exists($file)) { require $file; return true; } return false; } } Unit Tests The following example is one way of unit testing the above class loader: <?php namespace Example\\Tests; class MockPsr4AutoloaderClass extends Psr4AutoloaderClass { protected $files = array(); public function setFiles(array $files) { $this->files = $files; } protected function requireFile($file) { return in_array($file, $this->files); } } class Psr4AutoloaderClassTest extends \\PHPUnit_Framework_TestCase { protected $loader; protected function setUp() { $this->loader = new MockPsr4AutoloaderClass; $this->loader->setFiles(array( '/vendor/foo.bar/src/ClassName.php', '/vendor/foo.bar/src/DoomClassName.php', '/vendor/foo.bar/tests/ClassNameTest.php', '/vendor/foo.bardoom/src/ClassName.php', '/vendor/foo.bar.baz.dib/src/ClassName.php', '/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php', )); $this->loader->addNamespace( 'Foo\\Bar', '/vendor/foo.bar/src' ); $this->loader->addNamespace( 'Foo\\Bar', '/vendor/foo.bar/tests' ); $this->loader->addNamespace( 'Foo\\BarDoom', '/vendor/foo.bardoom/src' ); $this->loader->addNamespace( 'Foo\\Bar\\Baz\\Dib', '/vendor/foo.bar.baz.dib/src' ); $this->loader->addNamespace( 'Foo\\Bar\\Baz\\Dib\\Zim\\Gir', '/vendor/foo.bar.baz.dib.zim.gir/src' ); } public function testExistingFile() { $actual = $this->loader->loadClass('Foo\\Bar\\ClassName'); $expect = '/vendor/foo.bar/src/ClassName.php'; $this->assertSame($expect, $actual); $actual = $this->loader->loadClass('Foo\\Bar\\ClassNameTest'); $expect = '/vendor/foo.bar/tests/ClassNameTest.php'; $this->assertSame($expect, $actual); } public function testMissingFile() { $actual = $this->loader->loadClass('No_Vendor\\No_Package\\NoClass'); $this->assertFalse($actual); } public function testDeepFile() { $actual = $this->loader->loadClass('Foo\\Bar\\Baz\\Dib\\Zim\\Gir\\ClassName'); $expect = '/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php'; $this->assertSame($expect, $actual); } public function testConfusion() { $actual = $this->loader->loadClass('Foo\\Bar\\DoomClassName'); $expect = '/vendor/foo.bar/src/DoomClassName.php'; $this->assertSame($expect, $actual); $actual = $this->loader->loadClass('Foo\\BarDoom\\ClassName'); $expect = '/vendor/foo.bardoom/src/ClassName.php'; $this->assertSame($expect, $actual); } }","title":"PSR 4 autoloader examples"},{"location":"accepted/PSR-4-autoloader-examples/#example-implementations-of-psr-4","text":"The following examples illustrate PSR-4 compliant code:","title":"Example Implementations of PSR-4"},{"location":"accepted/PSR-4-autoloader-examples/#closure-example","text":"<?php /** * An example of a project-specific implementation. * * After registering this autoload function with SPL, the following line * would cause the function to attempt to load the \\Foo\\Bar\\Baz\\Qux class * from /path/to/project/src/Baz/Qux.php: * * new \\Foo\\Bar\\Baz\\Qux; * * @param string $class The fully-qualified class name. * @return void */ spl_autoload_register(function ($class) { // project-specific namespace prefix $prefix = 'Foo\\\\Bar\\\\'; // base directory for the namespace prefix $base_dir = __DIR__ . '/src/'; // does the class use the namespace prefix? $len = strlen($prefix); if (strncmp($prefix, $class, $len) !== 0) { // no, move to the next registered autoloader return; } // get the relative class name $relative_class = substr($class, $len); // replace the namespace prefix with the base directory, replace namespace // separators with directory separators in the relative class name, append // with .php $file = $base_dir . str_replace('\\\\', '/', $relative_class) . '.php'; // if the file exists, require it if (file_exists($file)) { require $file; } });","title":"Closure Example"},{"location":"accepted/PSR-4-autoloader-examples/#class-example","text":"The following is an example class implementation to handle multiple namespaces: <?php namespace Example; /** * An example of a general-purpose implementation that includes the optional * functionality of allowing multiple base directories for a single namespace * prefix. * * Given a foo-bar package of classes in the file system at the following * paths ... * * /path/to/packages/foo-bar/ * src/ * Baz.php # Foo\\Bar\\Baz * Qux/ * Quux.php # Foo\\Bar\\Qux\\Quux * tests/ * BazTest.php # Foo\\Bar\\BazTest * Qux/ * QuuxTest.php # Foo\\Bar\\Qux\\QuuxTest * * ... add the path to the class files for the \\Foo\\Bar\\ namespace prefix * as follows: * * <?php * // instantiate the loader * $loader = new \\Example\\Psr4AutoloaderClass; * * // register the autoloader * $loader->register(); * * // register the base directories for the namespace prefix * $loader->addNamespace('Foo\\Bar', '/path/to/packages/foo-bar/src'); * $loader->addNamespace('Foo\\Bar', '/path/to/packages/foo-bar/tests'); * * The following line would cause the autoloader to attempt to load the * \\Foo\\Bar\\Qux\\Quux class from /path/to/packages/foo-bar/src/Qux/Quux.php: * * <?php * new \\Foo\\Bar\\Qux\\Quux; * * The following line would cause the autoloader to attempt to load the * \\Foo\\Bar\\Qux\\QuuxTest class from /path/to/packages/foo-bar/tests/Qux/QuuxTest.php: * * <?php * new \\Foo\\Bar\\Qux\\QuuxTest; */ class Psr4AutoloaderClass { /** * An associative array where the key is a namespace prefix and the value * is an array of base directories for classes in that namespace. * * @var array */ protected $prefixes = array(); /** * Register loader with SPL autoloader stack. * * @return void */ public function register() { spl_autoload_register(array($this, 'loadClass')); } /** * Adds a base directory for a namespace prefix. * * @param string $prefix The namespace prefix. * @param string $base_dir A base directory for class files in the * namespace. * @param bool $prepend If true, prepend the base directory to the stack * instead of appending it; this causes it to be searched first rather * than last. * @return void */ public function addNamespace($prefix, $base_dir, $prepend = false) { // normalize namespace prefix $prefix = trim($prefix, '\\\\') . '\\\\'; // normalize the base directory with a trailing separator $base_dir = rtrim($base_dir, DIRECTORY_SEPARATOR) . '/'; // initialize the namespace prefix array if (isset($this->prefixes[$prefix]) === false) { $this->prefixes[$prefix] = array(); } // retain the base directory for the namespace prefix if ($prepend) { array_unshift($this->prefixes[$prefix], $base_dir); } else { array_push($this->prefixes[$prefix], $base_dir); } } /** * Loads the class file for a given class name. * * @param string $class The fully-qualified class name. * @return mixed The mapped file name on success, or boolean false on * failure. */ public function loadClass($class) { // the current namespace prefix $prefix = $class; // work backwards through the namespace names of the fully-qualified // class name to find a mapped file name while (false !== $pos = strrpos($prefix, '\\\\')) { // retain the trailing namespace separator in the prefix $prefix = substr($class, 0, $pos + 1); // the rest is the relative class name $relative_class = substr($class, $pos + 1); // try to load a mapped file for the prefix and relative class $mapped_file = $this->loadMappedFile($prefix, $relative_class); if ($mapped_file) { return $mapped_file; } // remove the trailing namespace separator for the next iteration // of strrpos() $prefix = rtrim($prefix, '\\\\'); } // never found a mapped file return false; } /** * Load the mapped file for a namespace prefix and relative class. * * @param string $prefix The namespace prefix. * @param string $relative_class The relative class name. * @return mixed Boolean false if no mapped file can be loaded, or the * name of the mapped file that was loaded. */ protected function loadMappedFile($prefix, $relative_class) { // are there any base directories for this namespace prefix? if (isset($this->prefixes[$prefix]) === false) { return false; } // look through base directories for this namespace prefix foreach ($this->prefixes[$prefix] as $base_dir) { // replace the namespace prefix with the base directory, // replace namespace separators with directory separators // in the relative class name, append with .php $file = $base_dir . str_replace('\\\\', '/', $relative_class) . '.php'; // if the mapped file exists, require it if ($this->requireFile($file)) { // yes, we're done return $file; } } // never found it return false; } /** * If a file exists, require it from the file system. * * @param string $file The file to require. * @return bool True if the file exists, false if not. */ protected function requireFile($file) { if (file_exists($file)) { require $file; return true; } return false; } }","title":"Class Example"},{"location":"accepted/PSR-4-autoloader-examples/#unit-tests","text":"The following example is one way of unit testing the above class loader: <?php namespace Example\\Tests; class MockPsr4AutoloaderClass extends Psr4AutoloaderClass { protected $files = array(); public function setFiles(array $files) { $this->files = $files; } protected function requireFile($file) { return in_array($file, $this->files); } } class Psr4AutoloaderClassTest extends \\PHPUnit_Framework_TestCase { protected $loader; protected function setUp() { $this->loader = new MockPsr4AutoloaderClass; $this->loader->setFiles(array( '/vendor/foo.bar/src/ClassName.php', '/vendor/foo.bar/src/DoomClassName.php', '/vendor/foo.bar/tests/ClassNameTest.php', '/vendor/foo.bardoom/src/ClassName.php', '/vendor/foo.bar.baz.dib/src/ClassName.php', '/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php', )); $this->loader->addNamespace( 'Foo\\Bar', '/vendor/foo.bar/src' ); $this->loader->addNamespace( 'Foo\\Bar', '/vendor/foo.bar/tests' ); $this->loader->addNamespace( 'Foo\\BarDoom', '/vendor/foo.bardoom/src' ); $this->loader->addNamespace( 'Foo\\Bar\\Baz\\Dib', '/vendor/foo.bar.baz.dib/src' ); $this->loader->addNamespace( 'Foo\\Bar\\Baz\\Dib\\Zim\\Gir', '/vendor/foo.bar.baz.dib.zim.gir/src' ); } public function testExistingFile() { $actual = $this->loader->loadClass('Foo\\Bar\\ClassName'); $expect = '/vendor/foo.bar/src/ClassName.php'; $this->assertSame($expect, $actual); $actual = $this->loader->loadClass('Foo\\Bar\\ClassNameTest'); $expect = '/vendor/foo.bar/tests/ClassNameTest.php'; $this->assertSame($expect, $actual); } public function testMissingFile() { $actual = $this->loader->loadClass('No_Vendor\\No_Package\\NoClass'); $this->assertFalse($actual); } public function testDeepFile() { $actual = $this->loader->loadClass('Foo\\Bar\\Baz\\Dib\\Zim\\Gir\\ClassName'); $expect = '/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php'; $this->assertSame($expect, $actual); } public function testConfusion() { $actual = $this->loader->loadClass('Foo\\Bar\\DoomClassName'); $expect = '/vendor/foo.bar/src/DoomClassName.php'; $this->assertSame($expect, $actual); $actual = $this->loader->loadClass('Foo\\BarDoom\\ClassName'); $expect = '/vendor/foo.bardoom/src/ClassName.php'; $this->assertSame($expect, $actual); } }","title":"Unit Tests"},{"location":"accepted/PSR-4-autoloader-meta/","text":"PSR-4 Meta Document 1. Summary The purpose is to specify the rules for an interoperable PHP autoloader that maps namespaces to file system paths, and that can co-exist with any other SPL registered autoloader. This would be an addition to, not a replacement for, PSR-0. 2. Why Bother? History of PSR-0 The PSR-0 class naming and autoloading standard rose out of the broad acceptance of the Horde/PEAR convention under the constraints of PHP 5.2 and previous. With that convention, the tendency was to put all PHP source classes in a single main directory, using underscores in the class name to indicate pseudo-namespaces, like so: /path/to/src/ VendorFoo/ Bar/ Baz.php # VendorFoo_Bar_Baz VendorDib/ Zim/ Gir.php # Vendor_Dib_Zim_Gir With the release of PHP 5.3 and the availability of namespaces proper, PSR-0 was introduced to allow both the old Horde/PEAR underscore mode and the use of the new namespace notation. Underscores were still allowed in the class name to ease the transition from the older namespace naming to the newer naming, and thereby to encourage wider adoption. /path/to/src/ VendorFoo/ Bar/ Baz.php # VendorFoo_Bar_Baz VendorDib/ Zim/ Gir.php # VendorDib_Zim_Gir Irk_Operation/ Impending_Doom/ V1.php V2.php # Irk_Operation\\Impending_Doom\\V2 This structure is informed very much by the fact that the PEAR installer moved source files from PEAR packages into a single central directory. Along Comes Composer With Composer, package sources are no longer copied to a single global location. They are used from their installed location and are not moved around. This means that with Composer there is no \"single main directory\" for PHP sources as with PEAR. Instead, there are multiple directories; each package is in a separate directory for each project. To meet the requirements of PSR-0, this leads to Composer packages looking like this: vendor/ vendor_name/ package_name/ src/ Vendor_Name/ Package_Name/ ClassName.php # Vendor_Name\\Package_Name\\ClassName tests/ Vendor_Name/ Package_Name/ ClassNameTest.php # Vendor_Name\\Package_Name\\ClassNameTest The \"src\" and \"tests\" directories have to include vendor and package directory names. This is an artifact of PSR-0 compliance. Many find this structure to be deeper and more repetitive than necessary. This proposal suggests that an additional or superseding PSR would be useful so that we can have packages that look more like the following: vendor/ vendor_name/ package_name/ src/ ClassName.php # Vendor_Name\\Package_Name\\ClassName tests/ ClassNameTest.php # Vendor_Name\\Package_Name\\ClassNameTest This would require an implementation of what was initially called \"package-oriented autoloading\" (as vs the traditional \"direct class-to-file autoloading\"). Package-Oriented Autoloading It's difficult to implement package-oriented autoloading via an extension or amendment to PSR-0, because PSR-0 does not allow for an intercessory path between any portions of the class name. This means the implementation of a package-oriented autoloader would be more complicated than PSR-0. However, it would allow for cleaner packages. Initially, the following rules were suggested: Implementors MUST use at least two namespace levels: a vendor name, and package name within that vendor. (This top-level two-name combination is hereinafter referred to as the vendor-package name or the vendor-package namespace.) Implementors MUST allow a path infix between the vendor-package namespace and the remainder of the fully qualified class name. The vendor-package namespace MAY map to any directory. The remaining portion of the fully-qualified class name MUST map the namespace names to identically-named directories, and MUST map the class name to an identically-named file ending in .php. Note that this means the end of underscore-as-directory-separator in the class name. One might think underscores should be honored as they are under PSR-0, but seeing as their presence in that document is in reference to transitioning away from PHP 5.2 and previous pseudo-namespacing, it is acceptable to remove them here as well. 3. Scope 3.1 Goals Retain the PSR-0 rule that implementors MUST use at least two namespace levels: a vendor name, and package name within that vendor. Allow a path infix between the vendor-package namespace and the remainder of the fully qualified class name. Allow the vendor-package namespace MAY map to any directory, perhaps multiple directories. End the honoring of underscores in class names as directory separators 3.2 Non-Goals Provide a general transformation algorithm for non-class resources 4. Approaches 4.1 Chosen Approach This approach retains key characteristics of PSR-0 while eliminating the deeper directory structures it requires. In addition, it specifies certain additional rules that make implementations explicitly more interoperable. Although not related to directory mapping, the final draft also specifies how autoloaders should handle errors. Specifically, it forbids throwing exceptions or raising errors. The reason is two-fold. Autoloaders in PHP are explicitly designed to be stackable so that if one autoloader cannot load a class another has a chance to do so. Having an autoloader trigger a breaking error condition violates that compatibility. class_exists() and interface_exists() allow \"not found, even after trying to autoload\" as a legitimate, normal use case. An autoloader that throws exceptions renders class_exists() unusable, which is entirely unacceptable from an interoperability standpoint. Autoloaders that wish to provide additional debugging information in a class-not-found case should do so via logging instead, either to a PSR-3 compatible logger or otherwise. Pros: Shallower directory structures More flexible file locations Stops underscore in class name from being honored as directory separator Makes implementations more explicitly interoperable Cons: It is no longer possible, as under PSR-0, to merely examine a class name to determine where it is in the file system (the \"class-to-file\" convention inherited from Horde/PEAR). 4.2 Alternative: Stay With PSR-0 Only Staying with PSR-0 only, although reasonable, does leave us with relatively deeper directory structures. Pros: No need to change anyone's habits or implementations Cons: Leaves us with deeper directory structures Leaves us with underscores in the class name being honored as directory separators 4.3 Alternative: Split Up Autoloading And Transformation Beau Simensen and others suggested that the transformation algorithm might be split out from the autoloading proposal so that the transformation rules could be referenced by other proposals. After doing the work to separate them, followed by a poll and some discussion, the combined version (i.e., transformation rules embedded in the autoloader proposal) was revealed as the preference. Pros: Transformation rules could be referenced separately by other proposals Cons: Not in line with the wishes of poll respondents and some collaborators 4.4 Alternative: Use More Imperative And Narrative Language After the second vote was pulled by a Sponsor after hearing from multiple +1 voters that they supported the idea but did not agree with (or understand) the wording of the proposal, there was a period during which the voted-on proposal was expanded with greater narrative and somewhat more imperative language. This approach was decried by a vocal minority of participants. After some time, Beau Simensen started an experimental revision with an eye to PSR-0; the Editor and Sponsors favored this more terse approach and shepherded the version now under consideration, written by Paul M. Jones and contributed to by many. Compatibility Note with PHP 5.3.2 and below PHP versions before 5.3.3 do not strip the leading namespace separator, so the responsibility to look out for this falls on the implementation. Failing to strip the leading namespace separator could lead to unexpected behavior. 5. People 5.1 Editor Paul M. Jones, Solar/Aura 5.2 Sponsors Phil Sturgeon, PyroCMS (Coordinator) Larry Garfield, Drupal 5.3 Contributors Andreas Hennings Bernhard Schussek Beau Simensen Donald Gilbert Mike van Riel Paul Dragoonis Too many others to name and count 6. Votes Entrance Vote: https://groups.google.com/d/msg/php-fig/_LYBgfcEoFE/ZwFTvVTIl4AJ Acceptance Vote: 1st attempt: https://groups.google.com/forum/#!topic/php-fig/Ua46E344_Ls , presented prior to new workflow; aborted due to accidental proposal modification 2nd attempt: https://groups.google.com/forum/#!topic/php-fig/NWfyAeF7Psk , cancelled at the discretion of the sponsor https://groups.google.com/forum/#!topic/php-fig/t4mW2TQF7iE 3rd attempt: TBD 7. Relevant Links Autoloader, round 4 POLL: Autoloader: Split or Combined? PSR-X autoloader spec: Loopholes, ambiguities Autoloader: Combine Proposals? Package-Oriented Autoloader, Round 2 Autoloader: looking again at namespace DISCUSSION: Package-Oriented Autoloader - vote against VOTE: Package-Oriented Autoloader Proposal: Package-Oriented Autoloader Towards a Package Oriented Autoloader List of Alternative PSR-4 Proposals Summary of [post-Acceptance Vote pull] PSR-4 discussions","title":"PSR-4 Meta Document"},{"location":"accepted/PSR-4-autoloader-meta/#psr-4-meta-document","text":"","title":"PSR-4 Meta Document"},{"location":"accepted/PSR-4-autoloader-meta/#1-summary","text":"The purpose is to specify the rules for an interoperable PHP autoloader that maps namespaces to file system paths, and that can co-exist with any other SPL registered autoloader. This would be an addition to, not a replacement for, PSR-0.","title":"1. Summary"},{"location":"accepted/PSR-4-autoloader-meta/#2-why-bother","text":"","title":"2. Why Bother?"},{"location":"accepted/PSR-4-autoloader-meta/#history-of-psr-0","text":"The PSR-0 class naming and autoloading standard rose out of the broad acceptance of the Horde/PEAR convention under the constraints of PHP 5.2 and previous. With that convention, the tendency was to put all PHP source classes in a single main directory, using underscores in the class name to indicate pseudo-namespaces, like so: /path/to/src/ VendorFoo/ Bar/ Baz.php # VendorFoo_Bar_Baz VendorDib/ Zim/ Gir.php # Vendor_Dib_Zim_Gir With the release of PHP 5.3 and the availability of namespaces proper, PSR-0 was introduced to allow both the old Horde/PEAR underscore mode and the use of the new namespace notation. Underscores were still allowed in the class name to ease the transition from the older namespace naming to the newer naming, and thereby to encourage wider adoption. /path/to/src/ VendorFoo/ Bar/ Baz.php # VendorFoo_Bar_Baz VendorDib/ Zim/ Gir.php # VendorDib_Zim_Gir Irk_Operation/ Impending_Doom/ V1.php V2.php # Irk_Operation\\Impending_Doom\\V2 This structure is informed very much by the fact that the PEAR installer moved source files from PEAR packages into a single central directory.","title":"History of PSR-0"},{"location":"accepted/PSR-4-autoloader-meta/#along-comes-composer","text":"With Composer, package sources are no longer copied to a single global location. They are used from their installed location and are not moved around. This means that with Composer there is no \"single main directory\" for PHP sources as with PEAR. Instead, there are multiple directories; each package is in a separate directory for each project. To meet the requirements of PSR-0, this leads to Composer packages looking like this: vendor/ vendor_name/ package_name/ src/ Vendor_Name/ Package_Name/ ClassName.php # Vendor_Name\\Package_Name\\ClassName tests/ Vendor_Name/ Package_Name/ ClassNameTest.php # Vendor_Name\\Package_Name\\ClassNameTest The \"src\" and \"tests\" directories have to include vendor and package directory names. This is an artifact of PSR-0 compliance. Many find this structure to be deeper and more repetitive than necessary. This proposal suggests that an additional or superseding PSR would be useful so that we can have packages that look more like the following: vendor/ vendor_name/ package_name/ src/ ClassName.php # Vendor_Name\\Package_Name\\ClassName tests/ ClassNameTest.php # Vendor_Name\\Package_Name\\ClassNameTest This would require an implementation of what was initially called \"package-oriented autoloading\" (as vs the traditional \"direct class-to-file autoloading\").","title":"Along Comes Composer"},{"location":"accepted/PSR-4-autoloader-meta/#package-oriented-autoloading","text":"It's difficult to implement package-oriented autoloading via an extension or amendment to PSR-0, because PSR-0 does not allow for an intercessory path between any portions of the class name. This means the implementation of a package-oriented autoloader would be more complicated than PSR-0. However, it would allow for cleaner packages. Initially, the following rules were suggested: Implementors MUST use at least two namespace levels: a vendor name, and package name within that vendor. (This top-level two-name combination is hereinafter referred to as the vendor-package name or the vendor-package namespace.) Implementors MUST allow a path infix between the vendor-package namespace and the remainder of the fully qualified class name. The vendor-package namespace MAY map to any directory. The remaining portion of the fully-qualified class name MUST map the namespace names to identically-named directories, and MUST map the class name to an identically-named file ending in .php. Note that this means the end of underscore-as-directory-separator in the class name. One might think underscores should be honored as they are under PSR-0, but seeing as their presence in that document is in reference to transitioning away from PHP 5.2 and previous pseudo-namespacing, it is acceptable to remove them here as well.","title":"Package-Oriented Autoloading"},{"location":"accepted/PSR-4-autoloader-meta/#3-scope","text":"","title":"3. Scope"},{"location":"accepted/PSR-4-autoloader-meta/#31-goals","text":"Retain the PSR-0 rule that implementors MUST use at least two namespace levels: a vendor name, and package name within that vendor. Allow a path infix between the vendor-package namespace and the remainder of the fully qualified class name. Allow the vendor-package namespace MAY map to any directory, perhaps multiple directories. End the honoring of underscores in class names as directory separators","title":"3.1 Goals"},{"location":"accepted/PSR-4-autoloader-meta/#32-non-goals","text":"Provide a general transformation algorithm for non-class resources","title":"3.2 Non-Goals"},{"location":"accepted/PSR-4-autoloader-meta/#4-approaches","text":"","title":"4. Approaches"},{"location":"accepted/PSR-4-autoloader-meta/#41-chosen-approach","text":"This approach retains key characteristics of PSR-0 while eliminating the deeper directory structures it requires. In addition, it specifies certain additional rules that make implementations explicitly more interoperable. Although not related to directory mapping, the final draft also specifies how autoloaders should handle errors. Specifically, it forbids throwing exceptions or raising errors. The reason is two-fold. Autoloaders in PHP are explicitly designed to be stackable so that if one autoloader cannot load a class another has a chance to do so. Having an autoloader trigger a breaking error condition violates that compatibility. class_exists() and interface_exists() allow \"not found, even after trying to autoload\" as a legitimate, normal use case. An autoloader that throws exceptions renders class_exists() unusable, which is entirely unacceptable from an interoperability standpoint. Autoloaders that wish to provide additional debugging information in a class-not-found case should do so via logging instead, either to a PSR-3 compatible logger or otherwise. Pros: Shallower directory structures More flexible file locations Stops underscore in class name from being honored as directory separator Makes implementations more explicitly interoperable Cons: It is no longer possible, as under PSR-0, to merely examine a class name to determine where it is in the file system (the \"class-to-file\" convention inherited from Horde/PEAR).","title":"4.1 Chosen Approach"},{"location":"accepted/PSR-4-autoloader-meta/#42-alternative-stay-with-psr-0-only","text":"Staying with PSR-0 only, although reasonable, does leave us with relatively deeper directory structures. Pros: No need to change anyone's habits or implementations Cons: Leaves us with deeper directory structures Leaves us with underscores in the class name being honored as directory separators","title":"4.2 Alternative: Stay With PSR-0 Only"},{"location":"accepted/PSR-4-autoloader-meta/#43-alternative-split-up-autoloading-and-transformation","text":"Beau Simensen and others suggested that the transformation algorithm might be split out from the autoloading proposal so that the transformation rules could be referenced by other proposals. After doing the work to separate them, followed by a poll and some discussion, the combined version (i.e., transformation rules embedded in the autoloader proposal) was revealed as the preference. Pros: Transformation rules could be referenced separately by other proposals Cons: Not in line with the wishes of poll respondents and some collaborators","title":"4.3 Alternative: Split Up Autoloading And Transformation"},{"location":"accepted/PSR-4-autoloader-meta/#44-alternative-use-more-imperative-and-narrative-language","text":"After the second vote was pulled by a Sponsor after hearing from multiple +1 voters that they supported the idea but did not agree with (or understand) the wording of the proposal, there was a period during which the voted-on proposal was expanded with greater narrative and somewhat more imperative language. This approach was decried by a vocal minority of participants. After some time, Beau Simensen started an experimental revision with an eye to PSR-0; the Editor and Sponsors favored this more terse approach and shepherded the version now under consideration, written by Paul M. Jones and contributed to by many.","title":"4.4 Alternative: Use More Imperative And Narrative Language"},{"location":"accepted/PSR-4-autoloader-meta/#compatibility-note-with-php-532-and-below","text":"PHP versions before 5.3.3 do not strip the leading namespace separator, so the responsibility to look out for this falls on the implementation. Failing to strip the leading namespace separator could lead to unexpected behavior.","title":"Compatibility Note with PHP 5.3.2 and below"},{"location":"accepted/PSR-4-autoloader-meta/#5-people","text":"","title":"5. People"},{"location":"accepted/PSR-4-autoloader-meta/#51-editor","text":"Paul M. Jones, Solar/Aura","title":"5.1 Editor"},{"location":"accepted/PSR-4-autoloader-meta/#52-sponsors","text":"Phil Sturgeon, PyroCMS (Coordinator) Larry Garfield, Drupal","title":"5.2 Sponsors"},{"location":"accepted/PSR-4-autoloader-meta/#53-contributors","text":"Andreas Hennings Bernhard Schussek Beau Simensen Donald Gilbert Mike van Riel Paul Dragoonis Too many others to name and count","title":"5.3 Contributors"},{"location":"accepted/PSR-4-autoloader-meta/#6-votes","text":"Entrance Vote: https://groups.google.com/d/msg/php-fig/_LYBgfcEoFE/ZwFTvVTIl4AJ Acceptance Vote: 1st attempt: https://groups.google.com/forum/#!topic/php-fig/Ua46E344_Ls , presented prior to new workflow; aborted due to accidental proposal modification 2nd attempt: https://groups.google.com/forum/#!topic/php-fig/NWfyAeF7Psk , cancelled at the discretion of the sponsor https://groups.google.com/forum/#!topic/php-fig/t4mW2TQF7iE 3rd attempt: TBD","title":"6. Votes"},{"location":"accepted/PSR-4-autoloader-meta/#7-relevant-links","text":"Autoloader, round 4 POLL: Autoloader: Split or Combined? PSR-X autoloader spec: Loopholes, ambiguities Autoloader: Combine Proposals? Package-Oriented Autoloader, Round 2 Autoloader: looking again at namespace DISCUSSION: Package-Oriented Autoloader - vote against VOTE: Package-Oriented Autoloader Proposal: Package-Oriented Autoloader Towards a Package Oriented Autoloader List of Alternative PSR-4 Proposals Summary of [post-Acceptance Vote pull] PSR-4 discussions","title":"7. Relevant Links"},{"location":"accepted/PSR-4-autoloader/","text":"Autoloader The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . 1. Overview This PSR describes a specification for autoloading classes from file paths. It is fully interoperable, and can be used in addition to any other autoloading specification, including PSR-0 . This PSR also describes where to place files that will be autoloaded according to the specification. 2. Specification The term \"class\" refers to classes, interfaces, traits, and other similar structures. A fully qualified class name has the following form: \\<NamespaceName>(\\<SubNamespaceNames>)*\\<ClassName> The fully qualified class name MUST have a top-level namespace name, also known as a \"vendor namespace\". The fully qualified class name MAY have one or more sub-namespace names. The fully qualified class name MUST have a terminating class name. Underscores have no special meaning in any portion of the fully qualified class name. Alphabetic characters in the fully qualified class name MAY be any combination of lower case and upper case. All class names MUST be referenced in a case-sensitive fashion. When loading a file that corresponds to a fully qualified class name ... A contiguous series of one or more leading namespace and sub-namespace names, not including the leading namespace separator, in the fully qualified class name (a \"namespace prefix\") corresponds to at least one \"base directory\". The contiguous sub-namespace names after the \"namespace prefix\" correspond to a subdirectory within a \"base directory\", in which the namespace separators represent directory separators. The subdirectory name MUST match the case of the sub-namespace names. The terminating class name corresponds to a file name ending in .php . The file name MUST match the case of the terminating class name. Autoloader implementations MUST NOT throw exceptions, MUST NOT raise errors of any level, and SHOULD NOT return a value. 3. Examples The table below shows the corresponding file path for a given fully qualified class name, namespace prefix, and base directory. Fully Qualified Class Name Namespace Prefix Base Directory Resulting File Path \\Acme\\Log\\Writer\\File_Writer Acme\\Log\\Writer ./acme-log-writer/lib/ ./acme-log-writer/lib/File_Writer.php \\Aura\\Web\\Response\\Status Aura\\Web /path/to/aura-web/src/ /path/to/aura-web/src/Response/Status.php \\Symfony\\Core\\Request Symfony\\Core ./vendor/Symfony/Core/ ./vendor/Symfony/Core/Request.php \\Zend\\Acl Zend /usr/includes/Zend/ /usr/includes/Zend/Acl.php For example implementations of autoloaders conforming to the specification, please see the examples file . Example implementations MUST NOT be regarded as part of the specification and MAY change at any time.","title":"Autoloader"},{"location":"accepted/PSR-4-autoloader/#autoloader","text":"The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"Autoloader"},{"location":"accepted/PSR-4-autoloader/#1-overview","text":"This PSR describes a specification for autoloading classes from file paths. It is fully interoperable, and can be used in addition to any other autoloading specification, including PSR-0 . This PSR also describes where to place files that will be autoloaded according to the specification.","title":"1. Overview"},{"location":"accepted/PSR-4-autoloader/#2-specification","text":"The term \"class\" refers to classes, interfaces, traits, and other similar structures. A fully qualified class name has the following form: \\<NamespaceName>(\\<SubNamespaceNames>)*\\<ClassName> The fully qualified class name MUST have a top-level namespace name, also known as a \"vendor namespace\". The fully qualified class name MAY have one or more sub-namespace names. The fully qualified class name MUST have a terminating class name. Underscores have no special meaning in any portion of the fully qualified class name. Alphabetic characters in the fully qualified class name MAY be any combination of lower case and upper case. All class names MUST be referenced in a case-sensitive fashion. When loading a file that corresponds to a fully qualified class name ... A contiguous series of one or more leading namespace and sub-namespace names, not including the leading namespace separator, in the fully qualified class name (a \"namespace prefix\") corresponds to at least one \"base directory\". The contiguous sub-namespace names after the \"namespace prefix\" correspond to a subdirectory within a \"base directory\", in which the namespace separators represent directory separators. The subdirectory name MUST match the case of the sub-namespace names. The terminating class name corresponds to a file name ending in .php . The file name MUST match the case of the terminating class name. Autoloader implementations MUST NOT throw exceptions, MUST NOT raise errors of any level, and SHOULD NOT return a value.","title":"2. Specification"},{"location":"accepted/PSR-4-autoloader/#3-examples","text":"The table below shows the corresponding file path for a given fully qualified class name, namespace prefix, and base directory. Fully Qualified Class Name Namespace Prefix Base Directory Resulting File Path \\Acme\\Log\\Writer\\File_Writer Acme\\Log\\Writer ./acme-log-writer/lib/ ./acme-log-writer/lib/File_Writer.php \\Aura\\Web\\Response\\Status Aura\\Web /path/to/aura-web/src/ /path/to/aura-web/src/Response/Status.php \\Symfony\\Core\\Request Symfony\\Core ./vendor/Symfony/Core/ ./vendor/Symfony/Core/Request.php \\Zend\\Acl Zend /usr/includes/Zend/ /usr/includes/Zend/Acl.php For example implementations of autoloaders conforming to the specification, please see the examples file . Example implementations MUST NOT be regarded as part of the specification and MAY change at any time.","title":"3. Examples"},{"location":"accepted/PSR-6-cache-meta/","text":"PSR-Cache Meta Document 1. Summary Caching is a common way to improve the performance of any project, making caching libraries one of the most common features of many frameworks and libraries. This has lead to a situation where many libraries roll their own caching libraries, with various levels of functionality. These differences are causing developers to have to learn multiple systems which may or may not provide the functionality they need. In addition, the developers of caching libraries themselves face a choice between only supporting a limited number of frameworks or creating a large number of adapter classes. 2. Why Bother? A common interface for caching systems will solve these problems. Library and framework developers can count on the caching systems working the way they're expecting, while the developers of caching systems will only have to implement a single set of interfaces rather than a whole assortment of adapters. Moreover, the implementation presented here is designed for future extensibility. It allows a variety of internally-different but API-compatible implementations and offers a clear path for future extension by later PSRs or by specific implementers. Pros: * A standard interface for caching allows free-standing libraries to support caching of intermediary data without effort; they may simply (optionally) depend on this standard interface and leverage it without being concerned about implementation details. * Commonly developed caching libraries shared by multiple projects, even if they extend this interface, are likely to be more robust than a dozen separately developed implementations. Cons: * Any interface standardization runs the risk of stifling future innovation as being \"not the Way It's Done(tm)\". However, we believe caching is a sufficiently commoditized problem space that the extension capability offered here mitigates any potential risk of stagnation. 3. Scope 3.1 Goals A common interface for basic and intermediate-level caching needs. A clear mechanism for extending the specification to support advanced features, both by future PSRs or by individual implementations. This mechanism must allow for multiple independent extensions without collision. 3.2 Non-Goals Architectural compatibility with all existing cache implementations. Advanced caching features such as namespacing or tagging that are used by a minority of users. 4. Approaches 4.1 Chosen Approach This specification adopts a \"repository model\" or \"data mapper\" model for caching rather than the more traditional \"expire-able key-value\" model. The primary reason is flexibility. A simple key/value model is much more difficult to extend. The model here mandates the use of a CacheItem object, which represents a cache entry, and a Pool object, which is a given store of cached data. Items are retrieved from the pool, interacted with, and returned to it. While a bit more verbose at times it offers a good, robust, flexible approach to caching, especially in cases where caching is more involved than simply saving and retrieving a string. Most method names were chosen based on common practice and method names in a survey of member projects and other popular non-member systems. Pros: Flexible and extensible Allows a great deal of variation in implementation without violating the interface Does not implicitly expose object constructors as a pseudo-interface. Cons: A bit more verbose than the naive approach Examples: Some common usage patterns are shown below. These are non-normative but should demonstrate the application of some design decisions. /** * Gets a list of available widgets. * * In this case, we assume the widget list changes so rarely that we want * the list cached forever until an explicit clear. */ function get_widget_list() { $pool = get_cache_pool('widgets'); $item = $pool->getItem('widget_list'); if (!$item->isHit()) { $value = compute_expensive_widget_list(); $item->set($value); $pool->save($item); } return $item->get(); } /** * Caches a list of available widgets. * * In this case, we assume a list of widgets has been computed and we want * to cache it, regardless of what may already be cached. */ function save_widget_list($list) { $pool = get_cache_pool('widgets'); $item = $pool->getItem('widget_list'); $item->set($list); $pool->save($item); } /** * Clears the list of available widgets. * * In this case, we simply want to remove the widget list from the cache. We * don't care if it was set or not; the post condition is simply \"no longer set\". */ function clear_widget_list() { $pool = get_cache_pool('widgets'); $pool->deleteItems(['widget_list']); } /** * Clears all widget information. * * In this case, we want to empty the entire widget pool. There may be other * pools in the application that will be unaffected. */ function clear_widget_cache() { $pool = get_cache_pool('widgets'); $pool->clear(); } /** * Load widgets. * * We want to get back a list of widgets, of which some are cached and some * are not. This of course assumes that loading from the cache is faster than * whatever the non-cached loading mechanism is. * * In this case, we assume widgets may change frequently so we only allow them * to be cached for an hour (3600 seconds). We also cache newly-loaded objects * back to the pool en masse. * * Note that a real implementation would probably also want a multi-load * operation for widgets, but that's irrelevant for this demonstration. */ function load_widgets(array $ids) { $pool = get_cache_pool('widgets'); $keys = array_map(function($id) { return 'widget.' . $id; }, $ids); $items = $pool->getItems($keys); $widgets = array(); foreach ($items as $key => $item) { if ($item->isHit()) { $value = $item->get(); } else { $value = expensive_widget_load($id); $item->set($value); $item->expiresAfter(3600); $pool->saveDeferred($item, true); } $widget[$value->id()] = $value; } $pool->commit(); // If no items were deferred this is a no-op. return $widgets; } /** * This examples reflects functionality that is NOT included in this * specification, but is shown as an example of how such functionality MIGHT * be added by extending implementations. */ interface TaggablePoolInterface extends Psr\\Cache\\CachePoolInterface { /** * Clears only those items from the pool that have the specified tag. */ clearByTag($tag); } interface TaggableItemInterface extends Psr\\Cache\\CacheItemInterface { public function setTags(array $tags); } /** * Caches a widget with tags. */ function set_widget(TaggablePoolInterface $pool, Widget $widget) { $key = 'widget.' . $widget->id(); $item = $pool->getItem($key); $item->setTags($widget->tags()); $item->set($widget); $pool->save($item); } 4.2 Alternative: \"Weak item\" approach A variety of earlier drafts took a simpler \"key value with expiration\" approach, also known as a \"weak item\" approach. In this model, the \"Cache Item\" object was really just a dumb array-with-methods object. Users would instantiate it directly, then pass it to a cache pool. While more familiar, that approach effectively prevented any meaningful extension of the Cache Item. It effectively made the Cache Item's constructor part of the implicit interface, and thus severely curtailed extensibility or the ability to have the cache item be where the intelligence lives. In a poll conducted in June 2013, most participants showed a clear preference for the more robust if less conventional \"Strong item\" / repository approach, which was adopted as the way forward. Pros: * More traditional approach. Cons: * Less extensible or flexible. 4.3 Alternative: \"Naked value\" approach Some of the earliest discussions of the Cache spec suggested skipping the Cache Item concept all together and just reading/writing raw values to be cached. While simpler, it was pointed out that made it impossible to tell the difference between a cache miss and whatever raw value was selected to represent a cache miss. That is, if a cache lookup returned NULL it's impossible to tell if there was no cached value or if NULL was the value that had been cached. (NULL is a legitimate value to cache in many cases.) Most more robust caching implementations we reviewed -- in particular the Stash caching library and the home-grown cache system used by Drupal -- use some sort of structured object on get at least to avoid confusion between a miss and a sentinel value. Based on that prior experience FIG decided that a naked value on get was impossible. 4.4 Alternative: ArrayAccess Pool There was a suggestion to make a Pool implement ArrayAccess, which would allow for cache get/set operations to use array syntax. That was rejected due to limited interest, limited flexibility of that approach (trivial get and set with default control information is all that's possible), and because it's trivial for a particular implementation to include as an add-on should it desire to do so. 5. People 5.1 Editor Larry Garfield 5.2 Sponsors Paul Dragoonis, PPI Framework (Coordinator) Robert Hafner, Stash 6. Votes Acceptance vote on the mailing list 7. Relevant Links Note: Order descending chronologically. Survey of existing cache implementations , by @dragoonis Strong vs. Weak informal poll , by @Crell Implementation details informal poll , by @Crell 8. Errata 8.1 Handling of incorrect DateTime values in expiresAt() The CacheItemInterface::expiresAt() method's $expiration parameter is untyped in the interface, but in the docblock is specified as \\DateTimeInterface . The intent is that either a \\DateTime or \\DateTimeImmutable object is allowed. However, \\DateTimeInterface and \\DateTimeImmutable were added in PHP 5.5, and the authors chose not to impose a hard syntactic requirement for PHP 5.5 on the specification. Despite that, implementers MUST accept only \\DateTimeInterface or compatible types (such as \\DateTime and \\DateTimeImmutable ) as if the method was explicitly typed. (Note that the variance rules for a typed parameter may vary between language versions.) Simulating a failed type check unfortunately varies between PHP versions and thus is not recommended. Instead, implementors SHOULD throw an instance of \\Psr\\Cache\\InvalidArgumentException . The following sample code is recommended in order to enforce the type check on the expiresAt() method: class ExpiresAtInvalidParameterException implements Psr\\Cache\\InvalidArgumentException {} // ... if (! ( null === $expiration || $expiration instanceof \\DateTime || $expiration instanceof \\DateTimeInterface )) { throw new ExpiresAtInvalidParameterException(sprintf( 'Argument 1 passed to %s::expiresAt() must be an instance of DateTime or DateTimeImmutable; %s given', get_class($this), is_object($expiration) ? get_class($expiration) : gettype($expiration) )); } 8.2 Type additions The 2.0 release of the psr/cache package includes scalar parameter types. The 3.0 release of the package includes return types. This structure leverages PHP 7.2 covariance support to allow for a gradual upgrade process, but requires PHP 8.0 for type compatibility. The 2.0 version also corrects the Errata 8.1 above by providing a correct type hint for the CacheItemInterface::expiresAt() method's $expiration parameter. That results in a slight change in the error thrown on invalid input; as it is still a fatal disallowed case, FIG has deemed it an acceptably small BC break in order to leverage correct native typing. Implementers MAY add return types to their own packages at their discretion, provided that: the return types match those in the 3.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later. Implementers MAY add parameter types to their own packages in a new major release, either at the same time as adding return types or in a subsequent release, provided that: the parameter types match those in the 2.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later. the implementation depends on \"psr/link\": \"^1.1 || ^2.0\" so as to exclude the untyped 1.0 version. Implementers are encouraged but not required to transition their packages toward the 3.0 version of the package at their earliest convenience.","title":"PSR-Cache Meta Document"},{"location":"accepted/PSR-6-cache-meta/#psr-cache-meta-document","text":"","title":"PSR-Cache Meta Document"},{"location":"accepted/PSR-6-cache-meta/#1-summary","text":"Caching is a common way to improve the performance of any project, making caching libraries one of the most common features of many frameworks and libraries. This has lead to a situation where many libraries roll their own caching libraries, with various levels of functionality. These differences are causing developers to have to learn multiple systems which may or may not provide the functionality they need. In addition, the developers of caching libraries themselves face a choice between only supporting a limited number of frameworks or creating a large number of adapter classes.","title":"1. Summary"},{"location":"accepted/PSR-6-cache-meta/#2-why-bother","text":"A common interface for caching systems will solve these problems. Library and framework developers can count on the caching systems working the way they're expecting, while the developers of caching systems will only have to implement a single set of interfaces rather than a whole assortment of adapters. Moreover, the implementation presented here is designed for future extensibility. It allows a variety of internally-different but API-compatible implementations and offers a clear path for future extension by later PSRs or by specific implementers. Pros: * A standard interface for caching allows free-standing libraries to support caching of intermediary data without effort; they may simply (optionally) depend on this standard interface and leverage it without being concerned about implementation details. * Commonly developed caching libraries shared by multiple projects, even if they extend this interface, are likely to be more robust than a dozen separately developed implementations. Cons: * Any interface standardization runs the risk of stifling future innovation as being \"not the Way It's Done(tm)\". However, we believe caching is a sufficiently commoditized problem space that the extension capability offered here mitigates any potential risk of stagnation.","title":"2. Why Bother?"},{"location":"accepted/PSR-6-cache-meta/#3-scope","text":"","title":"3. Scope"},{"location":"accepted/PSR-6-cache-meta/#31-goals","text":"A common interface for basic and intermediate-level caching needs. A clear mechanism for extending the specification to support advanced features, both by future PSRs or by individual implementations. This mechanism must allow for multiple independent extensions without collision.","title":"3.1 Goals"},{"location":"accepted/PSR-6-cache-meta/#32-non-goals","text":"Architectural compatibility with all existing cache implementations. Advanced caching features such as namespacing or tagging that are used by a minority of users.","title":"3.2 Non-Goals"},{"location":"accepted/PSR-6-cache-meta/#4-approaches","text":"","title":"4. Approaches"},{"location":"accepted/PSR-6-cache-meta/#41-chosen-approach","text":"This specification adopts a \"repository model\" or \"data mapper\" model for caching rather than the more traditional \"expire-able key-value\" model. The primary reason is flexibility. A simple key/value model is much more difficult to extend. The model here mandates the use of a CacheItem object, which represents a cache entry, and a Pool object, which is a given store of cached data. Items are retrieved from the pool, interacted with, and returned to it. While a bit more verbose at times it offers a good, robust, flexible approach to caching, especially in cases where caching is more involved than simply saving and retrieving a string. Most method names were chosen based on common practice and method names in a survey of member projects and other popular non-member systems. Pros: Flexible and extensible Allows a great deal of variation in implementation without violating the interface Does not implicitly expose object constructors as a pseudo-interface. Cons: A bit more verbose than the naive approach Examples: Some common usage patterns are shown below. These are non-normative but should demonstrate the application of some design decisions. /** * Gets a list of available widgets. * * In this case, we assume the widget list changes so rarely that we want * the list cached forever until an explicit clear. */ function get_widget_list() { $pool = get_cache_pool('widgets'); $item = $pool->getItem('widget_list'); if (!$item->isHit()) { $value = compute_expensive_widget_list(); $item->set($value); $pool->save($item); } return $item->get(); } /** * Caches a list of available widgets. * * In this case, we assume a list of widgets has been computed and we want * to cache it, regardless of what may already be cached. */ function save_widget_list($list) { $pool = get_cache_pool('widgets'); $item = $pool->getItem('widget_list'); $item->set($list); $pool->save($item); } /** * Clears the list of available widgets. * * In this case, we simply want to remove the widget list from the cache. We * don't care if it was set or not; the post condition is simply \"no longer set\". */ function clear_widget_list() { $pool = get_cache_pool('widgets'); $pool->deleteItems(['widget_list']); } /** * Clears all widget information. * * In this case, we want to empty the entire widget pool. There may be other * pools in the application that will be unaffected. */ function clear_widget_cache() { $pool = get_cache_pool('widgets'); $pool->clear(); } /** * Load widgets. * * We want to get back a list of widgets, of which some are cached and some * are not. This of course assumes that loading from the cache is faster than * whatever the non-cached loading mechanism is. * * In this case, we assume widgets may change frequently so we only allow them * to be cached for an hour (3600 seconds). We also cache newly-loaded objects * back to the pool en masse. * * Note that a real implementation would probably also want a multi-load * operation for widgets, but that's irrelevant for this demonstration. */ function load_widgets(array $ids) { $pool = get_cache_pool('widgets'); $keys = array_map(function($id) { return 'widget.' . $id; }, $ids); $items = $pool->getItems($keys); $widgets = array(); foreach ($items as $key => $item) { if ($item->isHit()) { $value = $item->get(); } else { $value = expensive_widget_load($id); $item->set($value); $item->expiresAfter(3600); $pool->saveDeferred($item, true); } $widget[$value->id()] = $value; } $pool->commit(); // If no items were deferred this is a no-op. return $widgets; } /** * This examples reflects functionality that is NOT included in this * specification, but is shown as an example of how such functionality MIGHT * be added by extending implementations. */ interface TaggablePoolInterface extends Psr\\Cache\\CachePoolInterface { /** * Clears only those items from the pool that have the specified tag. */ clearByTag($tag); } interface TaggableItemInterface extends Psr\\Cache\\CacheItemInterface { public function setTags(array $tags); } /** * Caches a widget with tags. */ function set_widget(TaggablePoolInterface $pool, Widget $widget) { $key = 'widget.' . $widget->id(); $item = $pool->getItem($key); $item->setTags($widget->tags()); $item->set($widget); $pool->save($item); }","title":"4.1 Chosen Approach"},{"location":"accepted/PSR-6-cache-meta/#42-alternative-weak-item-approach","text":"A variety of earlier drafts took a simpler \"key value with expiration\" approach, also known as a \"weak item\" approach. In this model, the \"Cache Item\" object was really just a dumb array-with-methods object. Users would instantiate it directly, then pass it to a cache pool. While more familiar, that approach effectively prevented any meaningful extension of the Cache Item. It effectively made the Cache Item's constructor part of the implicit interface, and thus severely curtailed extensibility or the ability to have the cache item be where the intelligence lives. In a poll conducted in June 2013, most participants showed a clear preference for the more robust if less conventional \"Strong item\" / repository approach, which was adopted as the way forward. Pros: * More traditional approach. Cons: * Less extensible or flexible.","title":"4.2 Alternative: \"Weak item\" approach"},{"location":"accepted/PSR-6-cache-meta/#43-alternative-naked-value-approach","text":"Some of the earliest discussions of the Cache spec suggested skipping the Cache Item concept all together and just reading/writing raw values to be cached. While simpler, it was pointed out that made it impossible to tell the difference between a cache miss and whatever raw value was selected to represent a cache miss. That is, if a cache lookup returned NULL it's impossible to tell if there was no cached value or if NULL was the value that had been cached. (NULL is a legitimate value to cache in many cases.) Most more robust caching implementations we reviewed -- in particular the Stash caching library and the home-grown cache system used by Drupal -- use some sort of structured object on get at least to avoid confusion between a miss and a sentinel value. Based on that prior experience FIG decided that a naked value on get was impossible.","title":"4.3 Alternative: \"Naked value\" approach"},{"location":"accepted/PSR-6-cache-meta/#44-alternative-arrayaccess-pool","text":"There was a suggestion to make a Pool implement ArrayAccess, which would allow for cache get/set operations to use array syntax. That was rejected due to limited interest, limited flexibility of that approach (trivial get and set with default control information is all that's possible), and because it's trivial for a particular implementation to include as an add-on should it desire to do so.","title":"4.4 Alternative: ArrayAccess Pool"},{"location":"accepted/PSR-6-cache-meta/#5-people","text":"","title":"5. People"},{"location":"accepted/PSR-6-cache-meta/#51-editor","text":"Larry Garfield","title":"5.1 Editor"},{"location":"accepted/PSR-6-cache-meta/#52-sponsors","text":"Paul Dragoonis, PPI Framework (Coordinator) Robert Hafner, Stash","title":"5.2 Sponsors"},{"location":"accepted/PSR-6-cache-meta/#6-votes","text":"Acceptance vote on the mailing list","title":"6. Votes"},{"location":"accepted/PSR-6-cache-meta/#7-relevant-links","text":"Note: Order descending chronologically. Survey of existing cache implementations , by @dragoonis Strong vs. Weak informal poll , by @Crell Implementation details informal poll , by @Crell","title":"7. Relevant Links"},{"location":"accepted/PSR-6-cache-meta/#8-errata","text":"","title":"8. Errata"},{"location":"accepted/PSR-6-cache-meta/#81-handling-of-incorrect-datetime-values-in-expiresat","text":"The CacheItemInterface::expiresAt() method's $expiration parameter is untyped in the interface, but in the docblock is specified as \\DateTimeInterface . The intent is that either a \\DateTime or \\DateTimeImmutable object is allowed. However, \\DateTimeInterface and \\DateTimeImmutable were added in PHP 5.5, and the authors chose not to impose a hard syntactic requirement for PHP 5.5 on the specification. Despite that, implementers MUST accept only \\DateTimeInterface or compatible types (such as \\DateTime and \\DateTimeImmutable ) as if the method was explicitly typed. (Note that the variance rules for a typed parameter may vary between language versions.) Simulating a failed type check unfortunately varies between PHP versions and thus is not recommended. Instead, implementors SHOULD throw an instance of \\Psr\\Cache\\InvalidArgumentException . The following sample code is recommended in order to enforce the type check on the expiresAt() method: class ExpiresAtInvalidParameterException implements Psr\\Cache\\InvalidArgumentException {} // ... if (! ( null === $expiration || $expiration instanceof \\DateTime || $expiration instanceof \\DateTimeInterface )) { throw new ExpiresAtInvalidParameterException(sprintf( 'Argument 1 passed to %s::expiresAt() must be an instance of DateTime or DateTimeImmutable; %s given', get_class($this), is_object($expiration) ? get_class($expiration) : gettype($expiration) )); }","title":"8.1 Handling of incorrect DateTime values in expiresAt()"},{"location":"accepted/PSR-6-cache-meta/#82-type-additions","text":"The 2.0 release of the psr/cache package includes scalar parameter types. The 3.0 release of the package includes return types. This structure leverages PHP 7.2 covariance support to allow for a gradual upgrade process, but requires PHP 8.0 for type compatibility. The 2.0 version also corrects the Errata 8.1 above by providing a correct type hint for the CacheItemInterface::expiresAt() method's $expiration parameter. That results in a slight change in the error thrown on invalid input; as it is still a fatal disallowed case, FIG has deemed it an acceptably small BC break in order to leverage correct native typing. Implementers MAY add return types to their own packages at their discretion, provided that: the return types match those in the 3.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later. Implementers MAY add parameter types to their own packages in a new major release, either at the same time as adding return types or in a subsequent release, provided that: the parameter types match those in the 2.0 package. the implementation specifies a minimum PHP version of 8.0.0 or later. the implementation depends on \"psr/link\": \"^1.1 || ^2.0\" so as to exclude the untyped 1.0 version. Implementers are encouraged but not required to transition their packages toward the 3.0 version of the package at their earliest convenience.","title":"8.2 Type additions"},{"location":"accepted/PSR-6-cache/","text":"Caching Interface Caching is a common way to improve the performance of any project, making caching libraries one of the most common features of many frameworks and libraries. This has lead to a situation where many libraries roll their own caching libraries, with various levels of functionality. These differences are causing developers to have to learn multiple systems which may or may not provide the functionality they need. In addition, the developers of caching libraries themselves face a choice between only supporting a limited number of frameworks or creating a large number of adapter classes. A common interface for caching systems will solve these problems. Library and framework developers can count on the caching systems working the way they're expecting, while the developers of caching systems will only have to implement a single set of interfaces rather than a whole assortment of adapters. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . Goal The goal of this PSR is to allow developers to create cache-aware libraries that can be integrated into existing frameworks and systems without the need for custom development. Definitions Calling Library - The library or code that actually needs the cache services. This library will utilize caching services that implement this standard's interfaces, but will otherwise have no knowledge of the implementation of those caching services. Implementing Library - This library is responsible for implementing this standard in order to provide caching services to any Calling Library. The Implementing Library MUST provide classes which implement the Cache\\CacheItemPoolInterface and Cache\\CacheItemInterface interfaces. Implementing Libraries MUST support at minimum TTL functionality as described below with whole-second granularity. TTL - The Time To Live (TTL) of an item is the amount of time between when that item is stored and it is considered stale. The TTL is normally defined by an integer representing time in seconds, or a DateInterval object. Expiration - The actual time when an item is set to go stale. This is typically calculated by adding the TTL to the time when an object is stored, but may also be explicitly set with DateTime object. An item with a 300 second TTL stored at 1:30:00 will have an expiration of 1:35:00. Implementing Libraries MAY expire an item before its requested Expiration Time, but MUST treat an item as expired once its Expiration Time is reached. If a calling library asks for an item to be saved but does not specify an expiration time, or specifies a null expiration time or TTL, an Implementing Library MAY use a configured default duration. If no default duration has been set, the Implementing Library MUST interpret that as a request to cache the item forever, or for as long as the underlying implementation supports. Key - A string of at least one character that uniquely identifies a cached item. Implementing libraries MUST support keys consisting of the characters A-Z , a-z , 0-9 , _ , and . in any order in UTF-8 encoding and a length of up to 64 characters. Implementing libraries MAY support additional characters and encodings or longer lengths, but must support at least that minimum. Libraries are responsible for their own escaping of key strings as appropriate, but MUST be able to return the original unmodified key string. The following characters are reserved for future extensions and MUST NOT be supported by implementing libraries: {}()/\\@: Hit - A cache hit occurs when a Calling Library requests an Item by key and a matching value is found for that key, and that value has not expired, and the value is not invalid for some other reason. Calling Libraries SHOULD make sure to verify isHit() on all get() calls. Miss - A cache miss is the opposite of a cache hit. A cache miss occurs when a Calling Library requests an item by key and that value not found for that key, or the value was found but has expired, or the value is invalid for some other reason. An expired value MUST always be considered a cache miss. Deferred - A deferred cache save indicates that a cache item may not be persisted immediately by the pool. A Pool object MAY delay persisting a deferred cache item in order to take advantage of bulk-set operations supported by some storage engines. A Pool MUST ensure that any deferred cache items are eventually persisted and data is not lost, and MAY persist them before a Calling Library requests that they be persisted. When a Calling Library invokes the commit() method all outstanding deferred items MUST be persisted. An Implementing Library MAY use whatever logic is appropriate to determine when to persist deferred items, such as an object destructor, persisting all on save(), a timeout or max-items check or any other appropriate logic. Requests for a cache item that has been deferred MUST return the deferred but not-yet-persisted item. Data Implementing libraries MUST support all serializable PHP data types, including: Strings - Character strings of arbitrary size in any PHP-compatible encoding. Integers - All integers of any size supported by PHP, up to 64-bit signed. Floats - All signed floating point values. Boolean - True and False. Null - The actual null value. Arrays - Indexed, associative and multidimensional arrays of arbitrary depth. Object - Any object that supports lossless serialization and deserialization such that $o == unserialize(serialize($o)) . Objects MAY leverage PHP's Serializable interface, __sleep() or __wakeup() magic methods, or similar language functionality if appropriate. All data passed into the Implementing Library MUST be returned exactly as passed. That includes the variable type. That is, it is an error to return (string) 5 if (int) 5 was the value saved. Implementing Libraries MAY use PHP's serialize() / unserialize() functions internally but are not required to do so. Compatibility with them is simply used as a baseline for acceptable object values. If it is not possible to return the exact saved value for any reason, implementing libraries MUST respond with a cache miss rather than corrupted data. Key Concepts Pool The Pool represents a collection of items in a caching system. The pool is a logical Repository of all items it contains. All cacheable items are retrieved from the Pool as an Item object, and all interaction with the whole universe of cached objects happens through the Pool. Items An Item represents a single key/value pair within a Pool. The key is the primary unique identifier for an Item and MUST be immutable. The Value MAY be changed at any time. Error handling While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. For that reason, Implementing Libraries MUST NOT throw exceptions other than those defined by the interface, and SHOULD trap any errors or exceptions triggered by an underlying data store and not allow them to bubble. An Implementing Library SHOULD log such errors or otherwise report them to an administrator as appropriate. If a Calling Library requests that one or more Items be deleted, or that a pool be cleared, it MUST NOT be considered an error condition if the specified key does not exist. The post-condition is the same (the key does not exist, or the pool is empty), thus there is no error condition. Interfaces CacheItemInterface CacheItemInterface defines an item inside a cache system. Each Item object MUST be associated with a specific key, which can be set according to the implementing system and is typically passed by the Cache\\CacheItemPoolInterface object. The Cache\\CacheItemInterface object encapsulates the storage and retrieval of cache items. Each Cache\\CacheItemInterface is generated by a Cache\\CacheItemPoolInterface object, which is responsible for any required setup as well as associating the object with a unique Key. Cache\\CacheItemInterface objects MUST be able to store and retrieve any type of PHP value defined in the Data section of this document. Calling Libraries MUST NOT instantiate Item objects themselves. They may only be requested from a Pool object via the getItem() method. Calling Libraries SHOULD NOT assume that an Item created by one Implementing Library is compatible with a Pool from another Implementing Library. <?php namespace Psr\\Cache; /** * CacheItemInterface defines an interface for interacting with objects inside a cache. */ interface CacheItemInterface { /** * Returns the key for the current cache item. * * The key is loaded by the Implementing Library, but should be available to * the higher level callers when needed. * * @return string * The key string for this cache item. */ public function getKey(); /** * Retrieves the value of the item from the cache associated with this object's key. * * The value returned must be identical to the value originally stored by set(). * * If isHit() returns false, this method MUST return null. Note that null * is a legitimate cached value, so the isHit() method SHOULD be used to * differentiate between \"null value was found\" and \"no value was found.\" * * @return mixed * The value corresponding to this cache item's key, or null if not found. */ public function get(); /** * Confirms if the cache item lookup resulted in a cache hit. * * Note: This method MUST NOT have a race condition between calling isHit() * and calling get(). * * @return bool * True if the request resulted in a cache hit. False otherwise. */ public function isHit(); /** * Sets the value represented by this cache item. * * The $value argument may be any item that can be serialized by PHP, * although the method of serialization is left up to the Implementing * Library. * * @param mixed $value * The serializable value to be stored. * * @return static * The invoked object. */ public function set($value); /** * Sets the expiration time for this cache item. * * @param \\DateTimeInterface|null $expiration * The point in time after which the item MUST be considered expired. * If null is passed explicitly, a default value MAY be used. If none is set, * the value should be stored permanently or for as long as the * implementation allows. * * @return static * The called object. */ public function expiresAt($expiration); /** * Sets the expiration time for this cache item. * * @param int|\\DateInterval|null $time * The period of time from the present after which the item MUST be considered * expired. An integer parameter is understood to be the time in seconds until * expiration. If null is passed explicitly, a default value MAY be used. * If none is set, the value should be stored permanently or for as long as the * implementation allows. * * @return static * The called object. */ public function expiresAfter($time); } CacheItemPoolInterface The primary purpose of Cache\\CacheItemPoolInterface is to accept a key from the Calling Library and return the associated Cache\\CacheItemInterface object. It is also the primary point of interaction with the entire cache collection. All configuration and initialization of the Pool is left up to an Implementing Library. <?php namespace Psr\\Cache; /** * CacheItemPoolInterface generates CacheItemInterface objects. */ interface CacheItemPoolInterface { /** * Returns a Cache Item representing the specified key. * * This method must always return a CacheItemInterface object, even in case of * a cache miss. It MUST NOT return null. * * @param string $key * The key for which to return the corresponding Cache Item. * * @throws InvalidArgumentException * If the $key string is not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return CacheItemInterface * The corresponding Cache Item. */ public function getItem($key); /** * Returns a traversable set of cache items. * * @param string[] $keys * An indexed array of keys of items to retrieve. * * @throws InvalidArgumentException * If any of the keys in $keys are not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return array|\\Traversable * A traversable collection of Cache Items keyed by the cache keys of * each item. A Cache item will be returned for each key, even if that * key is not found. However, if no keys are specified then an empty * traversable MUST be returned instead. */ public function getItems(array $keys = array()); /** * Confirms if the cache contains specified cache item. * * Note: This method MAY avoid retrieving the cached value for performance reasons. * This could result in a race condition with CacheItemInterface::get(). To avoid * such situation use CacheItemInterface::isHit() instead. * * @param string $key * The key for which to check existence. * * @throws InvalidArgumentException * If the $key string is not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return bool * True if item exists in the cache, false otherwise. */ public function hasItem($key); /** * Deletes all items in the pool. * * @return bool * True if the pool was successfully cleared. False if there was an error. */ public function clear(); /** * Removes the item from the pool. * * @param string $key * The key to delete. * * @throws InvalidArgumentException * If the $key string is not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return bool * True if the item was successfully removed. False if there was an error. */ public function deleteItem($key); /** * Removes multiple items from the pool. * * @param string[] $keys * An array of keys that should be removed from the pool. * * @throws InvalidArgumentException * If any of the keys in $keys are not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return bool * True if the items were successfully removed. False if there was an error. */ public function deleteItems(array $keys); /** * Persists a cache item immediately. * * @param CacheItemInterface $item * The cache item to save. * * @return bool * True if the item was successfully persisted. False if there was an error. */ public function save(CacheItemInterface $item); /** * Sets a cache item to be persisted later. * * @param CacheItemInterface $item * The cache item to save. * * @return bool * False if the item could not be queued or if a commit was attempted and failed. True otherwise. */ public function saveDeferred(CacheItemInterface $item); /** * Persists any deferred cache items. * * @return bool * True if all not-yet-saved items were successfully saved or there were none. False otherwise. */ public function commit(); } CacheException This exception interface is intended for use when critical errors occur, including but not limited to cache setup such as connecting to a cache server or invalid credentials supplied. Any exception thrown by an Implementing Library MUST implement this interface. <?php namespace Psr\\Cache; /** * Exception interface for all exceptions thrown by an Implementing Library. */ interface CacheException { } InvalidArgumentException <?php namespace Psr\\Cache; /** * Exception interface for invalid cache arguments. * * Any time an invalid argument is passed into a method it must throw an * exception class which implements Psr\\Cache\\InvalidArgumentException. */ interface InvalidArgumentException extends CacheException { } Since psr/cache version 2.0 , the above interfaces have been updated to add argument type hints. Since psr/cache version 3.0 , the above interfaces have been updated to add return type hints. References to array|\\Traversable have been replaced with iterable .","title":"Caching Interface"},{"location":"accepted/PSR-6-cache/#caching-interface","text":"Caching is a common way to improve the performance of any project, making caching libraries one of the most common features of many frameworks and libraries. This has lead to a situation where many libraries roll their own caching libraries, with various levels of functionality. These differences are causing developers to have to learn multiple systems which may or may not provide the functionality they need. In addition, the developers of caching libraries themselves face a choice between only supporting a limited number of frameworks or creating a large number of adapter classes. A common interface for caching systems will solve these problems. Library and framework developers can count on the caching systems working the way they're expecting, while the developers of caching systems will only have to implement a single set of interfaces rather than a whole assortment of adapters. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"Caching Interface"},{"location":"accepted/PSR-6-cache/#goal","text":"The goal of this PSR is to allow developers to create cache-aware libraries that can be integrated into existing frameworks and systems without the need for custom development.","title":"Goal"},{"location":"accepted/PSR-6-cache/#definitions","text":"Calling Library - The library or code that actually needs the cache services. This library will utilize caching services that implement this standard's interfaces, but will otherwise have no knowledge of the implementation of those caching services. Implementing Library - This library is responsible for implementing this standard in order to provide caching services to any Calling Library. The Implementing Library MUST provide classes which implement the Cache\\CacheItemPoolInterface and Cache\\CacheItemInterface interfaces. Implementing Libraries MUST support at minimum TTL functionality as described below with whole-second granularity. TTL - The Time To Live (TTL) of an item is the amount of time between when that item is stored and it is considered stale. The TTL is normally defined by an integer representing time in seconds, or a DateInterval object. Expiration - The actual time when an item is set to go stale. This is typically calculated by adding the TTL to the time when an object is stored, but may also be explicitly set with DateTime object. An item with a 300 second TTL stored at 1:30:00 will have an expiration of 1:35:00. Implementing Libraries MAY expire an item before its requested Expiration Time, but MUST treat an item as expired once its Expiration Time is reached. If a calling library asks for an item to be saved but does not specify an expiration time, or specifies a null expiration time or TTL, an Implementing Library MAY use a configured default duration. If no default duration has been set, the Implementing Library MUST interpret that as a request to cache the item forever, or for as long as the underlying implementation supports. Key - A string of at least one character that uniquely identifies a cached item. Implementing libraries MUST support keys consisting of the characters A-Z , a-z , 0-9 , _ , and . in any order in UTF-8 encoding and a length of up to 64 characters. Implementing libraries MAY support additional characters and encodings or longer lengths, but must support at least that minimum. Libraries are responsible for their own escaping of key strings as appropriate, but MUST be able to return the original unmodified key string. The following characters are reserved for future extensions and MUST NOT be supported by implementing libraries: {}()/\\@: Hit - A cache hit occurs when a Calling Library requests an Item by key and a matching value is found for that key, and that value has not expired, and the value is not invalid for some other reason. Calling Libraries SHOULD make sure to verify isHit() on all get() calls. Miss - A cache miss is the opposite of a cache hit. A cache miss occurs when a Calling Library requests an item by key and that value not found for that key, or the value was found but has expired, or the value is invalid for some other reason. An expired value MUST always be considered a cache miss. Deferred - A deferred cache save indicates that a cache item may not be persisted immediately by the pool. A Pool object MAY delay persisting a deferred cache item in order to take advantage of bulk-set operations supported by some storage engines. A Pool MUST ensure that any deferred cache items are eventually persisted and data is not lost, and MAY persist them before a Calling Library requests that they be persisted. When a Calling Library invokes the commit() method all outstanding deferred items MUST be persisted. An Implementing Library MAY use whatever logic is appropriate to determine when to persist deferred items, such as an object destructor, persisting all on save(), a timeout or max-items check or any other appropriate logic. Requests for a cache item that has been deferred MUST return the deferred but not-yet-persisted item.","title":"Definitions"},{"location":"accepted/PSR-6-cache/#data","text":"Implementing libraries MUST support all serializable PHP data types, including: Strings - Character strings of arbitrary size in any PHP-compatible encoding. Integers - All integers of any size supported by PHP, up to 64-bit signed. Floats - All signed floating point values. Boolean - True and False. Null - The actual null value. Arrays - Indexed, associative and multidimensional arrays of arbitrary depth. Object - Any object that supports lossless serialization and deserialization such that $o == unserialize(serialize($o)) . Objects MAY leverage PHP's Serializable interface, __sleep() or __wakeup() magic methods, or similar language functionality if appropriate. All data passed into the Implementing Library MUST be returned exactly as passed. That includes the variable type. That is, it is an error to return (string) 5 if (int) 5 was the value saved. Implementing Libraries MAY use PHP's serialize() / unserialize() functions internally but are not required to do so. Compatibility with them is simply used as a baseline for acceptable object values. If it is not possible to return the exact saved value for any reason, implementing libraries MUST respond with a cache miss rather than corrupted data.","title":"Data"},{"location":"accepted/PSR-6-cache/#key-concepts","text":"","title":"Key Concepts"},{"location":"accepted/PSR-6-cache/#pool","text":"The Pool represents a collection of items in a caching system. The pool is a logical Repository of all items it contains. All cacheable items are retrieved from the Pool as an Item object, and all interaction with the whole universe of cached objects happens through the Pool.","title":"Pool"},{"location":"accepted/PSR-6-cache/#items","text":"An Item represents a single key/value pair within a Pool. The key is the primary unique identifier for an Item and MUST be immutable. The Value MAY be changed at any time.","title":"Items"},{"location":"accepted/PSR-6-cache/#error-handling","text":"While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. For that reason, Implementing Libraries MUST NOT throw exceptions other than those defined by the interface, and SHOULD trap any errors or exceptions triggered by an underlying data store and not allow them to bubble. An Implementing Library SHOULD log such errors or otherwise report them to an administrator as appropriate. If a Calling Library requests that one or more Items be deleted, or that a pool be cleared, it MUST NOT be considered an error condition if the specified key does not exist. The post-condition is the same (the key does not exist, or the pool is empty), thus there is no error condition.","title":"Error handling"},{"location":"accepted/PSR-6-cache/#interfaces","text":"","title":"Interfaces"},{"location":"accepted/PSR-6-cache/#cacheiteminterface","text":"CacheItemInterface defines an item inside a cache system. Each Item object MUST be associated with a specific key, which can be set according to the implementing system and is typically passed by the Cache\\CacheItemPoolInterface object. The Cache\\CacheItemInterface object encapsulates the storage and retrieval of cache items. Each Cache\\CacheItemInterface is generated by a Cache\\CacheItemPoolInterface object, which is responsible for any required setup as well as associating the object with a unique Key. Cache\\CacheItemInterface objects MUST be able to store and retrieve any type of PHP value defined in the Data section of this document. Calling Libraries MUST NOT instantiate Item objects themselves. They may only be requested from a Pool object via the getItem() method. Calling Libraries SHOULD NOT assume that an Item created by one Implementing Library is compatible with a Pool from another Implementing Library. <?php namespace Psr\\Cache; /** * CacheItemInterface defines an interface for interacting with objects inside a cache. */ interface CacheItemInterface { /** * Returns the key for the current cache item. * * The key is loaded by the Implementing Library, but should be available to * the higher level callers when needed. * * @return string * The key string for this cache item. */ public function getKey(); /** * Retrieves the value of the item from the cache associated with this object's key. * * The value returned must be identical to the value originally stored by set(). * * If isHit() returns false, this method MUST return null. Note that null * is a legitimate cached value, so the isHit() method SHOULD be used to * differentiate between \"null value was found\" and \"no value was found.\" * * @return mixed * The value corresponding to this cache item's key, or null if not found. */ public function get(); /** * Confirms if the cache item lookup resulted in a cache hit. * * Note: This method MUST NOT have a race condition between calling isHit() * and calling get(). * * @return bool * True if the request resulted in a cache hit. False otherwise. */ public function isHit(); /** * Sets the value represented by this cache item. * * The $value argument may be any item that can be serialized by PHP, * although the method of serialization is left up to the Implementing * Library. * * @param mixed $value * The serializable value to be stored. * * @return static * The invoked object. */ public function set($value); /** * Sets the expiration time for this cache item. * * @param \\DateTimeInterface|null $expiration * The point in time after which the item MUST be considered expired. * If null is passed explicitly, a default value MAY be used. If none is set, * the value should be stored permanently or for as long as the * implementation allows. * * @return static * The called object. */ public function expiresAt($expiration); /** * Sets the expiration time for this cache item. * * @param int|\\DateInterval|null $time * The period of time from the present after which the item MUST be considered * expired. An integer parameter is understood to be the time in seconds until * expiration. If null is passed explicitly, a default value MAY be used. * If none is set, the value should be stored permanently or for as long as the * implementation allows. * * @return static * The called object. */ public function expiresAfter($time); }","title":"CacheItemInterface"},{"location":"accepted/PSR-6-cache/#cacheitempoolinterface","text":"The primary purpose of Cache\\CacheItemPoolInterface is to accept a key from the Calling Library and return the associated Cache\\CacheItemInterface object. It is also the primary point of interaction with the entire cache collection. All configuration and initialization of the Pool is left up to an Implementing Library. <?php namespace Psr\\Cache; /** * CacheItemPoolInterface generates CacheItemInterface objects. */ interface CacheItemPoolInterface { /** * Returns a Cache Item representing the specified key. * * This method must always return a CacheItemInterface object, even in case of * a cache miss. It MUST NOT return null. * * @param string $key * The key for which to return the corresponding Cache Item. * * @throws InvalidArgumentException * If the $key string is not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return CacheItemInterface * The corresponding Cache Item. */ public function getItem($key); /** * Returns a traversable set of cache items. * * @param string[] $keys * An indexed array of keys of items to retrieve. * * @throws InvalidArgumentException * If any of the keys in $keys are not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return array|\\Traversable * A traversable collection of Cache Items keyed by the cache keys of * each item. A Cache item will be returned for each key, even if that * key is not found. However, if no keys are specified then an empty * traversable MUST be returned instead. */ public function getItems(array $keys = array()); /** * Confirms if the cache contains specified cache item. * * Note: This method MAY avoid retrieving the cached value for performance reasons. * This could result in a race condition with CacheItemInterface::get(). To avoid * such situation use CacheItemInterface::isHit() instead. * * @param string $key * The key for which to check existence. * * @throws InvalidArgumentException * If the $key string is not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return bool * True if item exists in the cache, false otherwise. */ public function hasItem($key); /** * Deletes all items in the pool. * * @return bool * True if the pool was successfully cleared. False if there was an error. */ public function clear(); /** * Removes the item from the pool. * * @param string $key * The key to delete. * * @throws InvalidArgumentException * If the $key string is not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return bool * True if the item was successfully removed. False if there was an error. */ public function deleteItem($key); /** * Removes multiple items from the pool. * * @param string[] $keys * An array of keys that should be removed from the pool. * * @throws InvalidArgumentException * If any of the keys in $keys are not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return bool * True if the items were successfully removed. False if there was an error. */ public function deleteItems(array $keys); /** * Persists a cache item immediately. * * @param CacheItemInterface $item * The cache item to save. * * @return bool * True if the item was successfully persisted. False if there was an error. */ public function save(CacheItemInterface $item); /** * Sets a cache item to be persisted later. * * @param CacheItemInterface $item * The cache item to save. * * @return bool * False if the item could not be queued or if a commit was attempted and failed. True otherwise. */ public function saveDeferred(CacheItemInterface $item); /** * Persists any deferred cache items. * * @return bool * True if all not-yet-saved items were successfully saved or there were none. False otherwise. */ public function commit(); }","title":"CacheItemPoolInterface"},{"location":"accepted/PSR-6-cache/#cacheexception","text":"This exception interface is intended for use when critical errors occur, including but not limited to cache setup such as connecting to a cache server or invalid credentials supplied. Any exception thrown by an Implementing Library MUST implement this interface. <?php namespace Psr\\Cache; /** * Exception interface for all exceptions thrown by an Implementing Library. */ interface CacheException { }","title":"CacheException"},{"location":"accepted/PSR-6-cache/#invalidargumentexception","text":"<?php namespace Psr\\Cache; /** * Exception interface for invalid cache arguments. * * Any time an invalid argument is passed into a method it must throw an * exception class which implements Psr\\Cache\\InvalidArgumentException. */ interface InvalidArgumentException extends CacheException { } Since psr/cache version 2.0 , the above interfaces have been updated to add argument type hints. Since psr/cache version 3.0 , the above interfaces have been updated to add return type hints. References to array|\\Traversable have been replaced with iterable .","title":"InvalidArgumentException"},{"location":"accepted/PSR-7-http-message-meta/","text":"HTTP Message Meta Document 1. Summary The purpose of this proposal is to provide a set of common interfaces for HTTP messages as described in RFC 7230 and RFC 7231 , and URIs as described in RFC 3986 (in the context of HTTP messages). RFC 7230: http://www.ietf.org/rfc/rfc7230.txt RFC 7231: http://www.ietf.org/rfc/rfc7231.txt RFC 3986: http://www.ietf.org/rfc/rfc3986.txt All HTTP messages consist of the HTTP protocol version being used, headers, and a message body. A Request builds on the message to include the HTTP method used to make the request, and the URI to which the request is made. A Response includes the HTTP status code and reason phrase. In PHP, HTTP messages are used in two contexts: To send an HTTP request, via the ext/curl extension, PHP's native stream layer, etc., and process the received HTTP response. In other words, HTTP messages are used when using PHP as an HTTP client . To process an incoming HTTP request to the server, and return an HTTP response to the client making the request. PHP can use HTTP messages when used as a server-side application to fulfill HTTP requests. This proposal presents an API for fully describing all parts of the various HTTP messages within PHP. 2. HTTP Messages in PHP PHP does not have built-in support for HTTP messages. Client-side HTTP support PHP supports sending HTTP requests via several mechanisms: PHP streams The cURL extension ext/http (v2 also attempts to address server-side support) PHP streams are the most convenient and ubiquitous way to send HTTP requests, but pose a number of limitations with regards to properly configuring SSL support, and provide a cumbersome interface around setting things such as headers. cURL provides a complete and expanded feature-set, but, as it is not a default extension, is often not present. The http extension suffers from the same problem as cURL, as well as the fact that it has traditionally had far fewer examples of usage. Most modern HTTP client libraries tend to abstract the implementation, to ensure they can work on whatever environment they are executed on, and across any of the above layers. Server-side HTTP Support PHP uses Server APIs (SAPI) to interpret incoming HTTP requests, marshal input, and pass off handling to scripts. The original SAPI design mirrored Common Gateway Interface , which would marshal request data and push it into environment variables before passing delegation to a script; the script would then pull from the environment variables in order to process the request and return a response. PHP's SAPI design abstracts common input sources such as cookies, query string arguments, and url-encoded POST content via superglobals ( $_COOKIE , $_GET , and $_POST , respectively), providing a layer of convenience for web developers. On the response side of the equation, PHP was originally developed as a templating language, and allows intermixing HTML and PHP; any HTML portions of a file are immediately flushed to the output buffer. Modern applications and frameworks eschew this practice, as it can lead to issues with regards to emitting a status line and/or response headers; they tend to aggregate all headers and content, and emit them at once when all other application processing is complete. Special care needs to be paid to ensure that error reporting and other actions that send content to the output buffer do not flush the output buffer. 3. Why Bother? HTTP messages are used in a wide number of PHP projects -- both clients and servers. In each case, we observe one or more of the following patterns or situations: Projects use PHP's superglobals directly. Projects will create implementations from scratch. Projects may require a specific HTTP client/server library that provides HTTP message implementations. Projects may create adapters for common HTTP message implementations. As examples: Just about any application that began development before the rise of frameworks, which includes a number of very popular CMS, forum, and shopping cart systems, have historically used superglobals. Frameworks such as Symfony and Zend Framework each define HTTP components that form the basis of their MVC layers; even small, single-purpose libraries such as oauth2-server-php provide and require their own HTTP request/response implementations. Guzzle, Buzz, and other HTTP client implementations each create their own HTTP message implementations as well. Projects such as Silex, Stack, and Drupal 8 have hard dependencies on Symfony's HTTP kernel. Any SDK built on Guzzle has a hard requirement on Guzzle's HTTP message implementations. Projects such as Geocoder create redundant adapters for common libraries . Direct usage of superglobals has a number of concerns. First, these are mutable, which makes it possible for libraries and code to alter the values, and thus alter state for the application. Additionally, superglobals make unit and integration testing difficult and brittle, leading to code quality degradation. In the current ecosystem of frameworks that implement HTTP message abstractions, the net result is that projects are not capable of interoperability or cross-pollination. In order to consume code targeting one framework from another, the first order of business is building a bridge layer between the HTTP message implementations. On the client-side, if a particular library does not have an adapter you can utilize, you need to bridge the request/response pairs if you wish to use an adapter from another library. Finally, when it comes to server-side responses, PHP gets in its own way: any content emitted before a call to header() will result in that call becoming a no-op; depending on error reporting settings, this can often mean headers and/or response status are not correctly sent. One way to work around this is to use PHP's output buffering features, but nesting of output buffers can become problematic and difficult to debug. Frameworks and applications thus tend to create response abstractions for aggregating headers and content that can be emitted at once - and these abstractions are often incompatible. Thus, the goal of this proposal is to abstract both client- and server-side request and response interfaces in order to promote interoperability between projects. If projects implement these interfaces, a reasonable level of compatibility may be assumed when adopting code from different libraries. It should be noted that the goal of this proposal is not to obsolete the current interfaces utilized by existing PHP libraries. This proposal is aimed at interoperability between PHP packages for the purpose of describing HTTP messages. 4. Scope 4.1 Goals Provide the interfaces needed for describing HTTP messages. Focus on practical applications and usability. Define the interfaces to model all elements of the HTTP message and URI specifications. Ensure that the API does not impose arbitrary limits on HTTP messages. For example, some HTTP message bodies can be too large to store in memory, so we must account for this. Provide useful abstractions both for handling incoming requests for server-side applications and for sending outgoing requests in HTTP clients. 4.2 Non-Goals This proposal does not expect all HTTP client libraries or server-side frameworks to change their interfaces to conform. It is strictly meant for interoperability. While everyone's perception of what is and is not an implementation detail varies, this proposal should not impose implementation details. As RFCs 7230, 7231, and 3986 do not force any particular implementation, there will be a certain amount of invention needed to describe HTTP message interfaces in PHP. 5. Design Decisions Message design The MessageInterface provides accessors for the elements common to all HTTP messages, whether they are for requests or responses. These elements include: HTTP protocol version (e.g., \"1.0\", \"1.1\") HTTP headers HTTP message body More specific interfaces are used to describe requests and responses, and more specifically the context of each (client- vs. server-side). These divisions are partly inspired by existing PHP usage, but also by other languages such as Ruby's Rack , Python's WSGI , Go's http package , Node's http module , etc. Why are there header methods on messages rather than in a header bag? The message itself is a container for the headers (as well as the other message properties). How these are represented internally is an implementation detail, but uniform access to headers is a responsibility of the message. Why are URIs represented as objects? URIs are values, with identity defined by the value, and thus should be modeled as value objects. Additionally, URIs contain a variety of segments which may be accessed many times in a given request -- and which would require parsing the URI in order to determine (e.g., via parse_url() ). Modeling URIs as value objects allows parsing once only, and simplifies access to individual segments. It also provides convenience in client applications by allowing users to create new instances of a base URI instance with only the segments that change (e.g., updating the path only). Why does the request interface have methods for dealing with the request-target AND compose a URI? RFC 7230 details the request line as containing a \"request-target\". Of the four forms of request-target, only one is a URI compliant with RFC 3986; the most common form used is origin-form, which represents the URI without the scheme or authority information. Moreover, since all forms are valid for purposes of requests, the proposal must accommodate each. RequestInterface thus has methods relating to the request-target. By default, it will use the composed URI to present an origin-form request-target, and, in the absence of a URI instance, return the string \"/\". Another method, withRequestTarget() , allows specifying an instance with a specific request-target, allowing users to create requests that use one of the other valid request-target forms. The URI is kept as a discrete member of the request for a variety of reasons. For both clients and servers, knowledge of the absolute URI is typically required. In the case of clients, the URI, and specifically the scheme and authority details, is needed in order to make the actual TCP connection. For server-side applications, the full URI is often required in order to validate the request or to route to an appropriate handler. Why value objects? The proposal models messages and URIs as value objects . Messages are values where the identity is the aggregate of all parts of the message; a change to any aspect of the message is essentially a new message. This is the very definition of a value object. The practice by which changes result in a new instance is termed immutability , and is a feature designed to ensure the integrity of a given value. The proposal also recognizes that most clients and server-side applications will need to be able to easily update message aspects, and, as such, provides interface methods that will create new message instances with the updates. These are generally prefixed with the verbiage with or without . Value objects provides several benefits when modeling HTTP messages: Changes in URI state cannot alter the request composing the URI instance. Changes in headers cannot alter the message composing them. In essence, modeling HTTP messages as value objects ensures the integrity of the message state, and prevents the need for bi-directional dependencies, which can often go out-of-sync or lead to debugging or performance issues. For HTTP clients, they allow consumers to build a base request with data such as the base URI and required headers, without needing to build a brand new request or reset request state for each message the client sends: $uri = new Uri('http://api.example.com'); $baseRequest = new Request($uri, null, [ 'Authorization' => 'Bearer ' . $token, 'Accept' => 'application/json', ]); $request = $baseRequest->withUri($uri->withPath('/user'))->withMethod('GET'); $response = $client->send($request); // get user id from $response $body = new StringStream(json_encode(['tasks' => [ 'Code', 'Coffee', ]])); $request = $baseRequest ->withUri($uri->withPath('/tasks/user/' . $userId)) ->withMethod('POST') ->withHeader('Content-Type', 'application/json') ->withBody($body); $response = $client->send($request) // No need to overwrite headers or body! $request = $baseRequest->withUri($uri->withPath('/tasks'))->withMethod('GET'); $response = $client->send($request); On the server-side, developers will need to: Deserialize the request message body. Decrypt HTTP cookies. Write to the response. These operations can be accomplished with value objects as well, with a number of benefits: The original request state can be stored for retrieval by any consumer. A default response state can be created with default headers and/or message body. Most popular PHP frameworks have fully mutable HTTP messages today. The main changes necessary in consuming true value objects are: Instead of calling setter methods or setting public properties, mutator methods will be called, and the result assigned. Developers must notify the application on a change in state. As an example, in Zend Framework 2, instead of the following: function (MvcEvent $e) { $response = $e->getResponse(); $response->setHeaderLine('x-foo', 'bar'); } one would now write: function (MvcEvent $e) { $response = $e->getResponse(); $e->setResponse( $response->withHeader('x-foo', 'bar') ); } The above combines assignment and notification in a single call. This practice has a side benefit of making explicit any changes to application state being made. New instances vs returning $this One observation made on the various with*() methods is that they can likely safely return $this; if the argument presented will not result in a change in the value. One rationale for doing so is performance (as this will not result in a cloning operation). The various interfaces have been written with verbiage indicating that immutability MUST be preserved, but only indicate that \"an instance\" must be returned containing the new state. Since instances that represent the same value are considered equal, returning $this is functionally equivalent, and thus allowed. Using streams instead of X MessageInterface uses a body value that must implement StreamInterface . This design decision was made so that developers can send and receive (and/or receive and send) HTTP messages that contain more data than can practically be stored in memory while still allowing the convenience of interacting with message bodies as a string. While PHP provides a stream abstraction by way of stream wrappers, stream resources can be cumbersome to work with: stream resources can only be cast to a string using stream_get_contents() or manually reading the remainder of a string. Adding custom behavior to a stream as it is consumed or populated requires registering a stream filter; however, stream filters can only be added to a stream after the filter is registered with PHP (i.e., there is no stream filter autoloading mechanism). The use of a well- defined stream interface allows for the potential of flexible stream decorators that can be added to a request or response pre-flight to enable things like encryption, compression, ensuring that the number of bytes downloaded reflects the number of bytes reported in the Content-Length of a response, etc. Decorating streams is a well-established pattern in the Java and Node communities that allows for very flexible streams. The majority of the StreamInterface API is based on Python's io module , which provides a practical and consumable API. Instead of implementing stream capabilities using something like a WritableStreamInterface and ReadableStreamInterface , the capabilities of a stream are provided by methods like isReadable() , isWritable() , etc. This approach is used by Python, C#, C++ , Ruby , Node , and likely others. What if I just want to return a file? In some cases, you may want to return a file from the filesystem. The typical way to do this in PHP is one of the following: readfile($filename); stream_copy_to_stream(fopen($filename, 'r'), fopen('php://output', 'w')); Note that the above omits sending appropriate Content-Type and Content-Length headers; the developer would need to emit these prior to calling the above code. The equivalent using HTTP messages would be to use a StreamInterface implementation that accepts a filename and/or stream resource, and to provide this to the response instance. A complete example, including setting appropriate headers: // where Stream is a concrete StreamInterface: $stream = new Stream($filename); $finfo = new finfo(FILEINFO_MIME); $response = $response ->withHeader('Content-Type', $finfo->file($filename)) ->withHeader('Content-Length', (string) filesize($filename)) ->withBody($stream); Emitting this response will send the file to the client. What if I want to directly emit output? Directly emitting output (e.g. via echo , printf , or writing to the php://output stream) is generally only advisable as a performance optimization or when emitting large data sets. If it needs to be done and you still wish to work in an HTTP message paradigm, one approach would be to use a callback-based StreamInterface implementation, per this example . Wrap any code emitting output directly in a callback, pass that to an appropriate StreamInterface implementation, and provide it to the message body: $output = new CallbackStream(function () use ($request) { printf(\"The requested URI was: %s<br>\\n\", $request->getUri()); return ''; }); return (new Response()) ->withHeader('Content-Type', 'text/html') ->withBody($output); What if I want to use an iterator for content? Ruby's Rack implementation uses an iterator-based approach for server-side response message bodies. This can be emulated using an HTTP message paradigm via an iterator-backed StreamInterface approach, as detailed in the psr7examples repository . Why are streams mutable? The StreamInterface API includes methods such as write() which can change the message content -- which directly contradicts having immutable messages. The problem that arises is due to the fact that the interface is intended to wrap a PHP stream or similar. A write operation therefore will proxy to writing to the stream. Even if we made StreamInterface immutable, once the stream has been updated, any instance that wraps that stream will also be updated -- making immutability impossible to enforce. Our recommendation is that implementations use read-only streams for server-side requests and client-side responses. Rationale for ServerRequestInterface The RequestInterface and ResponseInterface have essentially 1:1 correlations with the request and response messages described in RFC 7230 . They provide interfaces for implementing value objects that correspond to the specific HTTP message types they model. For server-side applications there are other considerations for incoming requests: Access to server parameters (potentially derived from the request, but also potentially the result of server configuration, and generally represented via the $_SERVER superglobal; these are part of the PHP Server API (SAPI)). Access to the query string arguments (usually encapsulated in PHP via the $_GET superglobal). Access to the parsed body (i.e., data deserialized from the incoming request body; in PHP, this is typically the result of POST requests using application/x-www-form-urlencoded content types, and encapsulated in the $_POST superglobal, but for non-POST, non-form-encoded data, could be an array or an object). Access to uploaded files (encapsulated in PHP via the $_FILES superglobal). Access to cookie values (encapsulated in PHP via the $_COOKIE superglobal). Access to attributes derived from the request (usually, but not limited to, those matched against the URL path). Uniform access to these parameters increases the viability of interoperability between frameworks and libraries, as they can now assume that if a request implements ServerRequestInterface , they can get at these values. It also solves problems within the PHP language itself: Until 5.6.0, php://input was read-once; as such, instantiating multiple request instances from multiple frameworks/libraries could lead to inconsistent state, as the first to access php://input would be the only one to receive the data. Unit testing against superglobals (e.g., $_GET , $_FILES , etc.) is difficult and typically brittle. Encapsulating them inside the ServerRequestInterface implementation eases testing considerations. Why \"parsed body\" in the ServerRequestInterface? Arguments were made to use the terminology \"BodyParams\", and require the value to be an array, with the following rationale: Consistency with other server-side parameter access. $_POST is an array, and the 80% use case would target that superglobal. A single type makes for a strong contract, simplifying usage. The main argument is that if the body parameters are an array, developers have predictable access to values: $foo = isset($request->getBodyParams()['foo']) ? $request->getBodyParams()['foo'] : null; The argument for using \"parsed body\" was made by examining the domain. A message body can contain literally anything. While traditional web applications use forms and submit data using POST, this is a use case that is quickly being challenged in current web development trends, which are often API-centric, and thus use alternate request methods (notably PUT and PATCH), as well as non-form-encoded content (generally JSON or XML) that can be coerced to arrays in many cases, but in many cases also cannot or should not . If forcing the property representing the parsed body to be only an array, developers then need a shared convention about where to put the results of parsing the body. These might include: A special key under the body parameters, such as __parsed__ . A specially named attribute, such as __body__ . The end result is that a developer now has to look in multiple locations: $data = $request->getBodyParams(); if (isset($data['__parsed__']) && is_object($data['__parsed__'])) { $data = $data['__parsed__']; } // or: $data = $request->getBodyParams(); if ($request->hasAttribute('__body__')) { $data = $request->getAttribute('__body__'); } The solution presented is to use the terminology \"ParsedBody\", which implies that the values are the results of parsing the message body. This also means that the return value will be ambiguous; however, because this is an attribute of the domain, this is also expected. As such, usage will become: $data = $request->getParsedBody(); if (! $data instanceof \\stdClass) { // raise an exception! } // otherwise, we have what we expected This approach removes the limitations of forcing an array, at the expense of ambiguity of return value. Considering that the other suggested solutions \u2014 pushing the parsed data into a special body parameter key or into an attribute \u2014 also suffer from ambiguity, the proposed solution is simpler as it does not require additions to the interface specification. Ultimately, the ambiguity enables the flexibility required when representing the results of parsing the body. Why is no functionality included for retrieving the \"base path\"? Many frameworks provide the ability to get the \"base path,\" usually considered the path up to and including the front controller. As an example, if the application is served at http://example.com/b2b/index.php , and the current URI used to request it is http://example.com/b2b/index.php/customer/register , the functionality to retrieve the base path would return /b2b/index.php . This value can then be used by routers to strip that path segment prior to attempting a match. This value is often also then used for URI generation within applications; parameters will be passed to the router, which will generate the path, and prefix it with the base path in order to return a fully-qualified URI. Other tools \u2014 typically view helpers, template filters, or template functions \u2014 are used to resolve a path relative to the base path in order to generate a URI for linking to resources such as static assets. On examination of several different implementations, we noticed the following: The logic for determining the base path varies widely between implementations. As an example, compare the logic in ZF2 to the logic in Symfony 2 . Most implementations appear to allow manual injection of a base path to the router and/or any facilities used for URI generation. The primary use cases \u2014 routing and URI generation \u2014 typically are the only consumers of the functionality; developers usually do not need to be aware of the base path concept as other objects take care of that detail for them. As examples: A router will strip off the base path for you during routing; you do not need to pass the modified path to the router. View helpers, template filters, etc. typically are injected with a base path prior to invocation. Sometimes this is manually done, though more often it is the result of framework wiring. All sources necessary for calculating the base path are already in the RequestInterface instance , via server parameters and the URI instance. Our stance is that base path detection is framework and/or application specific, and the results of detection can be easily injected into objects that need it, and/or calculated as needed using utility functions and/or classes from the RequestInterface instance itself. Why does getUploadedFiles() return objects instead of arrays? getUploadedFiles() returns a tree of Psr\\Http\\Message\\UploadedFileInterface instances. This is done primarily to simplify specification: instead of requiring paragraphs of implementation specification for an array, we specify an interface. Additionally, the data in an UploadedFileInterface is normalized to work in both SAPI and non-SAPI environments. This allows the creation of processes to parse the message body manually and assign contents to streams without first writing to the filesystem, while still allowing proper handling of file uploads in SAPI environments. What about \"special\" header values? A number of header values contain unique representation requirements which can pose problems both for consumption as well as generation; in particular, cookies and the Accept header. This proposal does not provide any special treatment of any header types. The base MessageInterface provides methods for header retrieval and setting, and all header values are, in the end, string values. Developers are encouraged to write commodity libraries for interacting with these header values, either for the purposes of parsing or generation. Users may then consume these libraries when needing to interact with those values. Examples of this practice already exist in libraries such as willdurand/Negotiation and Aura.Accept . So long as the object has functionality for casting the value to a string, these objects can be used to populate the headers of an HTTP message. 6. People 6.1 Editor(s) Matthew Weier O'Phinney 6.2 Sponsors Paul M. Jones Beau Simensen (coordinator) 6.3 Contributors Michael Dowling Larry Garfield Evert Pot Tobias Schultze Bernhard Schussek Anton Serdyuk Phil Sturgeon Chris Wilkinson","title":"HTTP Message Meta Document"},{"location":"accepted/PSR-7-http-message-meta/#http-message-meta-document","text":"","title":"HTTP Message Meta Document"},{"location":"accepted/PSR-7-http-message-meta/#1-summary","text":"The purpose of this proposal is to provide a set of common interfaces for HTTP messages as described in RFC 7230 and RFC 7231 , and URIs as described in RFC 3986 (in the context of HTTP messages). RFC 7230: http://www.ietf.org/rfc/rfc7230.txt RFC 7231: http://www.ietf.org/rfc/rfc7231.txt RFC 3986: http://www.ietf.org/rfc/rfc3986.txt All HTTP messages consist of the HTTP protocol version being used, headers, and a message body. A Request builds on the message to include the HTTP method used to make the request, and the URI to which the request is made. A Response includes the HTTP status code and reason phrase. In PHP, HTTP messages are used in two contexts: To send an HTTP request, via the ext/curl extension, PHP's native stream layer, etc., and process the received HTTP response. In other words, HTTP messages are used when using PHP as an HTTP client . To process an incoming HTTP request to the server, and return an HTTP response to the client making the request. PHP can use HTTP messages when used as a server-side application to fulfill HTTP requests. This proposal presents an API for fully describing all parts of the various HTTP messages within PHP.","title":"1. Summary"},{"location":"accepted/PSR-7-http-message-meta/#2-http-messages-in-php","text":"PHP does not have built-in support for HTTP messages.","title":"2. HTTP Messages in PHP"},{"location":"accepted/PSR-7-http-message-meta/#client-side-http-support","text":"PHP supports sending HTTP requests via several mechanisms: PHP streams The cURL extension ext/http (v2 also attempts to address server-side support) PHP streams are the most convenient and ubiquitous way to send HTTP requests, but pose a number of limitations with regards to properly configuring SSL support, and provide a cumbersome interface around setting things such as headers. cURL provides a complete and expanded feature-set, but, as it is not a default extension, is often not present. The http extension suffers from the same problem as cURL, as well as the fact that it has traditionally had far fewer examples of usage. Most modern HTTP client libraries tend to abstract the implementation, to ensure they can work on whatever environment they are executed on, and across any of the above layers.","title":"Client-side HTTP support"},{"location":"accepted/PSR-7-http-message-meta/#server-side-http-support","text":"PHP uses Server APIs (SAPI) to interpret incoming HTTP requests, marshal input, and pass off handling to scripts. The original SAPI design mirrored Common Gateway Interface , which would marshal request data and push it into environment variables before passing delegation to a script; the script would then pull from the environment variables in order to process the request and return a response. PHP's SAPI design abstracts common input sources such as cookies, query string arguments, and url-encoded POST content via superglobals ( $_COOKIE , $_GET , and $_POST , respectively), providing a layer of convenience for web developers. On the response side of the equation, PHP was originally developed as a templating language, and allows intermixing HTML and PHP; any HTML portions of a file are immediately flushed to the output buffer. Modern applications and frameworks eschew this practice, as it can lead to issues with regards to emitting a status line and/or response headers; they tend to aggregate all headers and content, and emit them at once when all other application processing is complete. Special care needs to be paid to ensure that error reporting and other actions that send content to the output buffer do not flush the output buffer.","title":"Server-side HTTP Support"},{"location":"accepted/PSR-7-http-message-meta/#3-why-bother","text":"HTTP messages are used in a wide number of PHP projects -- both clients and servers. In each case, we observe one or more of the following patterns or situations: Projects use PHP's superglobals directly. Projects will create implementations from scratch. Projects may require a specific HTTP client/server library that provides HTTP message implementations. Projects may create adapters for common HTTP message implementations. As examples: Just about any application that began development before the rise of frameworks, which includes a number of very popular CMS, forum, and shopping cart systems, have historically used superglobals. Frameworks such as Symfony and Zend Framework each define HTTP components that form the basis of their MVC layers; even small, single-purpose libraries such as oauth2-server-php provide and require their own HTTP request/response implementations. Guzzle, Buzz, and other HTTP client implementations each create their own HTTP message implementations as well. Projects such as Silex, Stack, and Drupal 8 have hard dependencies on Symfony's HTTP kernel. Any SDK built on Guzzle has a hard requirement on Guzzle's HTTP message implementations. Projects such as Geocoder create redundant adapters for common libraries . Direct usage of superglobals has a number of concerns. First, these are mutable, which makes it possible for libraries and code to alter the values, and thus alter state for the application. Additionally, superglobals make unit and integration testing difficult and brittle, leading to code quality degradation. In the current ecosystem of frameworks that implement HTTP message abstractions, the net result is that projects are not capable of interoperability or cross-pollination. In order to consume code targeting one framework from another, the first order of business is building a bridge layer between the HTTP message implementations. On the client-side, if a particular library does not have an adapter you can utilize, you need to bridge the request/response pairs if you wish to use an adapter from another library. Finally, when it comes to server-side responses, PHP gets in its own way: any content emitted before a call to header() will result in that call becoming a no-op; depending on error reporting settings, this can often mean headers and/or response status are not correctly sent. One way to work around this is to use PHP's output buffering features, but nesting of output buffers can become problematic and difficult to debug. Frameworks and applications thus tend to create response abstractions for aggregating headers and content that can be emitted at once - and these abstractions are often incompatible. Thus, the goal of this proposal is to abstract both client- and server-side request and response interfaces in order to promote interoperability between projects. If projects implement these interfaces, a reasonable level of compatibility may be assumed when adopting code from different libraries. It should be noted that the goal of this proposal is not to obsolete the current interfaces utilized by existing PHP libraries. This proposal is aimed at interoperability between PHP packages for the purpose of describing HTTP messages.","title":"3. Why Bother?"},{"location":"accepted/PSR-7-http-message-meta/#4-scope","text":"","title":"4. Scope"},{"location":"accepted/PSR-7-http-message-meta/#41-goals","text":"Provide the interfaces needed for describing HTTP messages. Focus on practical applications and usability. Define the interfaces to model all elements of the HTTP message and URI specifications. Ensure that the API does not impose arbitrary limits on HTTP messages. For example, some HTTP message bodies can be too large to store in memory, so we must account for this. Provide useful abstractions both for handling incoming requests for server-side applications and for sending outgoing requests in HTTP clients.","title":"4.1 Goals"},{"location":"accepted/PSR-7-http-message-meta/#42-non-goals","text":"This proposal does not expect all HTTP client libraries or server-side frameworks to change their interfaces to conform. It is strictly meant for interoperability. While everyone's perception of what is and is not an implementation detail varies, this proposal should not impose implementation details. As RFCs 7230, 7231, and 3986 do not force any particular implementation, there will be a certain amount of invention needed to describe HTTP message interfaces in PHP.","title":"4.2 Non-Goals"},{"location":"accepted/PSR-7-http-message-meta/#5-design-decisions","text":"","title":"5. Design Decisions"},{"location":"accepted/PSR-7-http-message-meta/#message-design","text":"The MessageInterface provides accessors for the elements common to all HTTP messages, whether they are for requests or responses. These elements include: HTTP protocol version (e.g., \"1.0\", \"1.1\") HTTP headers HTTP message body More specific interfaces are used to describe requests and responses, and more specifically the context of each (client- vs. server-side). These divisions are partly inspired by existing PHP usage, but also by other languages such as Ruby's Rack , Python's WSGI , Go's http package , Node's http module , etc.","title":"Message design"},{"location":"accepted/PSR-7-http-message-meta/#why-are-there-header-methods-on-messages-rather-than-in-a-header-bag","text":"The message itself is a container for the headers (as well as the other message properties). How these are represented internally is an implementation detail, but uniform access to headers is a responsibility of the message.","title":"Why are there header methods on messages rather than in a header bag?"},{"location":"accepted/PSR-7-http-message-meta/#why-are-uris-represented-as-objects","text":"URIs are values, with identity defined by the value, and thus should be modeled as value objects. Additionally, URIs contain a variety of segments which may be accessed many times in a given request -- and which would require parsing the URI in order to determine (e.g., via parse_url() ). Modeling URIs as value objects allows parsing once only, and simplifies access to individual segments. It also provides convenience in client applications by allowing users to create new instances of a base URI instance with only the segments that change (e.g., updating the path only).","title":"Why are URIs represented as objects?"},{"location":"accepted/PSR-7-http-message-meta/#why-does-the-request-interface-have-methods-for-dealing-with-the-request-target-and-compose-a-uri","text":"RFC 7230 details the request line as containing a \"request-target\". Of the four forms of request-target, only one is a URI compliant with RFC 3986; the most common form used is origin-form, which represents the URI without the scheme or authority information. Moreover, since all forms are valid for purposes of requests, the proposal must accommodate each. RequestInterface thus has methods relating to the request-target. By default, it will use the composed URI to present an origin-form request-target, and, in the absence of a URI instance, return the string \"/\". Another method, withRequestTarget() , allows specifying an instance with a specific request-target, allowing users to create requests that use one of the other valid request-target forms. The URI is kept as a discrete member of the request for a variety of reasons. For both clients and servers, knowledge of the absolute URI is typically required. In the case of clients, the URI, and specifically the scheme and authority details, is needed in order to make the actual TCP connection. For server-side applications, the full URI is often required in order to validate the request or to route to an appropriate handler.","title":"Why does the request interface have methods for dealing with the request-target AND compose a URI?"},{"location":"accepted/PSR-7-http-message-meta/#why-value-objects","text":"The proposal models messages and URIs as value objects . Messages are values where the identity is the aggregate of all parts of the message; a change to any aspect of the message is essentially a new message. This is the very definition of a value object. The practice by which changes result in a new instance is termed immutability , and is a feature designed to ensure the integrity of a given value. The proposal also recognizes that most clients and server-side applications will need to be able to easily update message aspects, and, as such, provides interface methods that will create new message instances with the updates. These are generally prefixed with the verbiage with or without . Value objects provides several benefits when modeling HTTP messages: Changes in URI state cannot alter the request composing the URI instance. Changes in headers cannot alter the message composing them. In essence, modeling HTTP messages as value objects ensures the integrity of the message state, and prevents the need for bi-directional dependencies, which can often go out-of-sync or lead to debugging or performance issues. For HTTP clients, they allow consumers to build a base request with data such as the base URI and required headers, without needing to build a brand new request or reset request state for each message the client sends: $uri = new Uri('http://api.example.com'); $baseRequest = new Request($uri, null, [ 'Authorization' => 'Bearer ' . $token, 'Accept' => 'application/json', ]); $request = $baseRequest->withUri($uri->withPath('/user'))->withMethod('GET'); $response = $client->send($request); // get user id from $response $body = new StringStream(json_encode(['tasks' => [ 'Code', 'Coffee', ]])); $request = $baseRequest ->withUri($uri->withPath('/tasks/user/' . $userId)) ->withMethod('POST') ->withHeader('Content-Type', 'application/json') ->withBody($body); $response = $client->send($request) // No need to overwrite headers or body! $request = $baseRequest->withUri($uri->withPath('/tasks'))->withMethod('GET'); $response = $client->send($request); On the server-side, developers will need to: Deserialize the request message body. Decrypt HTTP cookies. Write to the response. These operations can be accomplished with value objects as well, with a number of benefits: The original request state can be stored for retrieval by any consumer. A default response state can be created with default headers and/or message body. Most popular PHP frameworks have fully mutable HTTP messages today. The main changes necessary in consuming true value objects are: Instead of calling setter methods or setting public properties, mutator methods will be called, and the result assigned. Developers must notify the application on a change in state. As an example, in Zend Framework 2, instead of the following: function (MvcEvent $e) { $response = $e->getResponse(); $response->setHeaderLine('x-foo', 'bar'); } one would now write: function (MvcEvent $e) { $response = $e->getResponse(); $e->setResponse( $response->withHeader('x-foo', 'bar') ); } The above combines assignment and notification in a single call. This practice has a side benefit of making explicit any changes to application state being made.","title":"Why value objects?"},{"location":"accepted/PSR-7-http-message-meta/#new-instances-vs-returning-this","text":"One observation made on the various with*() methods is that they can likely safely return $this; if the argument presented will not result in a change in the value. One rationale for doing so is performance (as this will not result in a cloning operation). The various interfaces have been written with verbiage indicating that immutability MUST be preserved, but only indicate that \"an instance\" must be returned containing the new state. Since instances that represent the same value are considered equal, returning $this is functionally equivalent, and thus allowed.","title":"New instances vs returning $this"},{"location":"accepted/PSR-7-http-message-meta/#using-streams-instead-of-x","text":"MessageInterface uses a body value that must implement StreamInterface . This design decision was made so that developers can send and receive (and/or receive and send) HTTP messages that contain more data than can practically be stored in memory while still allowing the convenience of interacting with message bodies as a string. While PHP provides a stream abstraction by way of stream wrappers, stream resources can be cumbersome to work with: stream resources can only be cast to a string using stream_get_contents() or manually reading the remainder of a string. Adding custom behavior to a stream as it is consumed or populated requires registering a stream filter; however, stream filters can only be added to a stream after the filter is registered with PHP (i.e., there is no stream filter autoloading mechanism). The use of a well- defined stream interface allows for the potential of flexible stream decorators that can be added to a request or response pre-flight to enable things like encryption, compression, ensuring that the number of bytes downloaded reflects the number of bytes reported in the Content-Length of a response, etc. Decorating streams is a well-established pattern in the Java and Node communities that allows for very flexible streams. The majority of the StreamInterface API is based on Python's io module , which provides a practical and consumable API. Instead of implementing stream capabilities using something like a WritableStreamInterface and ReadableStreamInterface , the capabilities of a stream are provided by methods like isReadable() , isWritable() , etc. This approach is used by Python, C#, C++ , Ruby , Node , and likely others.","title":"Using streams instead of X"},{"location":"accepted/PSR-7-http-message-meta/#what-if-i-just-want-to-return-a-file","text":"In some cases, you may want to return a file from the filesystem. The typical way to do this in PHP is one of the following: readfile($filename); stream_copy_to_stream(fopen($filename, 'r'), fopen('php://output', 'w')); Note that the above omits sending appropriate Content-Type and Content-Length headers; the developer would need to emit these prior to calling the above code. The equivalent using HTTP messages would be to use a StreamInterface implementation that accepts a filename and/or stream resource, and to provide this to the response instance. A complete example, including setting appropriate headers: // where Stream is a concrete StreamInterface: $stream = new Stream($filename); $finfo = new finfo(FILEINFO_MIME); $response = $response ->withHeader('Content-Type', $finfo->file($filename)) ->withHeader('Content-Length', (string) filesize($filename)) ->withBody($stream); Emitting this response will send the file to the client.","title":"What if I just want to return a file?"},{"location":"accepted/PSR-7-http-message-meta/#what-if-i-want-to-directly-emit-output","text":"Directly emitting output (e.g. via echo , printf , or writing to the php://output stream) is generally only advisable as a performance optimization or when emitting large data sets. If it needs to be done and you still wish to work in an HTTP message paradigm, one approach would be to use a callback-based StreamInterface implementation, per this example . Wrap any code emitting output directly in a callback, pass that to an appropriate StreamInterface implementation, and provide it to the message body: $output = new CallbackStream(function () use ($request) { printf(\"The requested URI was: %s<br>\\n\", $request->getUri()); return ''; }); return (new Response()) ->withHeader('Content-Type', 'text/html') ->withBody($output);","title":"What if I want to directly emit output?"},{"location":"accepted/PSR-7-http-message-meta/#what-if-i-want-to-use-an-iterator-for-content","text":"Ruby's Rack implementation uses an iterator-based approach for server-side response message bodies. This can be emulated using an HTTP message paradigm via an iterator-backed StreamInterface approach, as detailed in the psr7examples repository .","title":"What if I want to use an iterator for content?"},{"location":"accepted/PSR-7-http-message-meta/#why-are-streams-mutable","text":"The StreamInterface API includes methods such as write() which can change the message content -- which directly contradicts having immutable messages. The problem that arises is due to the fact that the interface is intended to wrap a PHP stream or similar. A write operation therefore will proxy to writing to the stream. Even if we made StreamInterface immutable, once the stream has been updated, any instance that wraps that stream will also be updated -- making immutability impossible to enforce. Our recommendation is that implementations use read-only streams for server-side requests and client-side responses.","title":"Why are streams mutable?"},{"location":"accepted/PSR-7-http-message-meta/#rationale-for-serverrequestinterface","text":"The RequestInterface and ResponseInterface have essentially 1:1 correlations with the request and response messages described in RFC 7230 . They provide interfaces for implementing value objects that correspond to the specific HTTP message types they model. For server-side applications there are other considerations for incoming requests: Access to server parameters (potentially derived from the request, but also potentially the result of server configuration, and generally represented via the $_SERVER superglobal; these are part of the PHP Server API (SAPI)). Access to the query string arguments (usually encapsulated in PHP via the $_GET superglobal). Access to the parsed body (i.e., data deserialized from the incoming request body; in PHP, this is typically the result of POST requests using application/x-www-form-urlencoded content types, and encapsulated in the $_POST superglobal, but for non-POST, non-form-encoded data, could be an array or an object). Access to uploaded files (encapsulated in PHP via the $_FILES superglobal). Access to cookie values (encapsulated in PHP via the $_COOKIE superglobal). Access to attributes derived from the request (usually, but not limited to, those matched against the URL path). Uniform access to these parameters increases the viability of interoperability between frameworks and libraries, as they can now assume that if a request implements ServerRequestInterface , they can get at these values. It also solves problems within the PHP language itself: Until 5.6.0, php://input was read-once; as such, instantiating multiple request instances from multiple frameworks/libraries could lead to inconsistent state, as the first to access php://input would be the only one to receive the data. Unit testing against superglobals (e.g., $_GET , $_FILES , etc.) is difficult and typically brittle. Encapsulating them inside the ServerRequestInterface implementation eases testing considerations.","title":"Rationale for ServerRequestInterface"},{"location":"accepted/PSR-7-http-message-meta/#why-parsed-body-in-the-serverrequestinterface","text":"Arguments were made to use the terminology \"BodyParams\", and require the value to be an array, with the following rationale: Consistency with other server-side parameter access. $_POST is an array, and the 80% use case would target that superglobal. A single type makes for a strong contract, simplifying usage. The main argument is that if the body parameters are an array, developers have predictable access to values: $foo = isset($request->getBodyParams()['foo']) ? $request->getBodyParams()['foo'] : null; The argument for using \"parsed body\" was made by examining the domain. A message body can contain literally anything. While traditional web applications use forms and submit data using POST, this is a use case that is quickly being challenged in current web development trends, which are often API-centric, and thus use alternate request methods (notably PUT and PATCH), as well as non-form-encoded content (generally JSON or XML) that can be coerced to arrays in many cases, but in many cases also cannot or should not . If forcing the property representing the parsed body to be only an array, developers then need a shared convention about where to put the results of parsing the body. These might include: A special key under the body parameters, such as __parsed__ . A specially named attribute, such as __body__ . The end result is that a developer now has to look in multiple locations: $data = $request->getBodyParams(); if (isset($data['__parsed__']) && is_object($data['__parsed__'])) { $data = $data['__parsed__']; } // or: $data = $request->getBodyParams(); if ($request->hasAttribute('__body__')) { $data = $request->getAttribute('__body__'); } The solution presented is to use the terminology \"ParsedBody\", which implies that the values are the results of parsing the message body. This also means that the return value will be ambiguous; however, because this is an attribute of the domain, this is also expected. As such, usage will become: $data = $request->getParsedBody(); if (! $data instanceof \\stdClass) { // raise an exception! } // otherwise, we have what we expected This approach removes the limitations of forcing an array, at the expense of ambiguity of return value. Considering that the other suggested solutions \u2014 pushing the parsed data into a special body parameter key or into an attribute \u2014 also suffer from ambiguity, the proposed solution is simpler as it does not require additions to the interface specification. Ultimately, the ambiguity enables the flexibility required when representing the results of parsing the body.","title":"Why \"parsed body\" in the ServerRequestInterface?"},{"location":"accepted/PSR-7-http-message-meta/#why-is-no-functionality-included-for-retrieving-the-base-path","text":"Many frameworks provide the ability to get the \"base path,\" usually considered the path up to and including the front controller. As an example, if the application is served at http://example.com/b2b/index.php , and the current URI used to request it is http://example.com/b2b/index.php/customer/register , the functionality to retrieve the base path would return /b2b/index.php . This value can then be used by routers to strip that path segment prior to attempting a match. This value is often also then used for URI generation within applications; parameters will be passed to the router, which will generate the path, and prefix it with the base path in order to return a fully-qualified URI. Other tools \u2014 typically view helpers, template filters, or template functions \u2014 are used to resolve a path relative to the base path in order to generate a URI for linking to resources such as static assets. On examination of several different implementations, we noticed the following: The logic for determining the base path varies widely between implementations. As an example, compare the logic in ZF2 to the logic in Symfony 2 . Most implementations appear to allow manual injection of a base path to the router and/or any facilities used for URI generation. The primary use cases \u2014 routing and URI generation \u2014 typically are the only consumers of the functionality; developers usually do not need to be aware of the base path concept as other objects take care of that detail for them. As examples: A router will strip off the base path for you during routing; you do not need to pass the modified path to the router. View helpers, template filters, etc. typically are injected with a base path prior to invocation. Sometimes this is manually done, though more often it is the result of framework wiring. All sources necessary for calculating the base path are already in the RequestInterface instance , via server parameters and the URI instance. Our stance is that base path detection is framework and/or application specific, and the results of detection can be easily injected into objects that need it, and/or calculated as needed using utility functions and/or classes from the RequestInterface instance itself.","title":"Why is no functionality included for retrieving the \"base path\"?"},{"location":"accepted/PSR-7-http-message-meta/#why-does-getuploadedfiles-return-objects-instead-of-arrays","text":"getUploadedFiles() returns a tree of Psr\\Http\\Message\\UploadedFileInterface instances. This is done primarily to simplify specification: instead of requiring paragraphs of implementation specification for an array, we specify an interface. Additionally, the data in an UploadedFileInterface is normalized to work in both SAPI and non-SAPI environments. This allows the creation of processes to parse the message body manually and assign contents to streams without first writing to the filesystem, while still allowing proper handling of file uploads in SAPI environments.","title":"Why does getUploadedFiles() return objects instead of arrays?"},{"location":"accepted/PSR-7-http-message-meta/#what-about-special-header-values","text":"A number of header values contain unique representation requirements which can pose problems both for consumption as well as generation; in particular, cookies and the Accept header. This proposal does not provide any special treatment of any header types. The base MessageInterface provides methods for header retrieval and setting, and all header values are, in the end, string values. Developers are encouraged to write commodity libraries for interacting with these header values, either for the purposes of parsing or generation. Users may then consume these libraries when needing to interact with those values. Examples of this practice already exist in libraries such as willdurand/Negotiation and Aura.Accept . So long as the object has functionality for casting the value to a string, these objects can be used to populate the headers of an HTTP message.","title":"What about \"special\" header values?"},{"location":"accepted/PSR-7-http-message-meta/#6-people","text":"","title":"6. People"},{"location":"accepted/PSR-7-http-message-meta/#61-editors","text":"Matthew Weier O'Phinney","title":"6.1 Editor(s)"},{"location":"accepted/PSR-7-http-message-meta/#62-sponsors","text":"Paul M. Jones Beau Simensen (coordinator)","title":"6.2 Sponsors"},{"location":"accepted/PSR-7-http-message-meta/#63-contributors","text":"Michael Dowling Larry Garfield Evert Pot Tobias Schultze Bernhard Schussek Anton Serdyuk Phil Sturgeon Chris Wilkinson","title":"6.3 Contributors"},{"location":"accepted/PSR-7-http-message/","text":"HTTP message interfaces This document describes common interfaces for representing HTTP messages as described in RFC 7230 and RFC 7231 , and URIs for use with HTTP messages as described in RFC 3986 . HTTP messages are the foundation of web development. Web browsers and HTTP clients such as cURL create HTTP request messages that are sent to a web server, which provides an HTTP response message. Server-side code receives an HTTP request message, and returns an HTTP response message. HTTP messages are typically abstracted from the end-user consumer, but as developers, we typically need to know how they are structured and how to access or manipulate them in order to perform our tasks, whether that might be making a request to an HTTP API, or handling an incoming request. Every HTTP request message has a specific form: POST /path HTTP/1.1 Host: example.com foo=bar&baz=bat The first line of a request is the \"request line\", and contains, in order, the HTTP request method, the request target (usually either an absolute URI or a path on the web server), and the HTTP protocol version. This is followed by one or more HTTP headers, an empty line, and the message body. HTTP response messages have a similar structure: HTTP/1.1 200 OK Content-Type: text/plain This is the response body The first line is the \"status line\", and contains, in order, the HTTP protocol version, the HTTP status code, and a \"reason phrase,\" a human-readable description of the status code. Like the request message, this is then followed by one or more HTTP headers, an empty line, and the message body. The interfaces described in this document are abstractions around HTTP messages and the elements composing them. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . References RFC 2119 RFC 3986 RFC 7230 RFC 7231 1. Specification 1.1 Messages An HTTP message is either a request from a client to a server or a response from a server to a client. This specification defines interfaces for the HTTP messages Psr\\Http\\Message\\RequestInterface and Psr\\Http\\Message\\ResponseInterface respectively. Both Psr\\Http\\Message\\RequestInterface and Psr\\Http\\Message\\ResponseInterface extend Psr\\Http\\Message\\MessageInterface . While Psr\\Http\\Message\\MessageInterface MAY be implemented directly, implementors SHOULD implement Psr\\Http\\Message\\RequestInterface and Psr\\Http\\Message\\ResponseInterface . From here forward, the namespace Psr\\Http\\Message will be omitted when referring to these interfaces. 1.2 HTTP Headers Case-insensitive header field names HTTP messages include case-insensitive header field names. Headers are retrieved by name from classes implementing the MessageInterface in a case-insensitive manner. For example, retrieving the foo header will return the same result as retrieving the FoO header. Similarly, setting the Foo header will overwrite any previously set foo header value. $message = $message->withHeader('foo', 'bar'); echo $message->getHeaderLine('foo'); // Outputs: bar echo $message->getHeaderLine('FOO'); // Outputs: bar $message = $message->withHeader('fOO', 'baz'); echo $message->getHeaderLine('foo'); // Outputs: baz Despite that headers may be retrieved case-insensitively, the original case MUST be preserved by the implementation, in particular when retrieved with getHeaders() . Non-conforming HTTP applications may depend on a certain case, so it is useful for a user to be able to dictate the case of the HTTP headers when creating a request or response. Headers with multiple values In order to accommodate headers with multiple values yet still provide the convenience of working with headers as strings, headers can be retrieved from an instance of a MessageInterface as an array or a string. Use the getHeaderLine() method to retrieve a header value as a string containing all header values of a case-insensitive header by name concatenated with a comma. Use getHeader() to retrieve an array of all the header values for a particular case-insensitive header by name. $message = $message ->withHeader('foo', 'bar') ->withAddedHeader('foo', 'baz'); $header = $message->getHeaderLine('foo'); // $header contains: 'bar,baz' $header = $message->getHeader('foo'); // ['bar', 'baz'] Note: Not all header values can be concatenated using a comma (e.g., Set-Cookie ). When working with such headers, consumers of MessageInterface -based classes SHOULD rely on the getHeader() method for retrieving such multi-valued headers. Host header In requests, the Host header typically mirrors the host component of the URI, as well as the host used when establishing the TCP connection. However, the HTTP specification allows the Host header to differ from each of the two. During construction, implementations MUST attempt to set the Host header from a provided URI if no Host header is provided. RequestInterface::withUri() will, by default, replace the returned request's Host header with a Host header matching the host component of the passed UriInterface . You can opt-in to preserving the original state of the Host header by passing true for the second ( $preserveHost ) argument. When this argument is set to true , the returned request will not update the Host header of the returned message -- unless the message contains no Host header. This table illustrates what getHeaderLine('Host') will return for a request returned by withUri() with the $preserveHost argument set to true for various initial requests and URIs. Request Host header 1 Request host component 2 URI host component 3 Result '' '' '' '' '' foo.com '' foo.com '' foo.com bar.com foo.com foo.com '' bar.com foo.com foo.com bar.com baz.com foo.com 1 Host header value prior to operation. 2 Host component of the URI composed in the request prior to the operation. 3 Host component of the URI being injected via withUri() . 1.3 Streams HTTP messages consist of a start-line, headers, and a body. The body of an HTTP message can be very small or extremely large. Attempting to represent the body of a message as a string can easily consume more memory than intended because the body must be stored completely in memory. Attempting to store the body of a request or response in memory would preclude the use of that implementation from being able to work with large message bodies. StreamInterface is used in order to hide the implementation details when a stream of data is read from or written to. For situations where a string would be an appropriate message implementation, built-in streams such as php://memory and php://temp may be used. StreamInterface exposes several methods that enable streams to be read from, written to, and traversed effectively. Streams expose their capabilities using three methods: isReadable() , isWritable() , and isSeekable() . These methods can be used by stream collaborators to determine if a stream is capable of their requirements. Each stream instance will have various capabilities: it can be read-only, write-only, or read-write. It can also allow arbitrary random access (seeking forwards or backwards to any location), or only sequential access (for example in the case of a socket, pipe, or callback-based stream). Finally, StreamInterface defines a __toString() method to simplify retrieving or emitting the entire body contents at once. Unlike the request and response interfaces, StreamInterface does not model immutability. In situations where an actual PHP stream is wrapped, immutability is impossible to enforce, as any code that interacts with the resource can potentially change its state (including cursor position, contents, and more). Our recommendation is that implementations use read-only streams for server-side requests and client-side responses. Consumers should be aware of the fact that the stream instance may be mutable, and, as such, could alter the state of the message; when in doubt, create a new stream instance and attach it to a message to enforce state. 1.4 Request Targets and URIs Per RFC 7230, request messages contain a \"request-target\" as the second segment of the request line. The request target can be one of the following forms: origin-form , which consists of the path, and, if present, the query string; this is often referred to as a relative URL. Messages as transmitted over TCP typically are of origin-form; scheme and authority data are usually only present via CGI variables. absolute-form , which consists of the scheme, authority (\"[user-info@]host[:port]\", where items in brackets are optional), path (if present), query string (if present), and fragment (if present). This is often referred to as an absolute URI, and is the only form to specify a URI as detailed in RFC 3986. This form is commonly used when making requests to HTTP proxies. authority-form , which consists of the authority only. This is typically used in CONNECT requests only, to establish a connection between an HTTP client and a proxy server. asterisk-form , which consists solely of the string * , and which is used with the OPTIONS method to determine the general capabilities of a web server. Aside from these request-targets, there is often an 'effective URL' which is separate from the request target. The effective URL is not transmitted within an HTTP message, but it is used to determine the protocol (http/https), port and hostname for making the request. The effective URL is represented by UriInterface . UriInterface models HTTP and HTTPS URIs as specified in RFC 3986 (the primary use case). The interface provides methods for interacting with the various URI parts, which will obviate the need for repeated parsing of the URI. It also specifies a __toString() method for casting the modeled URI to its string representation. When retrieving the request-target with getRequestTarget() , by default this method will use the URI object and extract all the necessary components to construct the origin-form . The origin-form is by far the most common request-target. If it's desired by an end-user to use one of the other three forms, or if the user wants to explicitly override the request-target, it is possible to do so with withRequestTarget() . Calling this method does not affect the URI, as it is returned from getUri() . For example, a user may want to make an asterisk-form request to a server: $request = $request ->withMethod('OPTIONS') ->withRequestTarget('*') ->withUri(new Uri('https://example.org/')); This example may ultimately result in an HTTP request that looks like this: OPTIONS * HTTP/1.1 But the HTTP client will be able to use the effective URL (from getUri() ), to determine the protocol, hostname and TCP port. An HTTP client MUST ignore the values of Uri::getPath() and Uri::getQuery() , and instead use the value returned by getRequestTarget() , which defaults to concatenating these two values. Clients that choose to not implement 1 or more of the 4 request-target forms, MUST still use getRequestTarget() . These clients MUST reject request-targets they do not support, and MUST NOT fall back on the values from getUri() . RequestInterface provides methods for retrieving the request-target or creating a new instance with the provided request-target. By default, if no request-target is specifically composed in the instance, getRequestTarget() will return the origin-form of the composed URI (or \"/\" if no URI is composed). withRequestTarget($requestTarget) creates a new instance with the specified request target, and thus allows developers to create request messages that represent the other three request-target forms (absolute-form, authority-form, and asterisk-form). When used, the composed URI instance can still be of use, particularly in clients, where it may be used to create the connection to the server. 1.5 Server-side Requests RequestInterface provides the general representation of an HTTP request message. However, server-side requests need additional treatment, due to the nature of the server-side environment. Server-side processing needs to take into account Common Gateway Interface (CGI), and, more specifically, PHP's abstraction and extension of CGI via its Server APIs (SAPI). PHP has provided simplification around input marshaling via superglobals such as: $_COOKIE , which deserializes and provides simplified access to HTTP cookies. $_GET , which deserializes and provides simplified access to query string arguments. $_POST , which deserializes and provides simplified access for urlencoded parameters submitted via HTTP POST; generically, it can be considered the results of parsing the message body. $_FILES , which provides serialized metadata around file uploads. $_SERVER , which provides access to CGI/SAPI environment variables, which commonly include the request method, the request scheme, the request URI, and headers. ServerRequestInterface extends RequestInterface to provide an abstraction around these various superglobals. This practice helps reduce coupling to the superglobals by consumers, and encourages and promotes the ability to test request consumers. The server request provides one additional property, \"attributes\", to allow consumers the ability to introspect, decompose, and match the request against application-specific rules (such as path matching, scheme matching, host matching, etc.). As such, the server request can also provide messaging between multiple request consumers. 1.6 Uploaded files ServerRequestInterface specifies a method for retrieving a tree of upload files in a normalized structure, with each leaf an instance of UploadedFileInterface . The $_FILES superglobal has some well-known problems when dealing with arrays of file inputs. As an example, if you have a form that submits an array of files \u2014 e.g., the input name \"files\", submitting files[0] and files[1] \u2014 PHP will represent this as: array( 'files' => array( 'name' => array( 0 => 'file0.txt', 1 => 'file1.html', ), 'type' => array( 0 => 'text/plain', 1 => 'text/html', ), /* etc. */ ), ) instead of the expected: array( 'files' => array( 0 => array( 'name' => 'file0.txt', 'type' => 'text/plain', /* etc. */ ), 1 => array( 'name' => 'file1.html', 'type' => 'text/html', /* etc. */ ), ), ) The result is that consumers need to know this language implementation detail, and write code for gathering the data for a given upload. Additionally, scenarios exist where $_FILES is not populated when file uploads occur: When the HTTP method is not POST . When unit testing. When operating under a non-SAPI environment, such as ReactPHP . In such cases, the data will need to be seeded differently. As examples: A process might parse the message body to discover the file uploads. In such cases, the implementation may choose not to write the file uploads to the file system, but instead wrap them in a stream in order to reduce memory, I/O, and storage overhead. In unit testing scenarios, developers need to be able to stub and/or mock the file upload metadata in order to validate and verify different scenarios. getUploadedFiles() provides the normalized structure for consumers. Implementations are expected to: Aggregate all information for a given file upload, and use it to populate a Psr\\Http\\Message\\UploadedFileInterface instance. Re-create the submitted tree structure, with each leaf being the appropriate Psr\\Http\\Message\\UploadedFileInterface instance for the given location in the tree. The tree structure referenced should mimic the naming structure in which files were submitted. In the simplest example, this might be a single named form element submitted as: <input type=\"file\" name=\"avatar\" /> In this case, the structure in $_FILES would look like: array( 'avatar' => array( 'tmp_name' => 'phpUxcOty', 'name' => 'my-avatar.png', 'size' => 90996, 'type' => 'image/png', 'error' => 0, ), ) The normalized form returned by getUploadedFiles() would be: array( 'avatar' => /* UploadedFileInterface instance */ ) In the case of an input using array notation for the name: <input type=\"file\" name=\"my-form[details][avatar]\" /> $_FILES ends up looking like this: array ( 'my-form' => array ( 'name' => array ( 'details' => array ( 'avatar' => 'my-avatar.png', ), ), 'type' => array ( 'details' => array ( 'avatar' => 'image/png', ), ), 'tmp_name' => array ( 'details' => array ( 'avatar' => 'phpmFLrzD', ), ), 'error' => array ( 'details' => array ( 'avatar' => 0, ), ), 'size' => array ( 'details' => array ( 'avatar' => 90996, ), ), ), ) And the corresponding tree returned by getUploadedFiles() should be: array( 'my-form' => array( 'details' => array( 'avatar' => /* UploadedFileInterface instance */ ), ), ) In some cases, you may specify an array of files: Upload an avatar: <input type=\"file\" name=\"my-form[details][avatars][]\" /> Upload an avatar: <input type=\"file\" name=\"my-form[details][avatars][]\" /> (As an example, JavaScript controls might spawn additional file upload inputs to allow uploading multiple files at once.) In such a case, the specification implementation must aggregate all information related to the file at the given index. The reason is because $_FILES deviates from its normal structure in such cases: array ( 'my-form' => array ( 'name' => array ( 'details' => array ( 'avatars' => array ( 0 => 'my-avatar.png', 1 => 'my-avatar2.png', 2 => 'my-avatar3.png', ), ), ), 'type' => array ( 'details' => array ( 'avatars' => array ( 0 => 'image/png', 1 => 'image/png', 2 => 'image/png', ), ), ), 'tmp_name' => array ( 'details' => array ( 'avatars' => array ( 0 => 'phpmFLrzD', 1 => 'phpV2pBil', 2 => 'php8RUG8v', ), ), ), 'error' => array ( 'details' => array ( 'avatars' => array ( 0 => 0, 1 => 0, 2 => 0, ), ), ), 'size' => array ( 'details' => array ( 'avatars' => array ( 0 => 90996, 1 => 90996, 3 => 90996, ), ), ), ), ) The above $_FILES array would correspond to the following structure as returned by getUploadedFiles() : array( 'my-form' => array( 'details' => array( 'avatars' => array( 0 => /* UploadedFileInterface instance */, 1 => /* UploadedFileInterface instance */, 2 => /* UploadedFileInterface instance */, ), ), ), ) Consumers would access index 1 of the nested array using: $request->getUploadedFiles()['my-form']['details']['avatars'][1]; Because the uploaded files data is derivative (derived from $_FILES or the request body), a mutator method, withUploadedFiles() , is also present in the interface, allowing delegation of the normalization to another process. In the case of the original examples, consumption resembles the following: $file0 = $request->getUploadedFiles()['files'][0]; $file1 = $request->getUploadedFiles()['files'][1]; printf( \"Received the files %s and %s\", $file0->getClientFilename(), $file1->getClientFilename() ); // \"Received the files file0.txt and file1.html\" This proposal also recognizes that implementations may operate in non-SAPI environments. As such, UploadedFileInterface provides methods for ensuring operations will work regardless of environment. In particular: moveTo($targetPath) is provided as a safe and recommended alternative to calling move_uploaded_file() directly on the temporary upload file. Implementations will detect the correct operation to use based on environment. getStream() will return a StreamInterface instance. In non-SAPI environments, one proposed possibility is to parse individual upload files into php://temp streams instead of directly to files; in such cases, no upload file is present. getStream() is therefore guaranteed to work regardless of environment. As examples: // Move a file to an upload directory $filename = sprintf( '%s.%s', create_uuid(), pathinfo($file0->getClientFilename(), PATHINFO_EXTENSION) ); $file0->moveTo(DATA_DIR . '/' . $filename); // Stream a file to Amazon S3. // Assume $s3wrapper is a PHP stream that will write to S3, and that // Psr7StreamWrapper is a class that will decorate a StreamInterface as a PHP // StreamWrapper. $stream = new Psr7StreamWrapper($file1->getStream()); stream_copy_to_stream($stream, $s3wrapper); 2. Package The interfaces and classes described are provided as part of the psr/http-message package. 3. Interfaces 3.1 Psr\\Http\\Message\\MessageInterface <?php namespace Psr\\Http\\Message; /** * HTTP messages consist of requests from a client to a server and responses * from a server to a client. This interface defines the methods common to * each. * * Messages are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. * * @see http://www.ietf.org/rfc/rfc7230.txt * @see http://www.ietf.org/rfc/rfc7231.txt */ interface MessageInterface { /** * Retrieves the HTTP protocol version as a string. * * The string MUST contain only the HTTP version number (e.g., \"1.1\", \"1.0\"). * * @return string HTTP protocol version. */ public function getProtocolVersion(); /** * Return an instance with the specified HTTP protocol version. * * The version string MUST contain only the HTTP version number (e.g., * \"1.1\", \"1.0\"). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new protocol version. * * @param string $version HTTP protocol version * @return static */ public function withProtocolVersion($version); /** * Retrieves all message header values. * * The keys represent the header name as it will be sent over the wire, and * each value is an array of strings associated with the header. * * // Represent the headers as a string * foreach ($message->getHeaders() as $name => $values) { * echo $name . ': ' . implode(', ', $values); * } * * // Emit headers iteratively: * foreach ($message->getHeaders() as $name => $values) { * foreach ($values as $value) { * header(sprintf('%s: %s', $name, $value), false); * } * } * * While header names are not case-sensitive, getHeaders() will preserve the * exact case in which headers were originally specified. * * @return string[][] Returns an associative array of the message's headers. * Each key MUST be a header name, and each value MUST be an array of * strings for that header. */ public function getHeaders(); /** * Checks if a header exists by the given case-insensitive name. * * @param string $name Case-insensitive header field name. * @return bool Returns true if any header names match the given header * name using a case-insensitive string comparison. Returns false if * no matching header name is found in the message. */ public function hasHeader($name); /** * Retrieves a message header value by the given case-insensitive name. * * This method returns an array of all the header values of the given * case-insensitive header name. * * If the header does not appear in the message, this method MUST return an * empty array. * * @param string $name Case-insensitive header field name. * @return string[] An array of string values as provided for the given * header. If the header does not appear in the message, this method MUST * return an empty array. */ public function getHeader($name); /** * Retrieves a comma-separated string of the values for a single header. * * This method returns all of the header values of the given * case-insensitive header name as a string concatenated together using * a comma. * * NOTE: Not all header values may be appropriately represented using * comma concatenation. For such headers, use getHeader() instead * and supply your own delimiter when concatenating. * * If the header does not appear in the message, this method MUST return * an empty string. * * @param string $name Case-insensitive header field name. * @return string A string of values as provided for the given header * concatenated together using a comma. If the header does not appear in * the message, this method MUST return an empty string. */ public function getHeaderLine($name); /** * Return an instance with the provided value replacing the specified header. * * While header names are case-insensitive, the casing of the header will * be preserved by this function, and returned from getHeaders(). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new and/or updated header and value. * * @param string $name Case-insensitive header field name. * @param string|string[] $value Header value(s). * @return static * @throws \\InvalidArgumentException for invalid header names or values. */ public function withHeader($name, $value); /** * Return an instance with the specified header appended with the given value. * * Existing values for the specified header will be maintained. The new * value(s) will be appended to the existing list. If the header did not * exist previously, it will be added. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new header and/or value. * * @param string $name Case-insensitive header field name to add. * @param string|string[] $value Header value(s). * @return static * @throws \\InvalidArgumentException for invalid header names. * @throws \\InvalidArgumentException for invalid header values. */ public function withAddedHeader($name, $value); /** * Return an instance without the specified header. * * Header resolution MUST be done without case-sensitivity. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that removes * the named header. * * @param string $name Case-insensitive header field name to remove. * @return static */ public function withoutHeader($name); /** * Gets the body of the message. * * @return StreamInterface Returns the body as a stream. */ public function getBody(); /** * Return an instance with the specified message body. * * The body MUST be a StreamInterface object. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return a new instance that has the * new body stream. * * @param StreamInterface $body Body. * @return static * @throws \\InvalidArgumentException When the body is not valid. */ public function withBody(StreamInterface $body); } 3.2 Psr\\Http\\Message\\RequestInterface <?php namespace Psr\\Http\\Message; /** * Representation of an outgoing, client-side request. * * Per the HTTP specification, this interface includes properties for * each of the following: * * - Protocol version * - HTTP method * - URI * - Headers * - Message body * * During construction, implementations MUST attempt to set the Host header from * a provided URI if no Host header is provided. * * Requests are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. */ interface RequestInterface extends MessageInterface { /** * Retrieves the message's request target. * * Retrieves the message's request-target either as it will appear (for * clients), as it appeared at request (for servers), or as it was * specified for the instance (see withRequestTarget()). * * In most cases, this will be the origin-form of the composed URI, * unless a value was provided to the concrete implementation (see * withRequestTarget() below). * * If no URI is available, and no request-target has been specifically * provided, this method MUST return the string \"/\". * * @return string */ public function getRequestTarget(); /** * Return an instance with the specific request-target. * * If the request needs a non-origin-form request-target \u2014 e.g., for * specifying an absolute-form, authority-form, or asterisk-form \u2014 * this method may be used to create an instance with the specified * request-target, verbatim. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * changed request target. * * @see http://tools.ietf.org/html/rfc7230#section-5.3 (for the various * request-target forms allowed in request messages) * @param mixed $requestTarget * @return static */ public function withRequestTarget($requestTarget); /** * Retrieves the HTTP method of the request. * * @return string Returns the request method. */ public function getMethod(); /** * Return an instance with the provided HTTP method. * * While HTTP method names are typically all uppercase characters, HTTP * method names are case-sensitive and thus implementations SHOULD NOT * modify the given string. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * changed request method. * * @param string $method Case-sensitive method. * @return static * @throws \\InvalidArgumentException for invalid HTTP methods. */ public function withMethod($method); /** * Retrieves the URI instance. * * This method MUST return a UriInterface instance. * * @see http://tools.ietf.org/html/rfc3986#section-4.3 * @return UriInterface Returns a UriInterface instance * representing the URI of the request. */ public function getUri(); /** * Returns an instance with the provided URI. * * This method MUST update the Host header of the returned request by * default if the URI contains a host component. If the URI does not * contain a host component, any pre-existing Host header MUST be carried * over to the returned request. * * You can opt-in to preserving the original state of the Host header by * setting `$preserveHost` to `true`. When `$preserveHost` is set to * `true`, this method interacts with the Host header in the following ways: * * - If the Host header is missing or empty, and the new URI contains * a host component, this method MUST update the Host header in the returned * request. * - If the Host header is missing or empty, and the new URI does not contain a * host component, this method MUST NOT update the Host header in the returned * request. * - If a Host header is present and non-empty, this method MUST NOT update * the Host header in the returned request. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new UriInterface instance. * * @see http://tools.ietf.org/html/rfc3986#section-4.3 * @param UriInterface $uri New request URI to use. * @param bool $preserveHost Preserve the original state of the Host header. * @return static */ public function withUri(UriInterface $uri, $preserveHost = false); } 3.2.1 Psr\\Http\\Message\\ServerRequestInterface <?php namespace Psr\\Http\\Message; /** * Representation of an incoming, server-side HTTP request. * * Per the HTTP specification, this interface includes properties for * each of the following: * * - Protocol version * - HTTP method * - URI * - Headers * - Message body * * Additionally, it encapsulates all data as it has arrived at the * application from the CGI and/or PHP environment, including: * * - The values represented in $_SERVER. * - Any cookies provided (generally via $_COOKIE) * - Query string arguments (generally via $_GET, or as parsed via parse_str()) * - Upload files, if any (as represented by $_FILES) * - Deserialized body parameters (generally from $_POST) * * $_SERVER values MUST be treated as immutable, as they represent application * state at the time of request; as such, no methods are provided to allow * modification of those values. The other values provide such methods, as they * can be restored from $_SERVER or the request body, and may need treatment * during the application (e.g., body parameters may be deserialized based on * content type). * * Additionally, this interface recognizes the utility of introspecting a * request to derive and match additional parameters (e.g., via URI path * matching, decrypting cookie values, deserializing non-form-encoded body * content, matching authorization headers to users, etc). These parameters * are stored in an \"attributes\" property. * * Requests are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. */ interface ServerRequestInterface extends RequestInterface { /** * Retrieve server parameters. * * Retrieves data related to the incoming request environment, * typically derived from PHP's $_SERVER superglobal. The data IS NOT * REQUIRED to originate from $_SERVER. * * @return array */ public function getServerParams(); /** * Retrieve cookies. * * Retrieves cookies sent by the client to the server. * * The data MUST be compatible with the structure of the $_COOKIE * superglobal. * * @return array */ public function getCookieParams(); /** * Return an instance with the specified cookies. * * The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST * be compatible with the structure of $_COOKIE. Typically, this data will * be injected at instantiation. * * This method MUST NOT update the related Cookie header of the request * instance, nor related values in the server params. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated cookie values. * * @param array $cookies Array of key/value pairs representing cookies. * @return static */ public function withCookieParams(array $cookies); /** * Retrieve query string arguments. * * Retrieves the deserialized query string arguments, if any. * * Note: the query params might not be in sync with the URI or server * params. If you need to ensure you are only getting the original * values, you may need to parse the query string from `getUri()->getQuery()` * or from the `QUERY_STRING` server param. * * @return array */ public function getQueryParams(); /** * Return an instance with the specified query string arguments. * * These values SHOULD remain immutable over the course of the incoming * request. They MAY be injected during instantiation, such as from PHP's * $_GET superglobal, or MAY be derived from some other value such as the * URI. In cases where the arguments are parsed from the URI, the data * MUST be compatible with what PHP's parse_str() would return for * purposes of how duplicate query parameters are handled, and how nested * sets are handled. * * Setting query string arguments MUST NOT change the URI stored by the * request, nor the values in the server params. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated query string arguments. * * @param array $query Array of query string arguments, typically from * $_GET. * @return static */ public function withQueryParams(array $query); /** * Retrieve normalized file upload data. * * This method returns upload metadata in a normalized tree, with each leaf * an instance of Psr\\Http\\Message\\UploadedFileInterface. * * These values MAY be prepared from $_FILES or the message body during * instantiation, or MAY be injected via withUploadedFiles(). * * @return array An array tree of UploadedFileInterface instances; an empty * array MUST be returned if no data is present. */ public function getUploadedFiles(); /** * Create a new instance with the specified uploaded files. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated body parameters. * * @param array $uploadedFiles An array tree of UploadedFileInterface instances. * @return static * @throws \\InvalidArgumentException if an invalid structure is provided. */ public function withUploadedFiles(array $uploadedFiles); /** * Retrieve any parameters provided in the request body. * * If the request Content-Type is either application/x-www-form-urlencoded * or multipart/form-data, and the request method is POST, this method MUST * return the contents of $_POST. * * Otherwise, this method may return any results of deserializing * the request body content; as parsing returns structured content, the * potential types MUST be arrays or objects only. A null value indicates * the absence of body content. * * @return null|array|object The deserialized body parameters, if any. * These will typically be an array or object. */ public function getParsedBody(); /** * Return an instance with the specified body parameters. * * These MAY be injected during instantiation. * * If the request Content-Type is either application/x-www-form-urlencoded * or multipart/form-data, and the request method is POST, use this method * ONLY to inject the contents of $_POST. * * The data IS NOT REQUIRED to come from $_POST, but MUST be the results of * deserializing the request body content. Deserialization/parsing returns * structured data, and, as such, this method ONLY accepts arrays or objects, * or a null value if nothing was available to parse. * * As an example, if content negotiation determines that the request data * is a JSON payload, this method could be used to create a request * instance with the deserialized parameters. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated body parameters. * * @param null|array|object $data The deserialized body data. This will * typically be in an array or object. * @return static * @throws \\InvalidArgumentException if an unsupported argument type is * provided. */ public function withParsedBody($data); /** * Retrieve attributes derived from the request. * * The request \"attributes\" may be used to allow injection of any * parameters derived from the request: e.g., the results of path * match operations; the results of decrypting cookies; the results of * deserializing non-form-encoded message bodies; etc. Attributes * will be application and request specific, and CAN be mutable. * * @return mixed[] Attributes derived from the request. */ public function getAttributes(); /** * Retrieve a single derived request attribute. * * Retrieves a single derived request attribute as described in * getAttributes(). If the attribute has not been previously set, returns * the default value as provided. * * This method obviates the need for a hasAttribute() method, as it allows * specifying a default value to return if the attribute is not found. * * @see getAttributes() * @param string $name The attribute name. * @param mixed $default Default value to return if the attribute does not exist. * @return mixed */ public function getAttribute($name, $default = null); /** * Return an instance with the specified derived request attribute. * * This method allows setting a single derived request attribute as * described in getAttributes(). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated attribute. * * @see getAttributes() * @param string $name The attribute name. * @param mixed $value The value of the attribute. * @return static */ public function withAttribute($name, $value); /** * Return an instance that removes the specified derived request attribute. * * This method allows removing a single derived request attribute as * described in getAttributes(). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that removes * the attribute. * * @see getAttributes() * @param string $name The attribute name. * @return static */ public function withoutAttribute($name); } 3.3 Psr\\Http\\Message\\ResponseInterface <?php namespace Psr\\Http\\Message; /** * Representation of an outgoing, server-side response. * * Per the HTTP specification, this interface includes properties for * each of the following: * * - Protocol version * - Status code and reason phrase * - Headers * - Message body * * Responses are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. */ interface ResponseInterface extends MessageInterface { /** * Gets the response status code. * * The status code is a 3-digit integer result code of the server's attempt * to understand and satisfy the request. * * @return int Status code. */ public function getStatusCode(); /** * Return an instance with the specified status code and, optionally, reason phrase. * * If no reason phrase is specified, implementations MAY choose to default * to the RFC 7231 or IANA recommended reason phrase for the response's * status code. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated status and reason phrase. * * @see http://tools.ietf.org/html/rfc7231#section-6 * @see http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml * @param int $code The 3-digit integer result code to set. * @param string $reasonPhrase The reason phrase to use with the * provided status code; if none is provided, implementations MAY * use the defaults as suggested in the HTTP specification. * @return static * @throws \\InvalidArgumentException For invalid status code arguments. */ public function withStatus($code, $reasonPhrase = ''); /** * Gets the response reason phrase associated with the status code. * * Because a reason phrase is not a required element in a response * status line, the reason phrase value MAY be empty. Implementations MAY * choose to return the default RFC 7231 recommended reason phrase (or those * listed in the IANA HTTP Status Code Registry) for the response's * status code. * * @see http://tools.ietf.org/html/rfc7231#section-6 * @see http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml * @return string Reason phrase; must return an empty string if none present. */ public function getReasonPhrase(); } 3.4 Psr\\Http\\Message\\StreamInterface <?php namespace Psr\\Http\\Message; /** * Describes a data stream. * * Typically, an instance will wrap a PHP stream; this interface provides * a wrapper around the most common operations, including serialization of * the entire stream to a string. */ interface StreamInterface { /** * Reads all data from the stream into a string, from the beginning to end. * * This method MUST attempt to seek to the beginning of the stream before * reading data and read the stream until the end is reached. * * Warning: This could attempt to load a large amount of data into memory. * * This method MUST NOT raise an exception in order to conform with PHP's * string casting operations. * * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring * @return string */ public function __toString(); /** * Closes the stream and any underlying resources. * * @return void */ public function close(); /** * Separates any underlying resources from the stream. * * After the stream has been detached, the stream is in an unusable state. * * @return resource|null Underlying PHP stream, if any */ public function detach(); /** * Get the size of the stream if known. * * @return int|null Returns the size in bytes if known, or null if unknown. */ public function getSize(); /** * Returns the current position of the file read/write pointer * * @return int Position of the file pointer * @throws \\RuntimeException on error. */ public function tell(); /** * Returns true if the stream is at the end of the stream. * * @return bool */ public function eof(); /** * Returns whether or not the stream is seekable. * * @return bool */ public function isSeekable(); /** * Seek to a position in the stream. * * @see http://www.php.net/manual/en/function.fseek.php * @param int $offset Stream offset * @param int $whence Specifies how the cursor position will be calculated * based on the seek offset. Valid values are identical to the built-in * PHP $whence values for `fseek()`. SEEK_SET: Set position equal to * offset bytes SEEK_CUR: Set position to current location plus offset * SEEK_END: Set position to end-of-stream plus offset. * @throws \\RuntimeException on failure. */ public function seek($offset, $whence = SEEK_SET); /** * Seek to the beginning of the stream. * * If the stream is not seekable, this method will raise an exception; * otherwise, it will perform a seek(0). * * @see seek() * @see http://www.php.net/manual/en/function.fseek.php * @throws \\RuntimeException on failure. */ public function rewind(); /** * Returns whether or not the stream is writable. * * @return bool */ public function isWritable(); /** * Write data to the stream. * * @param string $string The string that is to be written. * @return int Returns the number of bytes written to the stream. * @throws \\RuntimeException on failure. */ public function write($string); /** * Returns whether or not the stream is readable. * * @return bool */ public function isReadable(); /** * Read data from the stream. * * @param int $length Read up to $length bytes from the object and return * them. Fewer than $length bytes may be returned if underlying stream * call returns fewer bytes. * @return string Returns the data read from the stream, or an empty string * if no bytes are available. * @throws \\RuntimeException if an error occurs. */ public function read($length); /** * Returns the remaining contents in a string * * @return string * @throws \\RuntimeException if unable to read. * @throws \\RuntimeException if error occurs while reading. */ public function getContents(); /** * Get stream metadata as an associative array or retrieve a specific key. * * The keys returned are identical to the keys returned from PHP's * stream_get_meta_data() function. * * @see http://php.net/manual/en/function.stream-get-meta-data.php * @param string $key Specific metadata to retrieve. * @return array|mixed|null Returns an associative array if no key is * provided. Returns a specific key value if a key is provided and the * value is found, or null if the key is not found. */ public function getMetadata($key = null); } 3.5 Psr\\Http\\Message\\UriInterface <?php namespace Psr\\Http\\Message; /** * Value object representing a URI. * * This interface is meant to represent URIs according to RFC 3986 and to * provide methods for most common operations. Additional functionality for * working with URIs can be provided on top of the interface or externally. * Its primary use is for HTTP requests, but may also be used in other * contexts. * * Instances of this interface are considered immutable; all methods that * might change state MUST be implemented such that they retain the internal * state of the current instance and return an instance that contains the * changed state. * * Typically the Host header will also be present in the request message. * For server-side requests, the scheme will typically be discoverable in the * server parameters. * * @see http://tools.ietf.org/html/rfc3986 (the URI specification) */ interface UriInterface { /** * Retrieve the scheme component of the URI. * * If no scheme is present, this method MUST return an empty string. * * The value returned MUST be normalized to lowercase, per RFC 3986 * Section 3.1. * * The trailing \":\" character is not part of the scheme and MUST NOT be * added. * * @see https://tools.ietf.org/html/rfc3986#section-3.1 * @return string The URI scheme. */ public function getScheme(); /** * Retrieve the authority component of the URI. * * If no authority information is present, this method MUST return an empty * string. * * The authority syntax of the URI is: * * <pre> * [user-info@]host[:port] * </pre> * * If the port component is not set or is the standard port for the current * scheme, it SHOULD NOT be included. * * @see https://tools.ietf.org/html/rfc3986#section-3.2 * @return string The URI authority, in \"[user-info@]host[:port]\" format. */ public function getAuthority(); /** * Retrieve the user information component of the URI. * * If no user information is present, this method MUST return an empty * string. * * If a user is present in the URI, this will return that value; * additionally, if the password is also present, it will be appended to the * user value, with a colon (\":\") separating the values. * * The trailing \"@\" character is not part of the user information and MUST * NOT be added. * * @return string The URI user information, in \"username[:password]\" format. */ public function getUserInfo(); /** * Retrieve the host component of the URI. * * If no host is present, this method MUST return an empty string. * * The value returned MUST be normalized to lowercase, per RFC 3986 * Section 3.2.2. * * @see http://tools.ietf.org/html/rfc3986#section-3.2.2 * @return string The URI host. */ public function getHost(); /** * Retrieve the port component of the URI. * * If a port is present, and it is non-standard for the current scheme, * this method MUST return it as an integer. If the port is the standard port * used with the current scheme, this method SHOULD return null. * * If no port is present, and no scheme is present, this method MUST return * a null value. * * If no port is present, but a scheme is present, this method MAY return * the standard port for that scheme, but SHOULD return null. * * @return null|int The URI port. */ public function getPort(); /** * Retrieve the path component of the URI. * * The path can either be empty or absolute (starting with a slash) or * rootless (not starting with a slash). Implementations MUST support all * three syntaxes. * * Normally, the empty path \"\" and absolute path \"/\" are considered equal as * defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically * do this normalization because in contexts with a trimmed base path, e.g. * the front controller, this difference becomes significant. It's the task * of the user to handle both \"\" and \"/\". * * The value returned MUST be percent-encoded, but MUST NOT double-encode * any characters. To determine what characters to encode, please refer to * RFC 3986, Sections 2 and 3.3. * * As an example, if the value should include a slash (\"/\") not intended as * delimiter between path segments, that value MUST be passed in encoded * form (e.g., \"%2F\") to the instance. * * @see https://tools.ietf.org/html/rfc3986#section-2 * @see https://tools.ietf.org/html/rfc3986#section-3.3 * @return string The URI path. */ public function getPath(); /** * Retrieve the query string of the URI. * * If no query string is present, this method MUST return an empty string. * * The leading \"?\" character is not part of the query and MUST NOT be * added. * * The value returned MUST be percent-encoded, but MUST NOT double-encode * any characters. To determine what characters to encode, please refer to * RFC 3986, Sections 2 and 3.4. * * As an example, if a value in a key/value pair of the query string should * include an ampersand (\"&\") not intended as a delimiter between values, * that value MUST be passed in encoded form (e.g., \"%26\") to the instance. * * @see https://tools.ietf.org/html/rfc3986#section-2 * @see https://tools.ietf.org/html/rfc3986#section-3.4 * @return string The URI query string. */ public function getQuery(); /** * Retrieve the fragment component of the URI. * * If no fragment is present, this method MUST return an empty string. * * The leading \"#\" character is not part of the fragment and MUST NOT be * added. * * The value returned MUST be percent-encoded, but MUST NOT double-encode * any characters. To determine what characters to encode, please refer to * RFC 3986, Sections 2 and 3.5. * * @see https://tools.ietf.org/html/rfc3986#section-2 * @see https://tools.ietf.org/html/rfc3986#section-3.5 * @return string The URI fragment. */ public function getFragment(); /** * Return an instance with the specified scheme. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified scheme. * * Implementations MUST support the schemes \"http\" and \"https\" case * insensitively, and MAY accommodate other schemes if required. * * An empty scheme is equivalent to removing the scheme. * * @param string $scheme The scheme to use with the new instance. * @return static A new instance with the specified scheme. * @throws \\InvalidArgumentException for invalid schemes. * @throws \\InvalidArgumentException for unsupported schemes. */ public function withScheme($scheme); /** * Return an instance with the specified user information. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified user information. * * Password is optional, but the user information MUST include the * user; an empty string for the user is equivalent to removing user * information. * * @param string $user The user name to use for authority. * @param null|string $password The password associated with $user. * @return static A new instance with the specified user information. */ public function withUserInfo($user, $password = null); /** * Return an instance with the specified host. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified host. * * An empty host value is equivalent to removing the host. * * @param string $host The hostname to use with the new instance. * @return static A new instance with the specified host. * @throws \\InvalidArgumentException for invalid hostnames. */ public function withHost($host); /** * Return an instance with the specified port. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified port. * * Implementations MUST raise an exception for ports outside the * established TCP and UDP port ranges. * * A null value provided for the port is equivalent to removing the port * information. * * @param null|int $port The port to use with the new instance; a null value * removes the port information. * @return static A new instance with the specified port. * @throws \\InvalidArgumentException for invalid ports. */ public function withPort($port); /** * Return an instance with the specified path. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified path. * * The path can either be empty or absolute (starting with a slash) or * rootless (not starting with a slash). Implementations MUST support all * three syntaxes. * * If an HTTP path is intended to be host-relative rather than path-relative * then it must begin with a slash (\"/\"). HTTP paths not starting with a slash * are assumed to be relative to some base path known to the application or * consumer. * * Users can provide both encoded and decoded path characters. * Implementations ensure the correct encoding as outlined in getPath(). * * @param string $path The path to use with the new instance. * @return static A new instance with the specified path. * @throws \\InvalidArgumentException for invalid paths. */ public function withPath($path); /** * Return an instance with the specified query string. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified query string. * * Users can provide both encoded and decoded query characters. * Implementations ensure the correct encoding as outlined in getQuery(). * * An empty query string value is equivalent to removing the query string. * * @param string $query The query string to use with the new instance. * @return static A new instance with the specified query string. * @throws \\InvalidArgumentException for invalid query strings. */ public function withQuery($query); /** * Return an instance with the specified URI fragment. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified URI fragment. * * Users can provide both encoded and decoded fragment characters. * Implementations ensure the correct encoding as outlined in getFragment(). * * An empty fragment value is equivalent to removing the fragment. * * @param string $fragment The fragment to use with the new instance. * @return static A new instance with the specified fragment. */ public function withFragment($fragment); /** * Return the string representation as a URI reference. * * Depending on which components of the URI are present, the resulting * string is either a full URI or relative reference according to RFC 3986, * Section 4.1. The method concatenates the various components of the URI, * using the appropriate delimiters: * * - If a scheme is present, it MUST be suffixed by \":\". * - If an authority is present, it MUST be prefixed by \"//\". * - The path can be concatenated without delimiters. But there are two * cases where the path has to be adjusted to make the URI reference * valid as PHP does not allow to throw an exception in __toString(): * - If the path is rootless and an authority is present, the path MUST * be prefixed by \"/\". * - If the path is starting with more than one \"/\" and no authority is * present, the starting slashes MUST be reduced to one. * - If a query is present, it MUST be prefixed by \"?\". * - If a fragment is present, it MUST be prefixed by \"#\". * * @see http://tools.ietf.org/html/rfc3986#section-4.1 * @return string */ public function __toString(); } 3.6 Psr\\Http\\Message\\UploadedFileInterface <?php namespace Psr\\Http\\Message; /** * Value object representing a file uploaded through an HTTP request. * * Instances of this interface are considered immutable; all methods that * might change state MUST be implemented such that they retain the internal * state of the current instance and return an instance that contains the * changed state. */ interface UploadedFileInterface { /** * Retrieve a stream representing the uploaded file. * * This method MUST return a StreamInterface instance, representing the * uploaded file. The purpose of this method is to allow utilizing native PHP * stream functionality to manipulate the file upload, such as * stream_copy_to_stream() (though the result will need to be decorated in a * native PHP stream wrapper to work with such functions). * * If the moveTo() method has been called previously, this method MUST raise * an exception. * * @return StreamInterface Stream representation of the uploaded file. * @throws \\RuntimeException in cases when no stream is available. * @throws \\RuntimeException in cases when no stream can be created. */ public function getStream(); /** * Move the uploaded file to a new location. * * Use this method as an alternative to move_uploaded_file(). This method is * guaranteed to work in both SAPI and non-SAPI environments. * Implementations must determine which environment they are in, and use the * appropriate method (move_uploaded_file(), rename(), or a stream * operation) to perform the operation. * * $targetPath may be an absolute path, or a relative path. If it is a * relative path, resolution should be the same as used by PHP's rename() * function. * * The original file or stream MUST be removed on completion. * * If this method is called more than once, any subsequent calls MUST raise * an exception. * * When used in an SAPI environment where $_FILES is populated, when writing * files via moveTo(), is_uploaded_file() and move_uploaded_file() SHOULD be * used to ensure permissions and upload status are verified correctly. * * If you wish to move to a stream, use getStream(), as SAPI operations * cannot guarantee writing to stream destinations. * * @see http://php.net/is_uploaded_file * @see http://php.net/move_uploaded_file * @param string $targetPath Path to which to move the uploaded file. * @throws \\InvalidArgumentException if the $targetPath specified is invalid. * @throws \\RuntimeException on any error during the move operation. * @throws \\RuntimeException on the second or subsequent call to the method. */ public function moveTo($targetPath); /** * Retrieve the file size. * * Implementations SHOULD return the value stored in the \"size\" key of * the file in the $_FILES array if available, as PHP calculates this based * on the actual size transmitted. * * @return int|null The file size in bytes or null if unknown. */ public function getSize(); /** * Retrieve the error associated with the uploaded file. * * The return value MUST be one of PHP's UPLOAD_ERR_XXX constants. * * If the file was uploaded successfully, this method MUST return * UPLOAD_ERR_OK. * * Implementations SHOULD return the value stored in the \"error\" key of * the file in the $_FILES array. * * @see http://php.net/manual/en/features.file-upload.errors.php * @return int One of PHP's UPLOAD_ERR_XXX constants. */ public function getError(); /** * Retrieve the filename sent by the client. * * Do not trust the value returned by this method. A client could send * a malicious filename with the intention to corrupt or hack your * application. * * Implementations SHOULD return the value stored in the \"name\" key of * the file in the $_FILES array. * * @return string|null The filename sent by the client or null if none * was provided. */ public function getClientFilename(); /** * Retrieve the media type sent by the client. * * Do not trust the value returned by this method. A client could send * a malicious media type with the intention to corrupt or hack your * application. * * Implementations SHOULD return the value stored in the \"type\" key of * the file in the $_FILES array. * * @return string|null The media type sent by the client or null if none * was provided. */ public function getClientMediaType(); }","title":"HTTP message interfaces"},{"location":"accepted/PSR-7-http-message/#http-message-interfaces","text":"This document describes common interfaces for representing HTTP messages as described in RFC 7230 and RFC 7231 , and URIs for use with HTTP messages as described in RFC 3986 . HTTP messages are the foundation of web development. Web browsers and HTTP clients such as cURL create HTTP request messages that are sent to a web server, which provides an HTTP response message. Server-side code receives an HTTP request message, and returns an HTTP response message. HTTP messages are typically abstracted from the end-user consumer, but as developers, we typically need to know how they are structured and how to access or manipulate them in order to perform our tasks, whether that might be making a request to an HTTP API, or handling an incoming request. Every HTTP request message has a specific form: POST /path HTTP/1.1 Host: example.com foo=bar&baz=bat The first line of a request is the \"request line\", and contains, in order, the HTTP request method, the request target (usually either an absolute URI or a path on the web server), and the HTTP protocol version. This is followed by one or more HTTP headers, an empty line, and the message body. HTTP response messages have a similar structure: HTTP/1.1 200 OK Content-Type: text/plain This is the response body The first line is the \"status line\", and contains, in order, the HTTP protocol version, the HTTP status code, and a \"reason phrase,\" a human-readable description of the status code. Like the request message, this is then followed by one or more HTTP headers, an empty line, and the message body. The interfaces described in this document are abstractions around HTTP messages and the elements composing them. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"HTTP message interfaces"},{"location":"accepted/PSR-7-http-message/#references","text":"RFC 2119 RFC 3986 RFC 7230 RFC 7231","title":"References"},{"location":"accepted/PSR-7-http-message/#1-specification","text":"","title":"1. Specification"},{"location":"accepted/PSR-7-http-message/#11-messages","text":"An HTTP message is either a request from a client to a server or a response from a server to a client. This specification defines interfaces for the HTTP messages Psr\\Http\\Message\\RequestInterface and Psr\\Http\\Message\\ResponseInterface respectively. Both Psr\\Http\\Message\\RequestInterface and Psr\\Http\\Message\\ResponseInterface extend Psr\\Http\\Message\\MessageInterface . While Psr\\Http\\Message\\MessageInterface MAY be implemented directly, implementors SHOULD implement Psr\\Http\\Message\\RequestInterface and Psr\\Http\\Message\\ResponseInterface . From here forward, the namespace Psr\\Http\\Message will be omitted when referring to these interfaces.","title":"1.1 Messages"},{"location":"accepted/PSR-7-http-message/#12-http-headers","text":"","title":"1.2 HTTP Headers"},{"location":"accepted/PSR-7-http-message/#case-insensitive-header-field-names","text":"HTTP messages include case-insensitive header field names. Headers are retrieved by name from classes implementing the MessageInterface in a case-insensitive manner. For example, retrieving the foo header will return the same result as retrieving the FoO header. Similarly, setting the Foo header will overwrite any previously set foo header value. $message = $message->withHeader('foo', 'bar'); echo $message->getHeaderLine('foo'); // Outputs: bar echo $message->getHeaderLine('FOO'); // Outputs: bar $message = $message->withHeader('fOO', 'baz'); echo $message->getHeaderLine('foo'); // Outputs: baz Despite that headers may be retrieved case-insensitively, the original case MUST be preserved by the implementation, in particular when retrieved with getHeaders() . Non-conforming HTTP applications may depend on a certain case, so it is useful for a user to be able to dictate the case of the HTTP headers when creating a request or response.","title":"Case-insensitive header field names"},{"location":"accepted/PSR-7-http-message/#headers-with-multiple-values","text":"In order to accommodate headers with multiple values yet still provide the convenience of working with headers as strings, headers can be retrieved from an instance of a MessageInterface as an array or a string. Use the getHeaderLine() method to retrieve a header value as a string containing all header values of a case-insensitive header by name concatenated with a comma. Use getHeader() to retrieve an array of all the header values for a particular case-insensitive header by name. $message = $message ->withHeader('foo', 'bar') ->withAddedHeader('foo', 'baz'); $header = $message->getHeaderLine('foo'); // $header contains: 'bar,baz' $header = $message->getHeader('foo'); // ['bar', 'baz'] Note: Not all header values can be concatenated using a comma (e.g., Set-Cookie ). When working with such headers, consumers of MessageInterface -based classes SHOULD rely on the getHeader() method for retrieving such multi-valued headers.","title":"Headers with multiple values"},{"location":"accepted/PSR-7-http-message/#host-header","text":"In requests, the Host header typically mirrors the host component of the URI, as well as the host used when establishing the TCP connection. However, the HTTP specification allows the Host header to differ from each of the two. During construction, implementations MUST attempt to set the Host header from a provided URI if no Host header is provided. RequestInterface::withUri() will, by default, replace the returned request's Host header with a Host header matching the host component of the passed UriInterface . You can opt-in to preserving the original state of the Host header by passing true for the second ( $preserveHost ) argument. When this argument is set to true , the returned request will not update the Host header of the returned message -- unless the message contains no Host header. This table illustrates what getHeaderLine('Host') will return for a request returned by withUri() with the $preserveHost argument set to true for various initial requests and URIs. Request Host header 1 Request host component 2 URI host component 3 Result '' '' '' '' '' foo.com '' foo.com '' foo.com bar.com foo.com foo.com '' bar.com foo.com foo.com bar.com baz.com foo.com 1 Host header value prior to operation. 2 Host component of the URI composed in the request prior to the operation. 3 Host component of the URI being injected via withUri() .","title":"Host header"},{"location":"accepted/PSR-7-http-message/#13-streams","text":"HTTP messages consist of a start-line, headers, and a body. The body of an HTTP message can be very small or extremely large. Attempting to represent the body of a message as a string can easily consume more memory than intended because the body must be stored completely in memory. Attempting to store the body of a request or response in memory would preclude the use of that implementation from being able to work with large message bodies. StreamInterface is used in order to hide the implementation details when a stream of data is read from or written to. For situations where a string would be an appropriate message implementation, built-in streams such as php://memory and php://temp may be used. StreamInterface exposes several methods that enable streams to be read from, written to, and traversed effectively. Streams expose their capabilities using three methods: isReadable() , isWritable() , and isSeekable() . These methods can be used by stream collaborators to determine if a stream is capable of their requirements. Each stream instance will have various capabilities: it can be read-only, write-only, or read-write. It can also allow arbitrary random access (seeking forwards or backwards to any location), or only sequential access (for example in the case of a socket, pipe, or callback-based stream). Finally, StreamInterface defines a __toString() method to simplify retrieving or emitting the entire body contents at once. Unlike the request and response interfaces, StreamInterface does not model immutability. In situations where an actual PHP stream is wrapped, immutability is impossible to enforce, as any code that interacts with the resource can potentially change its state (including cursor position, contents, and more). Our recommendation is that implementations use read-only streams for server-side requests and client-side responses. Consumers should be aware of the fact that the stream instance may be mutable, and, as such, could alter the state of the message; when in doubt, create a new stream instance and attach it to a message to enforce state.","title":"1.3 Streams"},{"location":"accepted/PSR-7-http-message/#14-request-targets-and-uris","text":"Per RFC 7230, request messages contain a \"request-target\" as the second segment of the request line. The request target can be one of the following forms: origin-form , which consists of the path, and, if present, the query string; this is often referred to as a relative URL. Messages as transmitted over TCP typically are of origin-form; scheme and authority data are usually only present via CGI variables. absolute-form , which consists of the scheme, authority (\"[user-info@]host[:port]\", where items in brackets are optional), path (if present), query string (if present), and fragment (if present). This is often referred to as an absolute URI, and is the only form to specify a URI as detailed in RFC 3986. This form is commonly used when making requests to HTTP proxies. authority-form , which consists of the authority only. This is typically used in CONNECT requests only, to establish a connection between an HTTP client and a proxy server. asterisk-form , which consists solely of the string * , and which is used with the OPTIONS method to determine the general capabilities of a web server. Aside from these request-targets, there is often an 'effective URL' which is separate from the request target. The effective URL is not transmitted within an HTTP message, but it is used to determine the protocol (http/https), port and hostname for making the request. The effective URL is represented by UriInterface . UriInterface models HTTP and HTTPS URIs as specified in RFC 3986 (the primary use case). The interface provides methods for interacting with the various URI parts, which will obviate the need for repeated parsing of the URI. It also specifies a __toString() method for casting the modeled URI to its string representation. When retrieving the request-target with getRequestTarget() , by default this method will use the URI object and extract all the necessary components to construct the origin-form . The origin-form is by far the most common request-target. If it's desired by an end-user to use one of the other three forms, or if the user wants to explicitly override the request-target, it is possible to do so with withRequestTarget() . Calling this method does not affect the URI, as it is returned from getUri() . For example, a user may want to make an asterisk-form request to a server: $request = $request ->withMethod('OPTIONS') ->withRequestTarget('*') ->withUri(new Uri('https://example.org/')); This example may ultimately result in an HTTP request that looks like this: OPTIONS * HTTP/1.1 But the HTTP client will be able to use the effective URL (from getUri() ), to determine the protocol, hostname and TCP port. An HTTP client MUST ignore the values of Uri::getPath() and Uri::getQuery() , and instead use the value returned by getRequestTarget() , which defaults to concatenating these two values. Clients that choose to not implement 1 or more of the 4 request-target forms, MUST still use getRequestTarget() . These clients MUST reject request-targets they do not support, and MUST NOT fall back on the values from getUri() . RequestInterface provides methods for retrieving the request-target or creating a new instance with the provided request-target. By default, if no request-target is specifically composed in the instance, getRequestTarget() will return the origin-form of the composed URI (or \"/\" if no URI is composed). withRequestTarget($requestTarget) creates a new instance with the specified request target, and thus allows developers to create request messages that represent the other three request-target forms (absolute-form, authority-form, and asterisk-form). When used, the composed URI instance can still be of use, particularly in clients, where it may be used to create the connection to the server.","title":"1.4 Request Targets and URIs"},{"location":"accepted/PSR-7-http-message/#15-server-side-requests","text":"RequestInterface provides the general representation of an HTTP request message. However, server-side requests need additional treatment, due to the nature of the server-side environment. Server-side processing needs to take into account Common Gateway Interface (CGI), and, more specifically, PHP's abstraction and extension of CGI via its Server APIs (SAPI). PHP has provided simplification around input marshaling via superglobals such as: $_COOKIE , which deserializes and provides simplified access to HTTP cookies. $_GET , which deserializes and provides simplified access to query string arguments. $_POST , which deserializes and provides simplified access for urlencoded parameters submitted via HTTP POST; generically, it can be considered the results of parsing the message body. $_FILES , which provides serialized metadata around file uploads. $_SERVER , which provides access to CGI/SAPI environment variables, which commonly include the request method, the request scheme, the request URI, and headers. ServerRequestInterface extends RequestInterface to provide an abstraction around these various superglobals. This practice helps reduce coupling to the superglobals by consumers, and encourages and promotes the ability to test request consumers. The server request provides one additional property, \"attributes\", to allow consumers the ability to introspect, decompose, and match the request against application-specific rules (such as path matching, scheme matching, host matching, etc.). As such, the server request can also provide messaging between multiple request consumers.","title":"1.5 Server-side Requests"},{"location":"accepted/PSR-7-http-message/#16-uploaded-files","text":"ServerRequestInterface specifies a method for retrieving a tree of upload files in a normalized structure, with each leaf an instance of UploadedFileInterface . The $_FILES superglobal has some well-known problems when dealing with arrays of file inputs. As an example, if you have a form that submits an array of files \u2014 e.g., the input name \"files\", submitting files[0] and files[1] \u2014 PHP will represent this as: array( 'files' => array( 'name' => array( 0 => 'file0.txt', 1 => 'file1.html', ), 'type' => array( 0 => 'text/plain', 1 => 'text/html', ), /* etc. */ ), ) instead of the expected: array( 'files' => array( 0 => array( 'name' => 'file0.txt', 'type' => 'text/plain', /* etc. */ ), 1 => array( 'name' => 'file1.html', 'type' => 'text/html', /* etc. */ ), ), ) The result is that consumers need to know this language implementation detail, and write code for gathering the data for a given upload. Additionally, scenarios exist where $_FILES is not populated when file uploads occur: When the HTTP method is not POST . When unit testing. When operating under a non-SAPI environment, such as ReactPHP . In such cases, the data will need to be seeded differently. As examples: A process might parse the message body to discover the file uploads. In such cases, the implementation may choose not to write the file uploads to the file system, but instead wrap them in a stream in order to reduce memory, I/O, and storage overhead. In unit testing scenarios, developers need to be able to stub and/or mock the file upload metadata in order to validate and verify different scenarios. getUploadedFiles() provides the normalized structure for consumers. Implementations are expected to: Aggregate all information for a given file upload, and use it to populate a Psr\\Http\\Message\\UploadedFileInterface instance. Re-create the submitted tree structure, with each leaf being the appropriate Psr\\Http\\Message\\UploadedFileInterface instance for the given location in the tree. The tree structure referenced should mimic the naming structure in which files were submitted. In the simplest example, this might be a single named form element submitted as: <input type=\"file\" name=\"avatar\" /> In this case, the structure in $_FILES would look like: array( 'avatar' => array( 'tmp_name' => 'phpUxcOty', 'name' => 'my-avatar.png', 'size' => 90996, 'type' => 'image/png', 'error' => 0, ), ) The normalized form returned by getUploadedFiles() would be: array( 'avatar' => /* UploadedFileInterface instance */ ) In the case of an input using array notation for the name: <input type=\"file\" name=\"my-form[details][avatar]\" /> $_FILES ends up looking like this: array ( 'my-form' => array ( 'name' => array ( 'details' => array ( 'avatar' => 'my-avatar.png', ), ), 'type' => array ( 'details' => array ( 'avatar' => 'image/png', ), ), 'tmp_name' => array ( 'details' => array ( 'avatar' => 'phpmFLrzD', ), ), 'error' => array ( 'details' => array ( 'avatar' => 0, ), ), 'size' => array ( 'details' => array ( 'avatar' => 90996, ), ), ), ) And the corresponding tree returned by getUploadedFiles() should be: array( 'my-form' => array( 'details' => array( 'avatar' => /* UploadedFileInterface instance */ ), ), ) In some cases, you may specify an array of files: Upload an avatar: <input type=\"file\" name=\"my-form[details][avatars][]\" /> Upload an avatar: <input type=\"file\" name=\"my-form[details][avatars][]\" /> (As an example, JavaScript controls might spawn additional file upload inputs to allow uploading multiple files at once.) In such a case, the specification implementation must aggregate all information related to the file at the given index. The reason is because $_FILES deviates from its normal structure in such cases: array ( 'my-form' => array ( 'name' => array ( 'details' => array ( 'avatars' => array ( 0 => 'my-avatar.png', 1 => 'my-avatar2.png', 2 => 'my-avatar3.png', ), ), ), 'type' => array ( 'details' => array ( 'avatars' => array ( 0 => 'image/png', 1 => 'image/png', 2 => 'image/png', ), ), ), 'tmp_name' => array ( 'details' => array ( 'avatars' => array ( 0 => 'phpmFLrzD', 1 => 'phpV2pBil', 2 => 'php8RUG8v', ), ), ), 'error' => array ( 'details' => array ( 'avatars' => array ( 0 => 0, 1 => 0, 2 => 0, ), ), ), 'size' => array ( 'details' => array ( 'avatars' => array ( 0 => 90996, 1 => 90996, 3 => 90996, ), ), ), ), ) The above $_FILES array would correspond to the following structure as returned by getUploadedFiles() : array( 'my-form' => array( 'details' => array( 'avatars' => array( 0 => /* UploadedFileInterface instance */, 1 => /* UploadedFileInterface instance */, 2 => /* UploadedFileInterface instance */, ), ), ), ) Consumers would access index 1 of the nested array using: $request->getUploadedFiles()['my-form']['details']['avatars'][1]; Because the uploaded files data is derivative (derived from $_FILES or the request body), a mutator method, withUploadedFiles() , is also present in the interface, allowing delegation of the normalization to another process. In the case of the original examples, consumption resembles the following: $file0 = $request->getUploadedFiles()['files'][0]; $file1 = $request->getUploadedFiles()['files'][1]; printf( \"Received the files %s and %s\", $file0->getClientFilename(), $file1->getClientFilename() ); // \"Received the files file0.txt and file1.html\" This proposal also recognizes that implementations may operate in non-SAPI environments. As such, UploadedFileInterface provides methods for ensuring operations will work regardless of environment. In particular: moveTo($targetPath) is provided as a safe and recommended alternative to calling move_uploaded_file() directly on the temporary upload file. Implementations will detect the correct operation to use based on environment. getStream() will return a StreamInterface instance. In non-SAPI environments, one proposed possibility is to parse individual upload files into php://temp streams instead of directly to files; in such cases, no upload file is present. getStream() is therefore guaranteed to work regardless of environment. As examples: // Move a file to an upload directory $filename = sprintf( '%s.%s', create_uuid(), pathinfo($file0->getClientFilename(), PATHINFO_EXTENSION) ); $file0->moveTo(DATA_DIR . '/' . $filename); // Stream a file to Amazon S3. // Assume $s3wrapper is a PHP stream that will write to S3, and that // Psr7StreamWrapper is a class that will decorate a StreamInterface as a PHP // StreamWrapper. $stream = new Psr7StreamWrapper($file1->getStream()); stream_copy_to_stream($stream, $s3wrapper);","title":"1.6 Uploaded files"},{"location":"accepted/PSR-7-http-message/#2-package","text":"The interfaces and classes described are provided as part of the psr/http-message package.","title":"2. Package"},{"location":"accepted/PSR-7-http-message/#3-interfaces","text":"","title":"3. Interfaces"},{"location":"accepted/PSR-7-http-message/#31-psrhttpmessagemessageinterface","text":"<?php namespace Psr\\Http\\Message; /** * HTTP messages consist of requests from a client to a server and responses * from a server to a client. This interface defines the methods common to * each. * * Messages are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. * * @see http://www.ietf.org/rfc/rfc7230.txt * @see http://www.ietf.org/rfc/rfc7231.txt */ interface MessageInterface { /** * Retrieves the HTTP protocol version as a string. * * The string MUST contain only the HTTP version number (e.g., \"1.1\", \"1.0\"). * * @return string HTTP protocol version. */ public function getProtocolVersion(); /** * Return an instance with the specified HTTP protocol version. * * The version string MUST contain only the HTTP version number (e.g., * \"1.1\", \"1.0\"). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new protocol version. * * @param string $version HTTP protocol version * @return static */ public function withProtocolVersion($version); /** * Retrieves all message header values. * * The keys represent the header name as it will be sent over the wire, and * each value is an array of strings associated with the header. * * // Represent the headers as a string * foreach ($message->getHeaders() as $name => $values) { * echo $name . ': ' . implode(', ', $values); * } * * // Emit headers iteratively: * foreach ($message->getHeaders() as $name => $values) { * foreach ($values as $value) { * header(sprintf('%s: %s', $name, $value), false); * } * } * * While header names are not case-sensitive, getHeaders() will preserve the * exact case in which headers were originally specified. * * @return string[][] Returns an associative array of the message's headers. * Each key MUST be a header name, and each value MUST be an array of * strings for that header. */ public function getHeaders(); /** * Checks if a header exists by the given case-insensitive name. * * @param string $name Case-insensitive header field name. * @return bool Returns true if any header names match the given header * name using a case-insensitive string comparison. Returns false if * no matching header name is found in the message. */ public function hasHeader($name); /** * Retrieves a message header value by the given case-insensitive name. * * This method returns an array of all the header values of the given * case-insensitive header name. * * If the header does not appear in the message, this method MUST return an * empty array. * * @param string $name Case-insensitive header field name. * @return string[] An array of string values as provided for the given * header. If the header does not appear in the message, this method MUST * return an empty array. */ public function getHeader($name); /** * Retrieves a comma-separated string of the values for a single header. * * This method returns all of the header values of the given * case-insensitive header name as a string concatenated together using * a comma. * * NOTE: Not all header values may be appropriately represented using * comma concatenation. For such headers, use getHeader() instead * and supply your own delimiter when concatenating. * * If the header does not appear in the message, this method MUST return * an empty string. * * @param string $name Case-insensitive header field name. * @return string A string of values as provided for the given header * concatenated together using a comma. If the header does not appear in * the message, this method MUST return an empty string. */ public function getHeaderLine($name); /** * Return an instance with the provided value replacing the specified header. * * While header names are case-insensitive, the casing of the header will * be preserved by this function, and returned from getHeaders(). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new and/or updated header and value. * * @param string $name Case-insensitive header field name. * @param string|string[] $value Header value(s). * @return static * @throws \\InvalidArgumentException for invalid header names or values. */ public function withHeader($name, $value); /** * Return an instance with the specified header appended with the given value. * * Existing values for the specified header will be maintained. The new * value(s) will be appended to the existing list. If the header did not * exist previously, it will be added. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new header and/or value. * * @param string $name Case-insensitive header field name to add. * @param string|string[] $value Header value(s). * @return static * @throws \\InvalidArgumentException for invalid header names. * @throws \\InvalidArgumentException for invalid header values. */ public function withAddedHeader($name, $value); /** * Return an instance without the specified header. * * Header resolution MUST be done without case-sensitivity. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that removes * the named header. * * @param string $name Case-insensitive header field name to remove. * @return static */ public function withoutHeader($name); /** * Gets the body of the message. * * @return StreamInterface Returns the body as a stream. */ public function getBody(); /** * Return an instance with the specified message body. * * The body MUST be a StreamInterface object. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return a new instance that has the * new body stream. * * @param StreamInterface $body Body. * @return static * @throws \\InvalidArgumentException When the body is not valid. */ public function withBody(StreamInterface $body); }","title":"3.1 Psr\\Http\\Message\\MessageInterface"},{"location":"accepted/PSR-7-http-message/#32-psrhttpmessagerequestinterface","text":"<?php namespace Psr\\Http\\Message; /** * Representation of an outgoing, client-side request. * * Per the HTTP specification, this interface includes properties for * each of the following: * * - Protocol version * - HTTP method * - URI * - Headers * - Message body * * During construction, implementations MUST attempt to set the Host header from * a provided URI if no Host header is provided. * * Requests are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. */ interface RequestInterface extends MessageInterface { /** * Retrieves the message's request target. * * Retrieves the message's request-target either as it will appear (for * clients), as it appeared at request (for servers), or as it was * specified for the instance (see withRequestTarget()). * * In most cases, this will be the origin-form of the composed URI, * unless a value was provided to the concrete implementation (see * withRequestTarget() below). * * If no URI is available, and no request-target has been specifically * provided, this method MUST return the string \"/\". * * @return string */ public function getRequestTarget(); /** * Return an instance with the specific request-target. * * If the request needs a non-origin-form request-target \u2014 e.g., for * specifying an absolute-form, authority-form, or asterisk-form \u2014 * this method may be used to create an instance with the specified * request-target, verbatim. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * changed request target. * * @see http://tools.ietf.org/html/rfc7230#section-5.3 (for the various * request-target forms allowed in request messages) * @param mixed $requestTarget * @return static */ public function withRequestTarget($requestTarget); /** * Retrieves the HTTP method of the request. * * @return string Returns the request method. */ public function getMethod(); /** * Return an instance with the provided HTTP method. * * While HTTP method names are typically all uppercase characters, HTTP * method names are case-sensitive and thus implementations SHOULD NOT * modify the given string. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * changed request method. * * @param string $method Case-sensitive method. * @return static * @throws \\InvalidArgumentException for invalid HTTP methods. */ public function withMethod($method); /** * Retrieves the URI instance. * * This method MUST return a UriInterface instance. * * @see http://tools.ietf.org/html/rfc3986#section-4.3 * @return UriInterface Returns a UriInterface instance * representing the URI of the request. */ public function getUri(); /** * Returns an instance with the provided URI. * * This method MUST update the Host header of the returned request by * default if the URI contains a host component. If the URI does not * contain a host component, any pre-existing Host header MUST be carried * over to the returned request. * * You can opt-in to preserving the original state of the Host header by * setting `$preserveHost` to `true`. When `$preserveHost` is set to * `true`, this method interacts with the Host header in the following ways: * * - If the Host header is missing or empty, and the new URI contains * a host component, this method MUST update the Host header in the returned * request. * - If the Host header is missing or empty, and the new URI does not contain a * host component, this method MUST NOT update the Host header in the returned * request. * - If a Host header is present and non-empty, this method MUST NOT update * the Host header in the returned request. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new UriInterface instance. * * @see http://tools.ietf.org/html/rfc3986#section-4.3 * @param UriInterface $uri New request URI to use. * @param bool $preserveHost Preserve the original state of the Host header. * @return static */ public function withUri(UriInterface $uri, $preserveHost = false); }","title":"3.2 Psr\\Http\\Message\\RequestInterface"},{"location":"accepted/PSR-7-http-message/#321-psrhttpmessageserverrequestinterface","text":"<?php namespace Psr\\Http\\Message; /** * Representation of an incoming, server-side HTTP request. * * Per the HTTP specification, this interface includes properties for * each of the following: * * - Protocol version * - HTTP method * - URI * - Headers * - Message body * * Additionally, it encapsulates all data as it has arrived at the * application from the CGI and/or PHP environment, including: * * - The values represented in $_SERVER. * - Any cookies provided (generally via $_COOKIE) * - Query string arguments (generally via $_GET, or as parsed via parse_str()) * - Upload files, if any (as represented by $_FILES) * - Deserialized body parameters (generally from $_POST) * * $_SERVER values MUST be treated as immutable, as they represent application * state at the time of request; as such, no methods are provided to allow * modification of those values. The other values provide such methods, as they * can be restored from $_SERVER or the request body, and may need treatment * during the application (e.g., body parameters may be deserialized based on * content type). * * Additionally, this interface recognizes the utility of introspecting a * request to derive and match additional parameters (e.g., via URI path * matching, decrypting cookie values, deserializing non-form-encoded body * content, matching authorization headers to users, etc). These parameters * are stored in an \"attributes\" property. * * Requests are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. */ interface ServerRequestInterface extends RequestInterface { /** * Retrieve server parameters. * * Retrieves data related to the incoming request environment, * typically derived from PHP's $_SERVER superglobal. The data IS NOT * REQUIRED to originate from $_SERVER. * * @return array */ public function getServerParams(); /** * Retrieve cookies. * * Retrieves cookies sent by the client to the server. * * The data MUST be compatible with the structure of the $_COOKIE * superglobal. * * @return array */ public function getCookieParams(); /** * Return an instance with the specified cookies. * * The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST * be compatible with the structure of $_COOKIE. Typically, this data will * be injected at instantiation. * * This method MUST NOT update the related Cookie header of the request * instance, nor related values in the server params. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated cookie values. * * @param array $cookies Array of key/value pairs representing cookies. * @return static */ public function withCookieParams(array $cookies); /** * Retrieve query string arguments. * * Retrieves the deserialized query string arguments, if any. * * Note: the query params might not be in sync with the URI or server * params. If you need to ensure you are only getting the original * values, you may need to parse the query string from `getUri()->getQuery()` * or from the `QUERY_STRING` server param. * * @return array */ public function getQueryParams(); /** * Return an instance with the specified query string arguments. * * These values SHOULD remain immutable over the course of the incoming * request. They MAY be injected during instantiation, such as from PHP's * $_GET superglobal, or MAY be derived from some other value such as the * URI. In cases where the arguments are parsed from the URI, the data * MUST be compatible with what PHP's parse_str() would return for * purposes of how duplicate query parameters are handled, and how nested * sets are handled. * * Setting query string arguments MUST NOT change the URI stored by the * request, nor the values in the server params. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated query string arguments. * * @param array $query Array of query string arguments, typically from * $_GET. * @return static */ public function withQueryParams(array $query); /** * Retrieve normalized file upload data. * * This method returns upload metadata in a normalized tree, with each leaf * an instance of Psr\\Http\\Message\\UploadedFileInterface. * * These values MAY be prepared from $_FILES or the message body during * instantiation, or MAY be injected via withUploadedFiles(). * * @return array An array tree of UploadedFileInterface instances; an empty * array MUST be returned if no data is present. */ public function getUploadedFiles(); /** * Create a new instance with the specified uploaded files. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated body parameters. * * @param array $uploadedFiles An array tree of UploadedFileInterface instances. * @return static * @throws \\InvalidArgumentException if an invalid structure is provided. */ public function withUploadedFiles(array $uploadedFiles); /** * Retrieve any parameters provided in the request body. * * If the request Content-Type is either application/x-www-form-urlencoded * or multipart/form-data, and the request method is POST, this method MUST * return the contents of $_POST. * * Otherwise, this method may return any results of deserializing * the request body content; as parsing returns structured content, the * potential types MUST be arrays or objects only. A null value indicates * the absence of body content. * * @return null|array|object The deserialized body parameters, if any. * These will typically be an array or object. */ public function getParsedBody(); /** * Return an instance with the specified body parameters. * * These MAY be injected during instantiation. * * If the request Content-Type is either application/x-www-form-urlencoded * or multipart/form-data, and the request method is POST, use this method * ONLY to inject the contents of $_POST. * * The data IS NOT REQUIRED to come from $_POST, but MUST be the results of * deserializing the request body content. Deserialization/parsing returns * structured data, and, as such, this method ONLY accepts arrays or objects, * or a null value if nothing was available to parse. * * As an example, if content negotiation determines that the request data * is a JSON payload, this method could be used to create a request * instance with the deserialized parameters. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated body parameters. * * @param null|array|object $data The deserialized body data. This will * typically be in an array or object. * @return static * @throws \\InvalidArgumentException if an unsupported argument type is * provided. */ public function withParsedBody($data); /** * Retrieve attributes derived from the request. * * The request \"attributes\" may be used to allow injection of any * parameters derived from the request: e.g., the results of path * match operations; the results of decrypting cookies; the results of * deserializing non-form-encoded message bodies; etc. Attributes * will be application and request specific, and CAN be mutable. * * @return mixed[] Attributes derived from the request. */ public function getAttributes(); /** * Retrieve a single derived request attribute. * * Retrieves a single derived request attribute as described in * getAttributes(). If the attribute has not been previously set, returns * the default value as provided. * * This method obviates the need for a hasAttribute() method, as it allows * specifying a default value to return if the attribute is not found. * * @see getAttributes() * @param string $name The attribute name. * @param mixed $default Default value to return if the attribute does not exist. * @return mixed */ public function getAttribute($name, $default = null); /** * Return an instance with the specified derived request attribute. * * This method allows setting a single derived request attribute as * described in getAttributes(). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated attribute. * * @see getAttributes() * @param string $name The attribute name. * @param mixed $value The value of the attribute. * @return static */ public function withAttribute($name, $value); /** * Return an instance that removes the specified derived request attribute. * * This method allows removing a single derived request attribute as * described in getAttributes(). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that removes * the attribute. * * @see getAttributes() * @param string $name The attribute name. * @return static */ public function withoutAttribute($name); }","title":"3.2.1 Psr\\Http\\Message\\ServerRequestInterface"},{"location":"accepted/PSR-7-http-message/#33-psrhttpmessageresponseinterface","text":"<?php namespace Psr\\Http\\Message; /** * Representation of an outgoing, server-side response. * * Per the HTTP specification, this interface includes properties for * each of the following: * * - Protocol version * - Status code and reason phrase * - Headers * - Message body * * Responses are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. */ interface ResponseInterface extends MessageInterface { /** * Gets the response status code. * * The status code is a 3-digit integer result code of the server's attempt * to understand and satisfy the request. * * @return int Status code. */ public function getStatusCode(); /** * Return an instance with the specified status code and, optionally, reason phrase. * * If no reason phrase is specified, implementations MAY choose to default * to the RFC 7231 or IANA recommended reason phrase for the response's * status code. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated status and reason phrase. * * @see http://tools.ietf.org/html/rfc7231#section-6 * @see http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml * @param int $code The 3-digit integer result code to set. * @param string $reasonPhrase The reason phrase to use with the * provided status code; if none is provided, implementations MAY * use the defaults as suggested in the HTTP specification. * @return static * @throws \\InvalidArgumentException For invalid status code arguments. */ public function withStatus($code, $reasonPhrase = ''); /** * Gets the response reason phrase associated with the status code. * * Because a reason phrase is not a required element in a response * status line, the reason phrase value MAY be empty. Implementations MAY * choose to return the default RFC 7231 recommended reason phrase (or those * listed in the IANA HTTP Status Code Registry) for the response's * status code. * * @see http://tools.ietf.org/html/rfc7231#section-6 * @see http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml * @return string Reason phrase; must return an empty string if none present. */ public function getReasonPhrase(); }","title":"3.3 Psr\\Http\\Message\\ResponseInterface"},{"location":"accepted/PSR-7-http-message/#34-psrhttpmessagestreaminterface","text":"<?php namespace Psr\\Http\\Message; /** * Describes a data stream. * * Typically, an instance will wrap a PHP stream; this interface provides * a wrapper around the most common operations, including serialization of * the entire stream to a string. */ interface StreamInterface { /** * Reads all data from the stream into a string, from the beginning to end. * * This method MUST attempt to seek to the beginning of the stream before * reading data and read the stream until the end is reached. * * Warning: This could attempt to load a large amount of data into memory. * * This method MUST NOT raise an exception in order to conform with PHP's * string casting operations. * * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring * @return string */ public function __toString(); /** * Closes the stream and any underlying resources. * * @return void */ public function close(); /** * Separates any underlying resources from the stream. * * After the stream has been detached, the stream is in an unusable state. * * @return resource|null Underlying PHP stream, if any */ public function detach(); /** * Get the size of the stream if known. * * @return int|null Returns the size in bytes if known, or null if unknown. */ public function getSize(); /** * Returns the current position of the file read/write pointer * * @return int Position of the file pointer * @throws \\RuntimeException on error. */ public function tell(); /** * Returns true if the stream is at the end of the stream. * * @return bool */ public function eof(); /** * Returns whether or not the stream is seekable. * * @return bool */ public function isSeekable(); /** * Seek to a position in the stream. * * @see http://www.php.net/manual/en/function.fseek.php * @param int $offset Stream offset * @param int $whence Specifies how the cursor position will be calculated * based on the seek offset. Valid values are identical to the built-in * PHP $whence values for `fseek()`. SEEK_SET: Set position equal to * offset bytes SEEK_CUR: Set position to current location plus offset * SEEK_END: Set position to end-of-stream plus offset. * @throws \\RuntimeException on failure. */ public function seek($offset, $whence = SEEK_SET); /** * Seek to the beginning of the stream. * * If the stream is not seekable, this method will raise an exception; * otherwise, it will perform a seek(0). * * @see seek() * @see http://www.php.net/manual/en/function.fseek.php * @throws \\RuntimeException on failure. */ public function rewind(); /** * Returns whether or not the stream is writable. * * @return bool */ public function isWritable(); /** * Write data to the stream. * * @param string $string The string that is to be written. * @return int Returns the number of bytes written to the stream. * @throws \\RuntimeException on failure. */ public function write($string); /** * Returns whether or not the stream is readable. * * @return bool */ public function isReadable(); /** * Read data from the stream. * * @param int $length Read up to $length bytes from the object and return * them. Fewer than $length bytes may be returned if underlying stream * call returns fewer bytes. * @return string Returns the data read from the stream, or an empty string * if no bytes are available. * @throws \\RuntimeException if an error occurs. */ public function read($length); /** * Returns the remaining contents in a string * * @return string * @throws \\RuntimeException if unable to read. * @throws \\RuntimeException if error occurs while reading. */ public function getContents(); /** * Get stream metadata as an associative array or retrieve a specific key. * * The keys returned are identical to the keys returned from PHP's * stream_get_meta_data() function. * * @see http://php.net/manual/en/function.stream-get-meta-data.php * @param string $key Specific metadata to retrieve. * @return array|mixed|null Returns an associative array if no key is * provided. Returns a specific key value if a key is provided and the * value is found, or null if the key is not found. */ public function getMetadata($key = null); }","title":"3.4 Psr\\Http\\Message\\StreamInterface"},{"location":"accepted/PSR-7-http-message/#35-psrhttpmessageuriinterface","text":"<?php namespace Psr\\Http\\Message; /** * Value object representing a URI. * * This interface is meant to represent URIs according to RFC 3986 and to * provide methods for most common operations. Additional functionality for * working with URIs can be provided on top of the interface or externally. * Its primary use is for HTTP requests, but may also be used in other * contexts. * * Instances of this interface are considered immutable; all methods that * might change state MUST be implemented such that they retain the internal * state of the current instance and return an instance that contains the * changed state. * * Typically the Host header will also be present in the request message. * For server-side requests, the scheme will typically be discoverable in the * server parameters. * * @see http://tools.ietf.org/html/rfc3986 (the URI specification) */ interface UriInterface { /** * Retrieve the scheme component of the URI. * * If no scheme is present, this method MUST return an empty string. * * The value returned MUST be normalized to lowercase, per RFC 3986 * Section 3.1. * * The trailing \":\" character is not part of the scheme and MUST NOT be * added. * * @see https://tools.ietf.org/html/rfc3986#section-3.1 * @return string The URI scheme. */ public function getScheme(); /** * Retrieve the authority component of the URI. * * If no authority information is present, this method MUST return an empty * string. * * The authority syntax of the URI is: * * <pre> * [user-info@]host[:port] * </pre> * * If the port component is not set or is the standard port for the current * scheme, it SHOULD NOT be included. * * @see https://tools.ietf.org/html/rfc3986#section-3.2 * @return string The URI authority, in \"[user-info@]host[:port]\" format. */ public function getAuthority(); /** * Retrieve the user information component of the URI. * * If no user information is present, this method MUST return an empty * string. * * If a user is present in the URI, this will return that value; * additionally, if the password is also present, it will be appended to the * user value, with a colon (\":\") separating the values. * * The trailing \"@\" character is not part of the user information and MUST * NOT be added. * * @return string The URI user information, in \"username[:password]\" format. */ public function getUserInfo(); /** * Retrieve the host component of the URI. * * If no host is present, this method MUST return an empty string. * * The value returned MUST be normalized to lowercase, per RFC 3986 * Section 3.2.2. * * @see http://tools.ietf.org/html/rfc3986#section-3.2.2 * @return string The URI host. */ public function getHost(); /** * Retrieve the port component of the URI. * * If a port is present, and it is non-standard for the current scheme, * this method MUST return it as an integer. If the port is the standard port * used with the current scheme, this method SHOULD return null. * * If no port is present, and no scheme is present, this method MUST return * a null value. * * If no port is present, but a scheme is present, this method MAY return * the standard port for that scheme, but SHOULD return null. * * @return null|int The URI port. */ public function getPort(); /** * Retrieve the path component of the URI. * * The path can either be empty or absolute (starting with a slash) or * rootless (not starting with a slash). Implementations MUST support all * three syntaxes. * * Normally, the empty path \"\" and absolute path \"/\" are considered equal as * defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically * do this normalization because in contexts with a trimmed base path, e.g. * the front controller, this difference becomes significant. It's the task * of the user to handle both \"\" and \"/\". * * The value returned MUST be percent-encoded, but MUST NOT double-encode * any characters. To determine what characters to encode, please refer to * RFC 3986, Sections 2 and 3.3. * * As an example, if the value should include a slash (\"/\") not intended as * delimiter between path segments, that value MUST be passed in encoded * form (e.g., \"%2F\") to the instance. * * @see https://tools.ietf.org/html/rfc3986#section-2 * @see https://tools.ietf.org/html/rfc3986#section-3.3 * @return string The URI path. */ public function getPath(); /** * Retrieve the query string of the URI. * * If no query string is present, this method MUST return an empty string. * * The leading \"?\" character is not part of the query and MUST NOT be * added. * * The value returned MUST be percent-encoded, but MUST NOT double-encode * any characters. To determine what characters to encode, please refer to * RFC 3986, Sections 2 and 3.4. * * As an example, if a value in a key/value pair of the query string should * include an ampersand (\"&\") not intended as a delimiter between values, * that value MUST be passed in encoded form (e.g., \"%26\") to the instance. * * @see https://tools.ietf.org/html/rfc3986#section-2 * @see https://tools.ietf.org/html/rfc3986#section-3.4 * @return string The URI query string. */ public function getQuery(); /** * Retrieve the fragment component of the URI. * * If no fragment is present, this method MUST return an empty string. * * The leading \"#\" character is not part of the fragment and MUST NOT be * added. * * The value returned MUST be percent-encoded, but MUST NOT double-encode * any characters. To determine what characters to encode, please refer to * RFC 3986, Sections 2 and 3.5. * * @see https://tools.ietf.org/html/rfc3986#section-2 * @see https://tools.ietf.org/html/rfc3986#section-3.5 * @return string The URI fragment. */ public function getFragment(); /** * Return an instance with the specified scheme. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified scheme. * * Implementations MUST support the schemes \"http\" and \"https\" case * insensitively, and MAY accommodate other schemes if required. * * An empty scheme is equivalent to removing the scheme. * * @param string $scheme The scheme to use with the new instance. * @return static A new instance with the specified scheme. * @throws \\InvalidArgumentException for invalid schemes. * @throws \\InvalidArgumentException for unsupported schemes. */ public function withScheme($scheme); /** * Return an instance with the specified user information. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified user information. * * Password is optional, but the user information MUST include the * user; an empty string for the user is equivalent to removing user * information. * * @param string $user The user name to use for authority. * @param null|string $password The password associated with $user. * @return static A new instance with the specified user information. */ public function withUserInfo($user, $password = null); /** * Return an instance with the specified host. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified host. * * An empty host value is equivalent to removing the host. * * @param string $host The hostname to use with the new instance. * @return static A new instance with the specified host. * @throws \\InvalidArgumentException for invalid hostnames. */ public function withHost($host); /** * Return an instance with the specified port. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified port. * * Implementations MUST raise an exception for ports outside the * established TCP and UDP port ranges. * * A null value provided for the port is equivalent to removing the port * information. * * @param null|int $port The port to use with the new instance; a null value * removes the port information. * @return static A new instance with the specified port. * @throws \\InvalidArgumentException for invalid ports. */ public function withPort($port); /** * Return an instance with the specified path. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified path. * * The path can either be empty or absolute (starting with a slash) or * rootless (not starting with a slash). Implementations MUST support all * three syntaxes. * * If an HTTP path is intended to be host-relative rather than path-relative * then it must begin with a slash (\"/\"). HTTP paths not starting with a slash * are assumed to be relative to some base path known to the application or * consumer. * * Users can provide both encoded and decoded path characters. * Implementations ensure the correct encoding as outlined in getPath(). * * @param string $path The path to use with the new instance. * @return static A new instance with the specified path. * @throws \\InvalidArgumentException for invalid paths. */ public function withPath($path); /** * Return an instance with the specified query string. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified query string. * * Users can provide both encoded and decoded query characters. * Implementations ensure the correct encoding as outlined in getQuery(). * * An empty query string value is equivalent to removing the query string. * * @param string $query The query string to use with the new instance. * @return static A new instance with the specified query string. * @throws \\InvalidArgumentException for invalid query strings. */ public function withQuery($query); /** * Return an instance with the specified URI fragment. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified URI fragment. * * Users can provide both encoded and decoded fragment characters. * Implementations ensure the correct encoding as outlined in getFragment(). * * An empty fragment value is equivalent to removing the fragment. * * @param string $fragment The fragment to use with the new instance. * @return static A new instance with the specified fragment. */ public function withFragment($fragment); /** * Return the string representation as a URI reference. * * Depending on which components of the URI are present, the resulting * string is either a full URI or relative reference according to RFC 3986, * Section 4.1. The method concatenates the various components of the URI, * using the appropriate delimiters: * * - If a scheme is present, it MUST be suffixed by \":\". * - If an authority is present, it MUST be prefixed by \"//\". * - The path can be concatenated without delimiters. But there are two * cases where the path has to be adjusted to make the URI reference * valid as PHP does not allow to throw an exception in __toString(): * - If the path is rootless and an authority is present, the path MUST * be prefixed by \"/\". * - If the path is starting with more than one \"/\" and no authority is * present, the starting slashes MUST be reduced to one. * - If a query is present, it MUST be prefixed by \"?\". * - If a fragment is present, it MUST be prefixed by \"#\". * * @see http://tools.ietf.org/html/rfc3986#section-4.1 * @return string */ public function __toString(); }","title":"3.5 Psr\\Http\\Message\\UriInterface"},{"location":"accepted/PSR-7-http-message/#36-psrhttpmessageuploadedfileinterface","text":"<?php namespace Psr\\Http\\Message; /** * Value object representing a file uploaded through an HTTP request. * * Instances of this interface are considered immutable; all methods that * might change state MUST be implemented such that they retain the internal * state of the current instance and return an instance that contains the * changed state. */ interface UploadedFileInterface { /** * Retrieve a stream representing the uploaded file. * * This method MUST return a StreamInterface instance, representing the * uploaded file. The purpose of this method is to allow utilizing native PHP * stream functionality to manipulate the file upload, such as * stream_copy_to_stream() (though the result will need to be decorated in a * native PHP stream wrapper to work with such functions). * * If the moveTo() method has been called previously, this method MUST raise * an exception. * * @return StreamInterface Stream representation of the uploaded file. * @throws \\RuntimeException in cases when no stream is available. * @throws \\RuntimeException in cases when no stream can be created. */ public function getStream(); /** * Move the uploaded file to a new location. * * Use this method as an alternative to move_uploaded_file(). This method is * guaranteed to work in both SAPI and non-SAPI environments. * Implementations must determine which environment they are in, and use the * appropriate method (move_uploaded_file(), rename(), or a stream * operation) to perform the operation. * * $targetPath may be an absolute path, or a relative path. If it is a * relative path, resolution should be the same as used by PHP's rename() * function. * * The original file or stream MUST be removed on completion. * * If this method is called more than once, any subsequent calls MUST raise * an exception. * * When used in an SAPI environment where $_FILES is populated, when writing * files via moveTo(), is_uploaded_file() and move_uploaded_file() SHOULD be * used to ensure permissions and upload status are verified correctly. * * If you wish to move to a stream, use getStream(), as SAPI operations * cannot guarantee writing to stream destinations. * * @see http://php.net/is_uploaded_file * @see http://php.net/move_uploaded_file * @param string $targetPath Path to which to move the uploaded file. * @throws \\InvalidArgumentException if the $targetPath specified is invalid. * @throws \\RuntimeException on any error during the move operation. * @throws \\RuntimeException on the second or subsequent call to the method. */ public function moveTo($targetPath); /** * Retrieve the file size. * * Implementations SHOULD return the value stored in the \"size\" key of * the file in the $_FILES array if available, as PHP calculates this based * on the actual size transmitted. * * @return int|null The file size in bytes or null if unknown. */ public function getSize(); /** * Retrieve the error associated with the uploaded file. * * The return value MUST be one of PHP's UPLOAD_ERR_XXX constants. * * If the file was uploaded successfully, this method MUST return * UPLOAD_ERR_OK. * * Implementations SHOULD return the value stored in the \"error\" key of * the file in the $_FILES array. * * @see http://php.net/manual/en/features.file-upload.errors.php * @return int One of PHP's UPLOAD_ERR_XXX constants. */ public function getError(); /** * Retrieve the filename sent by the client. * * Do not trust the value returned by this method. A client could send * a malicious filename with the intention to corrupt or hack your * application. * * Implementations SHOULD return the value stored in the \"name\" key of * the file in the $_FILES array. * * @return string|null The filename sent by the client or null if none * was provided. */ public function getClientFilename(); /** * Retrieve the media type sent by the client. * * Do not trust the value returned by this method. A client could send * a malicious media type with the intention to corrupt or hack your * application. * * Implementations SHOULD return the value stored in the \"type\" key of * the file in the $_FILES array. * * @return string|null The media type sent by the client or null if none * was provided. */ public function getClientMediaType(); }","title":"3.6 Psr\\Http\\Message\\UploadedFileInterface"}]}